<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" href="src/icons/xmas.ico" type="image/x-icon">
    <link rel="shortcut icon" href="src/icons/xmas.ico" type="image/x-icon">

    <!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>Technical Interview</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
            integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <nav>
        <div class="nav-wrapper">
            <a href="#" data-target="mobile-demo" class="sidenav-trigger"><i class="material-icons">menu</i></a>
            <ul class="right hide-on-med-and-down">
                <li><a href="#js">JS</a></li>
                <li><a href="#js">HTML</a></li>
            </ul>
        </div>
    </nav>

    <ul class="sidenav" id="mobile-demo">
        <li>
            <a href="#js">JS</a>
        </li>
        <li>
            <a href="#html">HTML</a>
        </li>
    </ul>
</header>
<div class="container">

    <h5 id="js">JS</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке "Tree shaking"?
            </div>
            <div class="collapsible-body">
                <p>Tree shaking - це термін, який часто використовується в контексті JavaScript для опису видалення "мертвого" коду.
                    Кандидатам на співбесіді слід розуміти, як це працює і які переваги це має.</p>

                <p>Tree shaking - це метод оптимізації нашого JavaScript-пакета, виключаючи невикористовувані експорти в нашому проекті, тим
                    самим зменшуючи розмір кінцевого пакета. У системі збірки модулів, такій як Webpack чи Rollup, вона статично аналізує
                    всі імпорт та експорт в нашому вихідному коді та видаляє невикористаний код при створенні пакета.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="html">HTML</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Що таке DOCTYPE і навіщо його
                використовують?
            </div>
            <div class="collapsible-body">
                DOCTYPE (Document Type Definition) - це інструкція, яку використовують у HTML-документах для визначення
                типу документа та версії HTML або XHTML, якою він відповідає. Вона розміщується на самому початку
                HTML-коду, перед будь-якими тегами html, head, чи body.
                < !DOCTYPE html > < html lang="uk" > < head > < body > < /html ><br>
                Основна роль DOCTYPE:
                <ol>
                    <li>
                        Визначення режиму рендерингу:

                        Деякі браузери мають різні режими рендерингу для старих версій HTML. DOCTYPE допомагає браузерам
                        вибрати правильний режим рендерингу для забезпечення сумісності із стандартами.

                    </li>
                    <li>
                        Забезпечення сумісності:

                        Декларація DOCTYPE допомагає визначити версію HTML або XHTML, що використовується в документі.
                        Це важливо для того, щоб браузери могли коректно відображати сторінку відповідно до відповідних
                        стандартів.
                    </li>
                    <li>
                        Уникнення квірксів:

                        Зазначення DOCTYPE допомагає уникнути квірксів (різних режимів рендерингу), які можуть виникати
                        при відображенні сторінки в різних браузерах.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які основні теги структури HTML-сторінки?
            </div>
            <div class="collapsible-body">
                <ol>
                    <li><p><code>&lt;!DOCTYPE html&gt;</code>: Визначає тип документа та версію HTML.</p></li>
                    <li><p><code>&lt;html&gt;</code>: Визначає початок та кінець HTML-документа.</p></li>
                    <li><p><code>&lt;head&gt;</code>: Містить мета-інформацію про документ, таку як заголовок,
                        мета-теги, посилання на зовнішні ресурси (стилі, скрипти).</p></li>
                    <li><p><code>&lt;title&gt;</code>: Визначає заголовок сторінки, який відображається в заголовку
                        вкладки браузера або на панелі завдань.</p></li>
                    <li><p><code>&lt;meta charset="UTF-8"&gt;</code>: Вказує кодування символів для сторінки, зазвичай
                        встановлюється на UTF-8.</p></li>
                    <li><p><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>:
                        Встановлює мета-тег для налаштування ширини екрану та масштабування на мобільних пристроях.</p>
                    </li>
                    <li><p><code>&lt;body&gt;</code>: Містить основний вміст сторінки, такий як текст, зображення,
                        таблиці, форми та інші елементи.</p></li>
                    <li><p><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code>: Визначають заголовки різних рівнів.
                        <code>&lt;h1&gt;</code> - найважливіший, <code>&lt;h6&gt;</code> - найменший.</p></li>
                    <li><p><code>&lt;p&gt;</code>: Визначає абзац тексту.</p></li>
                    <li><p><code>&lt;a&gt;</code>: Створює посилання на іншу сторінку або ресурс.</p></li>
                    <li><p><code>&lt;img&gt;</code>: Вставляє зображення на сторінку.</p></li>
                    <li><p><code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>: Визначають
                        ненумерований (ul) або нумерований (ol) список та його елементи (li).</p></li>
                    <li><p><code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, <code>&lt;td&gt;</code>:
                        Визначають таблицю та її елементи.</p></li>
                    <li><p><code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>:
                        Визначають форму та її елементи для введення даних.</p></li>
                    <li><p><code>&lt;div&gt;</code>: Використовується для групування та стилізації інших елементів.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке семантичні теги та навіщо вони потрібні? Наведіть приклади таких тегів.
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>Семантичні теги в HTML це
                    елементи, які мають смислове значення та описують зміст, структуру та значення елементів на
                    сторінці. Використання семантичних тегів допомагає робити HTML-код більш зрозумілим для розробників
                    та браузерів, покращує доступність та SEO.</p>
                    <p>Основні переваги семантичних тегів:</p>
                    <ol>
                        <li><p><strong>Зрозумілість коду:</strong> Імена семантичних тегів самі по собі вказують на їхнє
                            значення, що робить код більш зрозумілим і легким для інших розробників читати.</p></li>
                        <li><p><strong>SEO:</strong> Використання семантичних тегів може поліпшити індексацію сторінок
                            пошуковими системами.</p></li>
                        <li><p><strong>Доступність:</strong> Семантичні теги допомагають робити веб-сайти більш
                            доступними для користувачів з вадами зору, а також для інших асистивних технологій.</p></li>
                    </ol>
                    <p>Приклади семантичних тегів:</p>
                    <ol>
                        <li><p><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</p></li>
                        <li><p><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</p></li>
                        <li><p><code>&lt;main&gt;</code>: Визначає основний контент сторінки.</p></li>
                        <li><p><code>&lt;article&gt;</code>: Визначає незалежний, самостійний контент, який може бути
                            повністю розміщений на іншому ресурсі.</p></li>
                        <li><p><code>&lt;section&gt;</code>: Визначає секцію документа.</p></li>
                        <li><p><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного
                            контенту (наприклад, бічні бари, реклама).</p></li>
                        <li><p><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</p></li>
                        <li><p><code>&lt;figure&gt;</code> і <code>&lt;figcaption&gt;</code>: Визначають зображення або
                            мультимедійний контент та його підпис.</p></li>
                        <li><p><code>&lt;time&gt;</code>: Визначає дату або час.</p></li>
                    </ol>
                    <p>Ці теги допомагають створювати структурований та змістовно збагачений HTML, що полегшує розуміння
                        структури документа як розробниками, так і браузерами та іншими агентами.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які теги добавили в HTML5?
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>HTML5 вніс багато нових тегів і
                    атрибутів, що значно поліпшили можливості мови та розширили функціональність веб-розробки. Ось деякі
                    з нових тегів, які були додані в HTML5:</p>
                    <ol>
                        <li><p><strong>Семантичні блокові елементи:</strong></p>
                            <ul>
                                <li><code>&lt;article&gt;</code>: Визначає самостійний контент, який може існувати
                                    незалежно від інших частин документа.
                                </li>
                                <li><code>&lt;section&gt;</code>: Визначає секцію документа.</li>
                                <li><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</li>
                                <li><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</li>
                                <li><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</li>
                                <li><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного
                                    контенту (наприклад, бічні бари, реклама).
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Елементи для введення форм:</strong></p>
                            <ul>
                                <li><code>&lt;datalist&gt;</code>: Визначає список варіантів для елемента <code>&lt;input&gt;</code>
                                    з атрибутом <code>list</code>.
                                </li>
                                <li><code>&lt;output&gt;</code>: Визначає область виведення для результатів форми.</li>
                            </ul>
                        </li>
                        <li><p><strong>Мультимедійні теги:</strong></p>
                            <ul>
                                <li><code>&lt;audio&gt;</code>: Визначає аудіо-елемент для вставки звукового контенту.
                                </li>
                                <li><code>&lt;video&gt;</code>: Визначає відео-елемент для вставки відео-контенту.</li>
                            </ul>
                        </li>
                        <li><p><strong>Графічні теги:</strong></p>
                            <ul>
                                <li><code>&lt;canvas&gt;</code>: Визначає область, на якій можна малювати за допомогою
                                    JavaScript.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Теги для роботи з ресурсами:</strong></p>
                            <ul>
                                <li><code>&lt;embed&gt;</code>: Вставляє зовнішні ресурси, такі як плагіни, аудіо або
                                    відео.
                                </li>
                                <li><code>&lt;source&gt;</code>: Вказує ресурс для вкладання у елементи <code>&lt;audio&gt;</code>
                                    та <code>&lt;video&gt;</code>.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Атрибути форм:</strong></p>
                            <ul>
                                <li><code>autocomplete</code>: Атрибут для управління автозаповненням полів форми.</li>
                                <li><code>placeholder</code>: Атрибут для встановлення підказки для користувача у полі
                                    введення.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Атрибути гіперпосилань:</strong></p>
                            <ul>
                                <li><code>download</code>: Атрибут для вказання, що посилання призначене для
                                    завантаження файлу замість переходу за ним.
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p>Це лише деякі приклади тегів та атрибутів, які були додані в HTML5. Ці зміни спрямовані на
                        поліпшення структури документа, роботи з мультимедіа та забезпечення більшої доступності та
                        можливостей веб-розробникам.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке data-атрибути, в яких випадках їх використовуєте?
            </div>
            <div class="collapsible-body">
                data-атрибути - це спеціальні атрибути HTML-тегів, які починаються з префіксу data-. Вони призначені для
                зберігання власних даних в елементах HTML, які можуть бути використані для додаткового опису або
                ідентифікації елементів. Використання data-атрибутів дозволяє розробникам зберігати інформацію без
                втручання у стандартні атрибути. Деякі випадки використання data-атрибутів:
                <ol>
                    <li>JavaScript: За допомогою data-атрибутів можна зберігати дані, які JavaScript потрібно
                        використовувати. Наприклад, для зберігання ідентифікаторів чи параметрів, які використовуються в
                        динамічних скриптах. JavaScript може отримати значення data-action для подальших дій.
                    </li>
                    <li>CSS: Можна використовувати data-атрибути для створення CSS-селекторів або передачі додаткових
                        стилів. В CSS: .user[data-status="active"] {} - Це дозволить стилізувати елемент із конкретним
                        data-атрибутом.
                    </li>
                    <li>HTML: Інколи data-атрибути використовуються для вставки додаткової інформації, яку може
                        використовувати браузер або інші інструменти.
                    </li>
                </ol>
                Тут data-analytics та data-location можуть вказувати на аналітичні дані для слідкування кліків та місця
                розташування посилання.

                Важливо пам'ятати, що data-атрибути не повинні використовуватися для зберігання інформації, яка повинна
                бути доступна для користувачів або врахована в пошукових системах. Вони призначені для зберігання
                технічної або внутрішньої інформації, яка не відображається на сторінці напряму.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Шо таке AMP?
            </div>
            <div class="collapsible-body">
                <p>AMP HTML, або Accelerated Mobile Pages, є фреймворком веб-компонентів, призначеним для оптимізації
                    перегляду веб-сторінок на мобільних пристроях. Його основна мета - покращити швидкість завантаження
                    сторінок та користувацький досвід на мобільних пристроях, дотримуючись найкращих практик щодо
                    продуктивності.</p>

                <p>Переваги використання AMP HTML включають в себе швидший час завантаження, кращі позначення у
                    пошукових системах, збільшення взаємодії користувачів та зменшення відсотку відмов. Це досягається
                    за допомогою різних оптимізацій, таких як ліниве завантаження зображень, асинхронне виконання
                    JavaScript та спрощення CSS.</p>

                AMP HTML відрізняється від звичайного HTML кількома способами:
                <ol>
                    <li>Вимагає конкретного заявлення doctype (< !doctype html>) та тегу < html amp>.</li>
                    <li>Користувацькі компоненти AMP замінюють деякі стандартні елементи HTML (наприклад, < amp-img>
                        замість < img>).
                    </li>
                    <li>Зовнішні таблиці стилів не дозволяються; весь CSS повинен бути вбудованим та обмеженим до
                        75KB.
                    </li>
                    <li>Дозволяється лише асинхронне виконання JavaScript із обмеженнями на власні сценарії.</li>
                    <li>Ресурси сторонніх постачальників повинні завантажуватись через схвалені розширення AMP.</li>
                    <li>Макет контенту повинен бути визначений перед завантаженням ресурсів для запобігання
                        переприсвоєнню контенту.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як оптимізувати перформанс сайту?
            </div>
            <div class="collapsible-body">
                Оптимізація продуктивності веб-сайту - це важливий аспект для забезпечення ефективної роботи сайту і
                задоволення користувачів. Ось деякі стратегії для оптимізації продуктивності сайту:

                <ol>
                    <li>
                        <strong>Зменшення розміру та кількості запитань:</strong>
                        <ul>
                            <li>Об'єднання та мінімізація файлів CSS, JavaScript та зображень може допомогти зменшити
                                розмір сторінки і час завантаження.
                            </li>
                            <li>Використання спрайтів для об'єднання зображень може зменшити кількість запитів
                                серверу.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Кешування</strong>
                        <ul>
                            <li>Використовуйте HTTP-заголовки кешування, щоб зберегти копії ресурсів на стороні клієнта
                                та уникнути повторних завантажень при повторних відвідуваннях сайту.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Асинхронне завантаження ресурсів</strong>
                        <ul>
                            <li></li>
                            <li></li>
                        </ul>
                    </li>
                    <li>
                        <strong></strong>
                        <ul>
                            <li>Завантажуйте JavaScript асинхронно та використовуйте атрибут async чи defer.</li>
                            <li>Використання лінивого завантаження для зображень та інших ресурсів, які не є необхідними
                                на початковому етапі завантаження сторінки.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Оптимізація зображень</strong>
                        <ul>
                            <li>Використовуйте формати зображень, що мають високу ступінь стиснення, такі як WebP.</li>
                            <li>Зменшуйте розмір зображень перед їх завантаженням.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мінімізація запитів до сервера</strong>
                        <ul>
                            <li>Зменшення кількості ресурсів на сторінці може допомогти скоротити час завантаження.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Використання CDN</strong>
                        <ul>
                            <li>Використання Content Delivery Network дозволяє розміщувати ресурси на серверах, що
                                розташовані ближче до користувачів, що поліпшує швидкість завантаження.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Аналіз та оптимізація запитів до бази даних</strong>
                        <ul>
                            <li>Оптимізація SQL-запитів та використання кешування можуть покращити відгук сайту.</li>

                        </ul>
                    </li>
                    <li>
                        <strong>Мініфікація HTML, CSS, та JavaScript</strong>
                        <ul>
                            <li>Видалення зайвих пробілів, коментарів та мінімізація коду можуть зменшити обсяг файлів і
                                покращити швидкість завантаження.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Оптимізація сервера</strong>
                        <ul>
                            <li>Використовуйте високопродуктивні сервери та оптимізуйте налаштування серверного
                                програмного забезпечення.
                            </li>
                            <li></li>
                        </ul>
                    </li>
                    <li>
                        <strong>Use a Content Delivery Network (CDN)</strong>
                        <ul>
                            <li>Сервіс по обслуговуванню статичних файлів може бути витребувальним завданням. Оскільки
                                це не є основною діяльністю 99% веб-сайтів, розумно передавати цю частину інфраструктури
                                іншим постачальникам. На щастя, існують спеціальні сервіси саме для цього: мережі
                                доставки контенту або CDN.
                            </li>
                            <li>CDN оптимізують доставку статичних файлів, таких як CSS, зображення, шрифти та
                                JavaScript, для ваших відвідувачів. Їх налаштування, як правило, дуже просте.
                            </li>
                            <li>CDN використовують географічно розподілені сервери. Це означає, що сервер, який
                                найближчий до вашого відвідувача, буде обслуговувати файли. Таким чином, час
                                завантаження, наприклад, зображень, буде однаковим, незалежно від того, де користувач
                                підключається. Загалом, при обслуговуванні статичних файлів з власних серверів час
                                завантаження збільшується, коли користувачі фізично далеко від сервера.
                            </li>
                            <li>Ви можете використовувати Sematext Experience для моніторингу продуктивності файлів,
                                розміщених на CDN, щоб фактично виміряти, чи є сенс передавати цю частину інфраструктури
                                іншим постачальникам. Коли ми вперше почали використовувати CDN для обслуговування
                                ресурсів для Sematext Cloud, ми фактично використовували Sematext Experience, що
                                показало, що ми дійсно обслуговуємо речі швидше для наших користувачів.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Minimize Time to First Byte</strong>
                        <p>Час до першого байта, або TTFB, - це час, який потрібно браузеру для отримання першого байта
                            даних від сервера. Таким чином, це стосується серверної частини, але воно відіграє важливу
                            роль взагалі у продуктивності вашого веб-сайту, тому вам слід приділити час для його
                            поліпшення.</p>
                        <p>Основним фактором, який знаходиться під вашим контролем у відношенні до TTFB, є час обробки
                            сервера. Таким чином, ви можете випробувати деякі поради, рекомендовані Google, для
                            поліпшення TTFB:</p>
                        <ol>
                            <li>Оптимізуйте логіку застосунка сервера для швидшої підготовки сторінок. Якщо ви
                                використовуєте серверний фреймворк, у фреймворка можуть бути рекомендації щодо того, як
                                це зробити.
                            </li>
                            <li>Оптимізуйте, як ваш сервер виконує запити до баз даних або переходіть до швидших систем
                                баз даних.
                            </li>
                            <li>Оновіть апаратне забезпечення сервера для отримання більше пам'яті або ЦП.</li>
                        </ol>
                        <p>TTFB менше 200 мс вважається великим. Діапазон від 200 мс до 500 мс вважається нормальним і
                            прийнятним. TTFB, що постійно перевищує 600 мс, потрібно розглядати для дослідження.
                            Sematext Experience може допомогти вам у цьому, а також в моніторингу інших метрик Web
                            Vitals.</p>
                    </li>
                    <li>
                        <strong>Кешування</strong>
                        <p>Я коротко згадував про кеш, але хочу пояснити, що це таке. Кешування - це процес збереження
                            версії ваших файлів у тимчасовому сховищі - кеші -, до якого можна отримати швидший доступ.
                            Є багато переваг у ввімкненні кешування в браузері, оскільки це може зменшити споживання
                            пропускної здатності, збільшити час завантаження, зменшити затримку та робоче навантаження
                            сервера. Основним недоліком є те, що фактично завжди буде принаймні дві версії вашого
                            веб-сайту у будь-який момент часу. Це може викликати проблеми, якщо ви використовуєте службу
                            в реальному часі, яка залежить від точних даних, але це можна вирішити в певній мірі,
                            вимагаючи очищення підсекції кешу при імпортуванні нових даних.</p>
                    </li>
                    <li>
                        <strong></strong>
                        <ul>
                            <li></li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are the critical rendering paths in a web browser?
            </div>
            <div class="collapsible-body">
                <p><strong>Критичний шлях рендеру (Critical Rendering Paths)</strong> - це послідовність дій, які браузер повинен виконати
                    для відображення вмісту сторінки на екрані користувача. Основним завданням є оптимізація цих шляхів для
                    максимально швидкого і коректного відображення вмісту. Нижче подано опис критичних шляхів у веб-браузері:</p>
                <ol>
                    <li>
                        <strong>Отримання HTML (Fetch HTML):</strong>
                        <p>Браузер починає завантаження сторінки, відправляючи запит на сервер для отримання HTML-коду.</p>
                        <p> Використання Content Delivery Network (CDN), компресія HTML і налаштування кешування.</p>
                    </li>
                    <li>
                        <strong>Обробка HTML (Parse HTML):</strong>
                        <p>Браузер аналізує отриманий HTML-код та створює DOM (Document Object Model) та CSSOM (CSS Object Model).</p>
                        <p>Мінімізація та усунення блокуючих ресурсів, збільшення паралелізму завантаження.</p>
                    </li>
                    <li>
                        <strong>Створення Render Tree (Create Render Tree):</strong>
                        <p> Браузер об'єднує DOM та CSSOM у Render Tree, який визначає порядок відображення елементів.</p>
                        <p>Мінімізація кількості CSS-блокуючих ресурсів, використання ефективних селекторів CSS.</p>
                    </li>
                    <li>
                        <strong>Обчислення розмірів та позицій (Layout):</strong>
                        <p>Браузер визначає розміри та позиції кожного елемента в Render Tree.</p>
                        <p>Використання флексбоксів, грідів, уникання складних таблиць.</p>
                    </li>
                    <li>
                        <strong>Відображення (Paint):</strong>
                        <p>Браузер займається фактичним відображенням сторінки на екрані користувача.</p>
                        <p>Використання анімацій GPU, оптимізація зображень.</p>
                    </li>
                    <li>
                        <strong>Оновлення (Composite): </strong>
                        <p>Браузер обновлює екран згідно з внесеними змінами.</p>
                        <p>Використання апаратного прискорення, уникання зайвих перемальовувань.</p>
                    </li>
                </ol>
                <p>Оптимізація критичних шляхів є ключовою для досягнення високої швидкодії завантаження сторінок та відповіді на запити
                    користувачів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                BOM (Browser Object Model) vs DOM (Document Object Model)
            </div>
            <div class="collapsible-body">
                <p>BOM (Browser Object Model) та DOM (Document Object Model) - це дві різні моделі об'єктів, які використовуються
                    веб-браузерами для представлення вмісту та взаємодії з ним на сторінках в Інтернеті. Нижче подано їхні основні
                    різниці:</p>
                <h6>DOM (Document Object Model):</h6>
                <ol>
                    <li>
                        <strong>Опис</strong>
                        <ul>
                            <li>DOM представляє структуру документа веб-сторінки, яка може бути HTML, XML або XHTML.</li>
                            <li>Кожен елемент, атрибут, текстовий вузол тощо має свій відповідний об'єкт в DOM.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Призначення</strong>
                        <ul>
                            <li>Використовується для доступу, маніпуляції та зміни структури та вмісту веб-документа.</li>
                            <li>Дозволяє скриптам змінювати вигляд та поведінку сторінки.</li>
                        </ul>
                    <li>
                        <strong>Орієнтований на документ</strong>
                        <ul>
                            <li>DOM визначає структуру документа та забезпечує можливість програмного доступу до елементів документа.</li>
                        </ul>
                </ol>

                <h6>BOM (Browser Object Model):</h6>
                <ol>
                    <li>
                        <strong>Опис</strong>
                        <ul>
                            <li>BOM представляє об'єкти браузера, такі як вікна та фрейми, а також деякі додаткові об'єкти, такі як
                                navigator, history, location тощо.
                            </li>
                            <li>Включає об'єкти, які не пов'язані з структурою документа.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Призначення</strong>
                        <ul>
                            <li>Використовується для контролю та взаємодії з самим браузером, а не конкретним документом.</li>
                            <li>Надає доступ до функцій, таких як керування вікнами, робота з історією перегляду, визначення
                                місцезнаходження тощо.
                            </li>
                        </ul>
                    <li>
                        <strong>Орієнтований на браузер</strong>
                        <ul>
                            <li>BOM визначає об'єкти, які представляють браузер і дозволяють контролювати його функціонал.</li>
                        </ul>
                </ol>

                <h6>Загальна Ідея:</h6>
                <ul>
                    <li>DOM відповідає за структуру та вміст веб-сторінки.</li>
                    <li>BOM відповідає за взаємодію з самим браузером та його функціоналом.</li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Доступність веб-сайту (Web Accessibility)
            </div>
            <div class="collapsible-body">
                <p>Доступність веб-сайту (Web Accessibility) — це забезпечення можливості використання та сприйняття веб-ресурсу всіма
                    користувачами, включаючи тих, які мають обмеження чи інвалідність. Ось деякі ключові аспекти доступності веб-сайтів:</p>
                <p>Дотримання принципів доступності дозволяє забезпечити комфортне та рівноправне використання веб-сайту всіма його
                    відвідувачами.</p>

                <ol>
                    <li>
                        <strong>Семантична Розмітка</strong>
                        <ul>
                            <li>Використання правильних HTML-тегів для опису структури сторінки.</li>
                            <li>Забезпечення логічного розташування та взаємодії елементів.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Адаптивний Дизайн:</strong>
                        <ul>
                            <li>Забезпечення читабельності та зручності використання на різних пристроях.</li>
                            <li>Створення веб-сайту, який підлаштовується під різні розміри екранів та пристрої.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Контрастність Кольорів</strong>
                        <ul>
                            <li>Використання достатнього контрасту між текстом та тлом для зручності читання користувачами з обмеженим
                                зором.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Альтернативні Тексти</strong>
                        <ul>
                            <li>Надання текстових описів (альтернативних текстів) для графічних елементів, щоб люди з вадами зору або
                                вимкненим зображенням могли зрозуміти зміст.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Клавішні Спуски</strong>
                        <ul>
                            <li>Забезпечення можливості навігації та використання всіх інтерактивних елементів за допомогою клавіатури, а не
                                лише миші.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Відмова від Миготіння</strong>
                        <ul>
                            <li>Уникання використання миготливих або блимучих елементів, які можуть викликати дискомфорт чи епілептичні
                                напади.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Легенди та Підказки Форм</strong>
                        <ul>
                            <li>Додавання чітких заголовків, підказок та легенд до форм для полегшення їх використання.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мовні Атрибути</strong>
                        <ul>
                            <li>Використання атрибутів мови для правильного визначення та читання текстів на різних мовах.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Навігація та Заголовки</strong>
                        <ul>
                            <li>Додавання структурованої навігації та заголовків для полегшення розуміння контенту та навігації.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Тестування з Користувачами</strong>
                        <ul>
                            <li>Проведення тестів доступності з реальними користувачами з різними потребами та обмеженнями.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How do you serve a page with content in multiple languages?
            </div>
            <div class="collapsible-body">
                <p>Для обслуговування сторінки з контентом у кількох мовах, ви можете використовувати підходи, такі як:</p>

                <ol>
                    <li>
                        <strong>Мульти-мовні файли перекладу:</strong>
                        <ul>
                            <li>Створіть окремі файли для кожної мови, які містять переклади контенту.</li>
                            <li>Використовуйте ідентифікатори для тексту, які потрібно перекласти.</li>
                            <li>Під час завантаження сторінки, визначайте мову користувача і завантажуйте відповідний файл перекладу.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>URL-параметри або піддомени:</strong>
                        <ul>
                            <li>Додається мовний ідентифікатор до URL-адреси (наприклад, /en/about для англійської мови, /es/about для
                                іспанської).
                            </li>
                            <li>Використовуйте цей ідентифікатор для визначення потрібної мови та завантаження відповідного контенту.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>HTTP заголовки:</strong>
                        <ul>
                            <li>Використовуйте HTTP заголовок Accept-Language для отримання від браузера інформації про мову користувача.
                            </li>
                            <li>На сервері визначайте мову і відповідно обслуговуйте сторінку.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>JavaScript-бібліотеки перекладу:</strong>
                        <ul>
                            <li>Використовуйте JavaScript-бібліотеки, такі як i18n.js або react-intl для управління перекладами у
                                фронтенді.
                            </li>
                            <li>Дозволяє вам динамічно змінювати мову і оновлювати контент без повного перезавантаження сторінки.</li>
                        </ul>
                    </li>
                </ol>

                <p>При виборі методу важливо враховувати SEO-дружність та зручність для користувачів. Зазвичай, краще обслуговувати сторінки
                    у різних мовах так, щоб вони були добре індексовані пошуковими системами та зручні для навігації користувачів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What kind of things must you be wary of when designing or developing for multilingual sites?
            </div>
            <div class="collapsible-body">
                <p>При проектуванні або розробці мульти-мовних сайтів важливо враховувати кілька аспектів, щоб забезпечити ефективність,
                    коректність та зручність для користувачів. Ось деякі речі, на які варто звертати увагу:</p>

                <ol>
                    <li>
                        <strong>Культурні відмінності:</strong>
                        <ul>
                            <li>Враховуйте різницю в культурних відмінностях при виборі зображень, кольорів та загального дизайну.</li>
                            <li>Пам'ятайте, що певний контент або вирази можуть мати різний сенс у різних культурах. (Mitsubishi Pajero)
                            </li>
                        </ul>
                    </li>
                    <li><strong>Доступність текстового контенту:</strong>
                        <ul>
                            <li>Переконайтеся, що дизайн передбачає різні довжини текстового контенту в різних мовах, щоб уникнути обрізання
                                або переповнення блоків.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Підтримка мовних правил:</strong>
                        <ul>
                            <li>Враховуйте різні правила сортування, числові та календарні формати, які можуть відрізнятися в різних
                                мовах.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Менеджмент контенту:</strong>
                        <ul>
                            <li>Використовуйте системи управління контентом (CMS), які підтримують легке додавання та оновлення мов.</li>
                            <li>Забезпечте можливість редагування та попереднього перегляду контенту для перекладачів.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Describe the difference between a cookie, sessionStorage and localStorage.
            </div>
            <div class="collapsible-body">
                <p>Різниця між кукі (cookie), sessionStorage та localStorage полягає в їхньому зберіганні даних, тривалості життя, розмірі
                    та доступі:</p>
                <ol>
                    <li>
                        <strong>Кукі (cookie):</strong>
                        <ul>
                            <li>
                                <strong>Зберігання:</strong>
                                <p>Кукі - це невеликий обсяг даних, який зберігається на боці клієнта та відправляється разом із кожним
                                    запитом на сервер.</p>
                            </li>
                            <li>
                                <strong>Тривалість життя:</strong>
                                <p> Може мати обмежену тривалість, встановлену вами, або доки не закінчиться сеанс браузера (залежно від
                                    параметрів).</p>
                            </li>
                            <li>
                                <strong>Доступ: </strong>
                                <p>Має обмежений доступ через JavaScript через обмежені методи API і визначені правила Same-Origin
                                    <Policy class=""></Policy>
                                </p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>sessionStorage:</strong>
                        <ul>
                            <li>
                                <strong>Зберігання:</strong>
                                <p>sessionStorage зберігає дані в області пам'яті сесії тільки на час життя сесії браузера.</p>
                            </li>
                            <li>
                                <strong>Тривалість життя:</strong>
                                <p>Дані в sessionStorage будуть видалені при закритті вкладки або вікна браузера.</p>
                            </li>
                            <li>
                                <strong>Доступ: </strong>
                                <p>Доступно тільки на стороні клієнта, і дані не надсилаються на сервер під час запитів.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>localStorage:</strong>
                        <ul>
                            <li>
                                <strong>Зберігання:</strong>
                                <p>localStorage подібно до sessionStorage, але дані в ньому зберігаються на більший термін, навіть після
                                    закриття вкладки чи перезавантаження браузера.</p>
                            </li>
                            <li>
                                <strong>Тривалість життя:</strong>
                                <p>Дані в localStorage залишаються, поки їх не видалено вручну або не скинуто з програми.</p>
                            </li>
                            <li>
                                <strong>Доступ: </strong>
                                <p>Також доступно тільки на стороні клієнта, і дані не надсилаються на сервер під час запитів.</p>
                            </li>
                        </ul>
                    </li>
                    <p>
                        Обираючи між цими варіантами збереження даних, важливо враховувати потреби вашого додатка щодо тривалості життя
                        даних та безпеки, а також вимоги до зберігання даних на сервері чи локально на клієнтському пристрої.
                    </p>
                    <p>Розмір даних, який може бути збережений в куках (cookie), sessionStorage та localStorage, може варіюватися в
                        залежності від браузера та його обмежень. Тут є загальні вказівки:</p>
                    <ol>
                        <li>
                            <strong>Cookie:</strong>
                            <ul>
                                <li>Загальний розмір куки для одного домену обмежений приблизно 4096 байтами (4 КБ).</li>
                                <li>Браузер обмежує кількість куків, які можуть бути збережені для одного домену (зазвичай близько 50).</li>
                            </ul>
                        </li>
                        <li>
                            <strong>sessionStorage та localStorage:</strong>
                            <ul>
                                <li>Зазвичай більші обсяги даних порівняно з кукі.</li>
                                <li>Розмір localStorage обмежений приблизно 5 МБ на домен.</li>
                                <li>Розмір sessionStorage зазвичай теж довший (~ 5 MB), але при закритті вкладки або вікна браузера дані
                                    видаляються.
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p>Важливо враховувати, що це загальні вказівки, і реальні обмеження можуть варіюватися в залежності від конкретного
                        браузера та його налаштувань. Також слід пам'ятати, що великі об'єми даних можуть впливати на продуктивність та
                        швидкодію веб-сторінок.</p>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Describe the difference between < script>, < script async> and < script defer>.
            </div>
            <div class="collapsible-body">
                <p>
                    Теги < script>, < script async>, та < script defer> в HTML використовуються для включення та виконання JavaScript коду
                    на веб-сторінці, проте вони відрізняються за тим, як вони впливають на завантаження та виконання скрипта. Ось короткий
                    опис кожного:
                </p>
                <ol>
                    <li>
                        <strong>< script></strong>
                        <ul>
                            <li>
                                <strong>Завантаження:</strong>
                                <p>Скрипт завантажується та виконується синхронно, що означає, що він блокує парсинг HTML-документу до тих
                                    пір, поки скрипт повністю не завантажиться та не виконається.</p>
                            </li>
                            <li>
                                <strong>Використання:</strong>
                                <p>Це стандартна поведінка за замовчуванням. Використовується, коли скрипт повинен виконатися негайно та є
                                    необхідним для подальшого відображення чи функціональності сторінки.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>< script async></strong>
                        <ul>
                            <li>
                                <strong>Завантаження:</strong>
                                <p>Скрипт завантажується асинхронно, дозволяючи парсингу HTML продовжуватися, навіть якщо скрипт ще не
                                    завантажений. Однак виконання скрипта трапляється, як тільки він завантажується, незалежно від того, чи
                                    завершено парсинг HTML чи ні.</p>
                            </li>
                            <li>
                                <strong>Використання:</strong>
                                <p>Використовується, коли скрипт не залежить від інших скриптів та може виконуватися в будь-який момент.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>< script defer></strong>
                        <ul>
                            <li>
                                <strong>Завантаження:</strong>
                                <p>Скрипт також завантажується асинхронно, але виконання відбувається тільки після завершення парсингу
                                    HTML-документу.</p>
                            </li>
                            <li>
                                <strong>Використання:</strong>
                                <p>Використовується, коли порядок виконання скриптів важливий та ви хочете, щоб скрипт виконувався після
                                    повного завантаження та парсингу HTML.</p>
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Why is it generally a good idea to position CSS < link>s between < head>< /head> and JS < script>s just before
                < /body>? Do you know any exceptions?
            </div>
            <div class="collapsible-body">
                <p>Зазвичай рекомендується розміщувати елементи CSS < link> між тегами < head> і JS < script> безпосередньо перед
                    закриваючим тегом < /body> з кількох причин:</p>
                <ol>
                    <li>
                        <strong>Забезпечення швидшого відображення контенту:</strong>
                        <ul>
                            <li>озміщення CSS у < head> дозволяє браузеру завантажувати та обробляти стилі перед відображенням вмісту. Це
                                сприяє швидшому відображенню сторінки користувачеві, оскільки стилі вже доступні для використання.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Запобігання блокуванню рендерингу:</strong>
                        <ul>
                            <li>JS-скрипти можуть блокувати процес рендерингу, тому важливо розміщувати < script> перед закриваючим тегом
                                < /body>. Це дозволяє браузеру завантажувати і відображати контент, тоді як скрипти обробляються після того,
                                як сторінка вже відобразилася.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Покращення взаємодії з кешуванням:</strong>
                        <ul>
                            <li>Розміщення JS в кінці дозволяє використовувати кешування стилів під час повторних відвідувань сторінки,
                                оскільки вони не змінюються часто.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Винятки можуть існувати залежно від конкретних потреб проекту або випадків використання. Наприклад, для невеликих
                    сторінок чи проектів може бути прийнятно розмістити CSS та JS в одному файлі чи включати стилі безпосередньо в HTML
                    документ, але це залежить від конкретних обставин.</p>
            </div>
        </li>


        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What is progressive rendering?
            </div>
            <div class="collapsible-body">
                <p>Прогресивний рендеринг (Progressive Rendering) - це підхід до відображення веб-сторінок, за яким контент поступово
                    виводиться на екран для користувача, по мірі його завантаження та обробки. Це поліпшує враження від швидкості
                    завантаження сторінки, особливо на повільних інтернет-з'єднаннях або на пристроях з обмеженими ресурсами.</p>
                <p>Прогресивний рендеринг може включати в себе кілька аспектів:</p>
                <ol>
                    <li>
                        <strong>Поступове завантаження контенту:</strong>
                        <p>Спочатку на екран виводяться основні елементи сторінки, такі як текст та зображення низької роздільної здатності.
                            Потім, по мірі завантаження більше ресурсів, контент оновлюється та відображається у вищій якості.</p>
                    </li>
                    <li>
                        <strong>Ліниве завантаження зображень (Lazy Loading):</strong>
                        <p>Зображення завантажуються тільки тоді, коли вони з'являються в області видимості користувача. Це допомагає
                            зменшити час завантаження сторінки, оскільки не всі зображення обробляються одночасно.</p>
                    </li>
                    <li>
                        <strong>Поступова підгрузка контенту:</strong>
                        <p>Контент, який знаходиться внизу сторінки, може завантажуватися та виводитися поетапно, навіть якщо верхня частина
                            сторінки вже відобразилася.</p>
                    </li>
                </ol>
                <p>Прогресивний рендеринг дозволяє користувачам швидше отримати доступ до основного контенту сторінки, забезпечуючи краще
                    враження від її продуктивності, навіть під час нестабільного або повільного з'єднання з Інтернетом.</p>

                <h6>Для реалізації прогресивного рендерингу та поліпшення швидкості завантаження веб-сторінок можна використовувати різні
                    способи та інструменти:</h6>
                <ol>
                    <li>
                        <strong>Ліниве завантаження зображень (Lazy Loading):</strong>
                        <ul>
                            <li>Використовуйте атрибут loading для тегів < img>, наприклад: < img src="image.jpg" loading="lazy">.</li>
                            <li>Використовуйте JavaScript для лінивого завантаження зображень, наприклад, бібліотеку LazyLoad.js.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Асинхронне завантаження ресурсів:</strong>
                        <ul>
                            <li>Використовуйте атрибут async для тегів < script> для асинхронного завантаження скриптів.</li>
                            <li>Розміщуйте скрипти, які не блокують відображення контенту, перед закриваючим тегом < /body>.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Поступове завантаження контенту:</strong>
                        <ul>
                            <li>Виводьте основний текст та блоки контенту першими, навіть якщо інші ресурси ще не завантажені.</li>
                            <li>Використовуйте анімації або переходи для зменшення відчуття затримки при поступовому завантаженні.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Збереження та використання кешу:</strong>
                        <ul>
                            <li>Використовуйте HTTP-кешування для збереження ресурсів на стороні клієнта.</li>
                            <li>Використовуйте сервісні роботи (Service Workers) для створення власного кешу та управління ресурсами в
                                офлайн-режимі.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Інструменти для аналізу та оптимізації:</strong>
                        <ul>
                            <li>Використовуйте інструменти для аналізу завантаження сторінки, такі як Lighthouse, PageSpeed Insights або
                                WebPageTest.
                            </li>
                            <li>Використовуйте інструменти для оптимізації зображень, наприклад, ImageOptim або TinyPNG.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Why you would use a srcset attribute in an image tag? Explain the process the browser uses when evaluating the content of
                this attribute.
            </div>
            <div class="collapsible-body">
                <p>Атрибут srcset в тегу < img> використовується для вказання різних версій зображення з різною роздільною здатністю чи
                    розміром. Це дозволяє браузерам вибирати оптимальну версію зображення, враховуючи характеристики пристрою та екрана
                    користувача, що покращує продуктивність та ефективність завантаження сторінок.</p>
                <p>Процес оцінки вмісту атрибута srcset браузером виглядає наступним чином:</p>
                <ol>
                    <li>
                        <strong>Браузер отримує список доступних ресурсів:</strong>
                        <p>Атрибут srcset містить список URL зображень та відповідних розмірів чи роздільних здатностей.
                            <br>
                            < img srcset="image-320w.jpg 320w, image-480w.jpg 480w, image-800w.jpg 800w" src="default.jpg"
                            alt="Description">
                        </p>
                    </li>
                    <li>
                        <strong>Браузер оцінює умови відображення:</strong>
                        <p>Браузер аналізує характеристики пристрою та екрана, такі як розмір екрана, роздільна здатність, піксельна
                            щільність тощо.</p>
                    </li>
                    <li>
                        <strong>Браузер вибирає оптимальне зображення:</strong>
                        <p>На основі аналізу, браузер вибирає найбільш підходяще зображення зі списку, яке відповідає умовам відображення.
                            Це може бути зображення з найбільшою роздільною здатністю або оптимальним розміром для пристрою.</p>
                    </li>
                    <li>
                        <strong>Браузер завантажує вибране зображення:</strong>
                        <p>Обране зображення завантажується та відображається на сторінці.</p>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке спрайт в html?
            </div>
            <div class="collapsible-body">
                <p>У HTML термін "спрайт" може вказувати на дві різні речі: CSS-спрайти та SVG-спрайти.</p>
                <ol>
                    <li>
                        <strong>CSS-спрайт (CSS Sprites):</strong>
                        <p>CSS-спрайт є методом оптимізації завантаження сторінки, коли кілька малих зображень об'єднуються в одне велике
                            зображення (спрайт). Замість того, щоб завантажувати кожне зображення окремо, браузер лише завантажує одне
                            зображення, і CSS використовується для відображення потрібної частини спрайту на сторінці.</p>

                        <strong>Спосіб імплементації: </strong>
                        <ul>
                            <li>
                                <strong>Підготовка зображень:</strong>
                                <p>Збережіть всі малі зображення, які ви хочете об'єднати в спрайт, в одній текі. Зазвичай, це іконки,
                                    кнопки або інші графічні елементи.</p>
                            </li>
                            <li>
                                <strong>Створення спрайта:</strong>
                                <p>Використайте інструмент для створення спрайтів, такий як SpritePad, SpriteMe, або TexturePacker, або
                                    створіть його самостійно за допомогою графічного редактора.</p>
                                <p>Розташуйте всі малі зображення на одному великому листі, за можливість використовуйте прогалини між
                                    ними.</p>
                            </li>
                            <li>
                                <strong>Збереження спрайта:</strong>
                                <p>Збережіть створений спрайт у форматі зображення (зазвичай PNG або JPEG).</p>
                            </li>
                            <li>
                                <strong>Використання CSS:</strong>
                                <p>Визначте клас для елементу, який ви хочете оформити за допомогою CSS-спрайта.
                                    <br>
                                <pre>
                                        .icon {
                                           width: 30px;
                                           height: 30px;
                                           background-image: url('sprites.png');
                                        }
                                    </pre>
                                </p>
                                <p>Визначте позицію конкретного зображення на спрайті за допомогою background-position. Це вказує, яка
                                    частина спрайта повинна бути відображена.</p>
                                <pre>
                                    .icon-home {
                                       background-position: 0 0;
                                    }

                                    .icon-email {
                                       background-position: 0 -40px;
                                    }
                                </pre>
                            </li>
                            <li>
                                <strong>Використання в HTML:</strong>
                                <p>Додайте HTML-елемент із вказаним класом та визначте, яке зображення має бути відображене.</p>
                                <p>< div class="icon icon-home">< /div> < div class="icon icon-email">< /div>
                                </p>
                            </li>
                        </ul>
                        <p>Це дозволить вам зменшити кількість HTTP-запитів, які потрібно робити для завантаження різних зображень, і
                            покращити швидкість завантаження сторінки.</p>
                    </li>
                    <li>
                        <strong>SVG-спрайт (SVG Sprites):</strong>
                        <p>SVG-спрайт об'єднує кілька SVG-зображень в один файл. Це полегшує керування та завантаженням багатьох SVG-ікон на
                            сторінку.</p>
                    </li>
                </ol>
                <p>Обидва ці методи дозволяють оптимізувати завантаження зображень та покращувати продуктивність сторінки. Однак вони
                    використовуються для різних типів зображень та мають свої відмінності у використанні.</p>
                <p>
                <pre>
                        < svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                           < symbol id="icon-home" viewBox="0 0 24 24">
                    <!-- SVG код для іконки дому -->
                           < /symbol>
                           < symbol id="icon-email" viewBox="0 0 24 24">
                    <!-- SVG код для іконки електронної пошти -->
                           < /symbol>
                        < /svg>

                        < svg class="icon">
                           < use xlink:href="#icon-home">< /use>
                        < /svg>

                        < svg class="icon">
                           < use xlink:href="#icon-email">< /use>
                        < /svg>

                    </pre>
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are empty elements in HTML ?
            </div>
            <div class="collapsible-body">
                <p>Empty elements в HTML — це теги, які не мають контенту або вмісту і закриваються самими собою. У таких тегів немає
                    парного тегу закриття, і вони мають спеціальний синтаксис для короткого запису.</p>
                <p>Наприклад, тег < br> (ламання рядка) або < img> (зображення) є прикладами empty elements:</p>
                <p>Інші приклади empty elements включають теги, такі як < input>, < meta>, < link>, і < hr>. Вони використовуються для
                    вставки елементів, які не мають контенту або потребують мінімального оформлення.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are HTML Attributes?
            </div>
            <div class="collapsible-body">
                <p>
                    Атрибути - це властивості, які можна додавати до тегу HTML. Ці атрибути змінюють спосіб, яким тег веде себе або
                    відображається. Наприклад, у тега < img> є атрибут src, який використовується для вказівки джерела, з якого слід
                    відображати зображення.</p>
                <p>Ми додаємо атрибути одразу після імені тегу HTML, всередині дужок. Ми можемо додавати атрибути тільки до відкриваючих або
                    самозакриваючих тегів, але ніколи не до закриваючих тегів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Explain the difference between layout, painting and compositing.
            </div>
            <div class="collapsible-body">
                <p>Концепції компонування (layout), фарбування (painting) і композиції (compositing) є важливими для розуміння того, як
                    браузери відображають веб-сторінки.</p>
                <ol>
                    <li>
                        <strong>Компонування (Layout):</strong>
                        <p>Компонування — це процес визначення розташування та розмірів всіх елементів на сторінці відповідно до
                            CSS-властивостей та макету. Це включає визначення положення та розмірів блоків, тексту, відступів і так
                            далі.</p>
                    </li>
                    <li>
                        <strong>Фарбування (Painting):</strong>
                        <p>Фарбування — це процес, коли браузер заповнює контент сторінки кольорами та текстурами відповідно до властивостей
                            стилів. Відбувається визначення кінцевого вигляду кожного елемента на основі його стилів.</p>
                    </li>
                    <li>
                        <strong>Композиція (Compositing):</strong>
                        <p>Композиція — це процес, коли браузер об'єднує вже нарисовані та відфарбовані елементи на екрані, створюючи
                            кінцевий вигляд сторінки. Це включає в себе управління прозорістю, насиченістю, зміщенням та іншими
                            ефектами.</p>
                    </li>
                </ol>
                <p>Взаємодія цих процесів є неперервним і складається з декількох етапів, що дозволяють браузерам ефективно та швидко
                    рендерити складні веб-сторінки.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Коменти в CSS, HTML & JS
            </div>
            <div class="collapsible-body">
                <p>
                    Коментарі в CSS, HTML і JavaScript використовуються для надання пояснень коду і не впливають на виконання програми чи
                    рендеринг вмісту веб-сторінки. Ось як вони виглядають у кожній з цих мов:</p>
                <p>/* Це коментар в CSS */</p>
                <p><!-- Це коментар в HTML --></p>
                <p>// Це однорядковий коментар в JavaScript</p>
                <p>
                <pre>
                        /*
                           Це багаторядковий
                           коментар в JavaScript
                        */
                    </pre>
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Семантика HTML
            </div>
            <div class="collapsible-body">
                <p>Семантика в HTML відноситься до практики використання елементів мови розмітки HTML таким чином, щоб вони передавали
                    значення щодо структури та змісту веб-сторінки. Семантичне HTML допомагає як браузерам, так і розробникам розуміти
                    призначення та роль різних частин вмісту. Це покращує доступність, оптимізацію для пошукових систем та загальну
                    структуру документа.</p>

                <ol>
                    <li>
                        <strong>header</strong>
                        <p>Визначає верхню частину сторінки або розділ заголовків.</p>
                    </li>
                    <li>
                        <strong>nav</strong>
                        <p>Вказує на навігаційний блок сторінки.</p>
                    </li>
                    <li>
                        <strong>main</strong>
                        <p>Визначає основний контент сторінки, який не є частиною заголовка, навігації, або підвалу.</p>
                    </li>
                    <li>
                        <strong>article</strong>
                        <p>Визначає незалежний контент, такий як новина або стаття.</p>
                    </li>
                    <li>
                        <strong>section</strong>
                        <p>Визначає розділ документа, наприклад, групу пов'язаних статей або блоків контенту.</p>
                    </li>
                    <li>
                        <strong>aside</strong>
                        <p>Вказує на контент, який стоїть окремо від основного контенту, наприклад, бічні бокові панелі.</p>
                    </li>
                    <li>
                        <strong>footer</strong>
                        <p>Визначає нижню частину сторінки або розділ підвалу.</p>
                    </li>
                    <li>
                        <strong>figure | figcaption</strong>
                        <p> визначає автономний контент, такий як зображення, відео або графіка | визначає підпис до контенту відповідно</p>
                    </li>
                    <li>
                        <strong>time</strong>
                        <p>Вказує на час або дату, наприклад, використовується для позначення публікацій або подій.</p>
                    </li>
                    <li>
                        <strong>mark</strong>
                        <p>Визначає текст, який виділяється або підсвічується для наголошення важливості.</p>
                    </li>
                </ol>

                <p>Ці семантичні елементи допомагають чітко визначити роль кожного блоку вмісту на сторінці та полегшують розуміння
                    структури документа.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Shadow DOM
            </div>
            <div class="collapsible-body">
                <p>Shadow DOM (об'єктна модель відображення) - це технологія веб-розробки, яка дозволяє ізолювати і вкладати веб-компоненти
                    (елементи) так, щоб їх стилі та логіка не впливали на стилі та логіку інших елементів на сторінці.</p>
                <p>Shadow DOM дозволяє створювати веб-компоненти з покращеною ізоляцією, зменшує вплив стилів та логіки компонентів на решту
                    сторінки та дозволяє підтримувати більшу структуру та порядок в коді.</p>

                <p>Shadow DOM має кілька важливих використань (use cases) у веб-розробці. Ось декілька сценаріїв, де використання Shadow DOM
                    є корисним:</p>
                <ol>
                    <li>
                        <strong>Ізоляція Стилів і Логіки:</strong>
                        <p>Shadow DOM дозволяє ізолювати стилі та логіку веб-компонентів від стилів інших частин сторінки. Це дозволяє
                            розробникам створювати компоненти, які не будуть конфліктувати зі стилями інших елементів.</p>
                    </li>
                    <li>
                        <strong>Створення Компонентів:</strong>
                        <p>Shadow DOM є ідеальним інструментом для створення власних кастомних веб-компонентів. Ви можете використовувати
                            Shadow DOM для створення ізольованого середовища для власного компонента, що дозволяє використовувати його
                            безпосередньо в HTML-документах, забезпечуючи при цьому його ізоляцію від зовнішніх стилів і скриптів.</p>
                    </li>
                    <li>
                        <strong>Розширення Функціональності</strong>
                        <p>Shadow DOM дозволяє розробникам розширювати стандартні HTML елементи та створювати елементи з новою
                            функціональністю. Наприклад, ви можете створити кнопку з власними стилями та подіями, які не впливатимуть на
                            інші кнопки на сторінці.</p>
                    </li>
                    <li>
                        <strong>Покращення Структури Коду</strong>
                        <p>Використання Shadow DOM сприяє покращенню структури коду, оскільки ви можете розділити логіку та стилі вашого
                            компонента від іншого коду сторінки. Це допомагає підтримувати чистоту коду та полегшує розуміння та модифікацію
                            компонентів.</p>
                    </li>
                    <li>
                        <strong>Зменшення Впливу</strong>
                        <p>Shadow DOM дозволяє вам створювати компоненти, які мають мінімальний вплив на інші частини сторінки. Це особливо
                            важливо в ситуаціях, коли ви використовуєте сторонні бібліотеки або компоненти, і хочете уникнути конфліктів
                            імен та стилів.</p>
                    </li>
                </ol>
                <p>Ці використання демонструють, як Shadow DOM може бути корисним для покращення ізоляції та підтримки компонентного підходу
                    у веб-розробці.</p>

                <p><strong>Як створити такий елемент?</strong></p>
                <ol>
                    <li>
                        Створюємо < div id="shadow-host">Host Element< /div> - базовий стардартний елемент, з якого робитимемо тіневий DOM
                    </li>
                    <li>
                        За допомогою JavaScript створюється тіневий DOM для shadow-host за допомогою attachShadow.
                    </li>
                    <li>В Shadow DOM додається < p> елемент з текстом "This is a Shadow DOM element."</li>
                    <li>Також додається стиль для < p> елемента в межах Shadow DOM.</li>
                    <li>Основний DOM і тіневий DOM ізольовані, і стилі з Shadow DOM не впливають на елементи за межами Shadow DOM.</li>
                    <li>
                        <pre>
                            // Отримуємо елемент, який буде господарем тіневого DOM
                            const shadowHost = document.getElementById('shadow-host');

                            // Створюємо Shadow DOM
                            const shadowRoot = shadowHost.attachShadow({ mode: 'open' });

                            // Створюємо елемент в Shadow DOM
                            const shadowElement = document.createElement('p');
                            shadowElement.textContent = 'This is a Shadow DOM element.';

                            // Додаємо стилі для Shadow DOM елемента
                            const style = document.createElement('style');
                            style.textContent = `
                              p {
                                color: blue;
                                font-style: italic;
                              }
                            `;
                            shadowRoot.appendChild(style);

                            // Додаємо Shadow DOM елемент до Shadow DOM
                            shadowRoot.appendChild(shadowElement);
                        </pre>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Яка роль тегу < meta> в HTML?
            </div>
            <div class="collapsible-body">
                Тег < meta> надає додаткову інформацію про веб-сторінку, таку як автор, опис і ключові слова. Він розташований в межах
                секції < head> HTML-документа.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Яка роль атрибуту method в формах HTML?
            </div>
            <div class="collapsible-body">
                <p>Атрибут method використовується для вказівки HTTP-методу, який буде використовуватися для відправки даних форми. Два
                    найбільш поширені методи - GET і POST.
                </p>
                <ul>
                    <li>GET - Використовується для отримання даних з сервера. Дані відправляються через URL, видимі в адресному рядку
                        браузера.
                    </li>
                    <li>POST - Використовується для відправлення даних на сервер для обробки. Дані відправляються через тіло HTTP-запиту, що
                        робить їх прихованими.
                    </li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке Гідратація?
            </div>
            <div class="collapsible-body">
                <p>Гідратація - це просто процес приєднання поведінки JavaScript до HTML-елементів, які були згенеровані на сервері. Це
                    необхідно для створення інтерактивної веб-сторінки, що дозволяє користувачам натискати кнопки, заповнювати форми та
                    виконувати інші дії. Без гідратації веб-сторінки були б статичними та неспроможними реагувати.</p>
                <p>У випадку Server-side Rendering (SSR), HTML та JavaScript генеруються на сервері і відсилаються на клієнт у вигляді
                    повноцінного документа. Однак цей HTML лише статично представляє сторінку. Гідратація в таких випадках є необхідною для
                    приєднання обробників подій до сторінки, роблячи її інтерактивною. Після завантаження HTML та JavaScript бандлів браузер
                    виконує JavaScript, який приєднує обробники подій до HTML, забезпечуючи повноцінний інтерактивний досвід
                    користувача.</p>
                <p>У випадку Client-side Rendering (CSR), весь JavaScript бандл завантажується та виконується на стороні клієнта, і
                    гідратація не потрібна. JavaScript може безпосередньо маніпулювати HTML-елементами, які він створив, без додаткового
                    етапу гідратації.</p>
                <p>Отже, гідратація є ключовим елементом для створення динамічних та інтерактивних веб-додатків, особливо в контексті
                    рендерингу на стороні сервера.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>


    </ul>


    <h5 id="css">CSS</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Анімації
            </div>
            <div class="collapsible-body">
                <p>Анімація у CSS дозволяє створювати рухливі та привабливі ефекти на веб-сайтах. Ось основні аспекти використання CSS
                    анімації:</p>
                <ol>
                    <li>
                        <strong>Ключові Кадри (Keyframes)</strong>
                        <ul>
                            <li>Ключові кадри визначають стани елемента на різних етапах анімації.</li>
                            <li>Використовуються ключові слова @keyframes для створення набору кадрів.</li>
                            <li>
                                <pre>
                                    @keyframes example {
                                      0% { opacity: 0; }
                                      50% { opacity: 0.5; }
                                      100% { opacity: 1; }
                                    }
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивість animation</strong>
                        <ul>
                            <li>Властивість animation використовується для визначення анімації для елемента.</li>
                            <li>Зазвичай вказується ім'я ключових кадрів та тривалість анімації.</li>
                            <li>.element { animation: example 3s ease-in-out; }</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Опції Таймінгу:</strong>
                        <ul>
                            <li><strong>ease</strong>: починається повільно, прискорюється, а потім знову сповільнюється.</li>
                            <li><strong>linear</strong>: рухається з однаковою швидкістю протягом всієї тривалості.</li>
                            <li><strong>ease-in</strong>: починається повільно, потім прискорюється.</li>
                            <li><strong>ease-out</strong>: починається швидко, потім сповільнюється.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивості animation-delay та animation-iteration-count</strong>
                        <ul>
                            <li><strong>animation-delay</strong> вказує затримку перед початком анімації.</li>
                            <li><strong>animation-iteration-count</strong> визначає кількість повторень анімації.</li>
                            <li>.element { animation-delay: 2s; animation-iteration-count: infinite; }</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Зміна Властивостей:</strong>
                        <ul>
                            <li>Анімація може змінювати різні властивості, такі як розмір, колір, положення тощо.</li>
                            <li><pre>
                                @keyframes example {
                                    0% { transform: scale(1); }
                                    50% { transform: scale(1.5); }
                                    100% { transform: scale(1); }
                                }
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивість animation-fill-mode:</strong>
                        <ul>
                            <li>Вказує, яким чином стилі мають застосовуватися до елемента поза межами визначеної анімації.</li>
                            <li>.element { animation: example 3s ease-in-out; animation-fill-mode: forwards; }
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Різниця між Grid & Flexbox
            </div>
            <div class="collapsible-body">
                <p>Розуміння різниці між CSS Grid та Flexbox є ключовим для ефективного проектування макету. Особа, яка проходить інтерв'ю,
                    повинна вміти висловлювати ці різниці та їхні випадки використання.</p>

                <p>CSS Grid - це двовимірна система, яка обробляє як рядки, так і стовпці, ідеальна для масштабних макетів. Flexbox - це
                    одновимірна система, яка обробляє один рядок АБО один стовпець одночасно, найбільш підходить для менших макетів, де
                    елементи
                    повинні вирівнюватися або розподілятися відносно один одного. Подавшись для розташування загальної структури, Grid, як
                    правило, використовується для розташування елементів всередині тих самих комірок Grid.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Методології CSS (BEM, OOCSS, SMACSS)
            </div>
            <div class="collapsible-body">
                <p>Методології CSS — це підходи до написання та організації коду на Cascading Style Sheets (CSS). Кілька популярних
                    методологій включають BEM (Block, Element, Modifier), OOCSS (Object-Oriented CSS) та SMACSS (Scalable and Modular
                    Architecture for CSS).</p>
                <ol>
                    <li>
                        <strong>BEM (Block, Element, Modifier):</strong>
                        <ul>
                            <li>
                                <strong>Блок (Block): </strong>
                                <p>Основний компонент, незалежний від контексту.</p>
                            </li>
                            <li>
                                <strong>Елемент (Element): </strong>
                                <p>Частина блока, яка не має сенсу самостійно, але має сенс в контексті блока.</p>
                            </li>
                            <li>
                                <strong>Модифікатор (Modifier): </strong>
                                <p>Зміна вигляду або стану блока чи елемента.</p>
                            </li>
                        </ul>
                        <strong>Переваги BEM:</strong>
                        <ul>
                            <li>Чітка структура і неймінг, що полегшує розробку та підтримку.</li>
                            <li>Універсальність і висока переносимість компонентів.</li>
                        </ul>
                        <strong>Недоліки BEM:</strong>
                        <ul>
                            <li>Збільшує об'єм HTML-коду через використання багато класів.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>OOCSS (Object-Oriented CSS):</strong>
                        <ul>
                            <li>
                                <strong>Об'єкт (Object):</strong>
                                <p>Відокремлений, повторно використовуваний компонент, який має стилі та властивості.</p>
                            </li>
                            <li>
                                <strong>Зовнішній вигляд (Separation of Concerns):</strong>
                                <p>Розділення структури та оформлення елементів.</p>
                            </li>
                        </ul>
                        <strong>Переваги OOCSS:</strong>
                        <ul>
                            <li>Збільшує повторне використання коду та спрощує його обслуговування.</li>
                            <li>Забезпечує швидше завантаження сторінок через оптимізацію CSS.</li>
                        </ul>
                        <strong>Недоліки OOCSS:</strong>
                        <ul>
                            <li>Може призвести до менш чіткої структури та менш простого коду.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>SMACSS (Scalable and Modular Architecture for CSS):</strong>
                        <ul>
                            <li>
                                <strong>Масштабована (Scalable): </strong>
                                <p>Спроект може зростати без значного збільшення складності CSS.</p>
                            </li>
                            <li>
                                <strong>Модульна (Modular): </strong>
                                <p>Складові частини дизайну повинні бути незалежними та переносимими.</p>
                            </li>
                        </ul>
                        <strong>Переваги SMACSS:</strong>
                        <ul>
                            <li>Сприяє простоті та чіткості в організації коду.</li>
                            <li>Простота управління та вдосконалення проектів через модульний підхід.</li>
                        </ul>
                        <strong>Недоліки SMACSS:</strong>
                        <ul>
                            <li>Може вимагати більше часу та зусиль для вивчення та впровадження.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Переваги використання препроцесорів в проекті
            </div>
            <div class="collapsible-body">
                <p>
                    Процесори CSS, такі як SASS та LESS, розширюють базові можливості CSS. Вони вводять функції, такі як змінні,
                    вкладеність, міксини та успадкування, що робить CSS більш підтримуваним та організованим. Однак вони вимагають процесу
                    збірки, і створений CSS не завжди може бути оптимізованим. Також відладка може бути складнішою через різницю між
                    написаним кодом та компільованим CSS.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Різниця між position: relative & position: absolute
            </div>
            <div class="collapsible-body">
                <p>
                    Відносне та абсолютне позиціонування - це два різних способи розміщення елементів на сторінці веб-сайту.</p>
                <ol>
                    <li>
                        <strong>Відносне позиціонування:</strong>
                        <p>При відносному позиціонуванні елемент зсувається відносно його звичайного положення в документі, при цьому
                            зберігаючи його в поточному потоці документа. Це означає, що інші елементи на сторінці не впливають на цей рух.
                            Наприклад, якщо ми переміщуємо блок на 20px вправо, простір, який він почав займати, залишається незмінним.</p>
                    </li>
                    <li>
                        <strong>Абсолютне позиціонування:</strong>
                        <p>При абсолютному позиціонуванні елемент вилучається з потоку документа, і для нього не створюється простір в
                            макеті сторінки. Елемент позиціонується відносно його найближчого позиціонованого предка (якщо такий є), або, в
                            іншому випадку, відносно тіла документа. Інші елементи на сторінці можуть займати простір, який раніше належав
                            абсолютно позиціонованому елементу.</p>
                    </li>
                </ol>
                <p>Отже, відносне позиціонування зміщує елемент відносно його звичайного положення, залишаючи його в потоці документа, тоді
                    як абсолютне позиціонування вилучає елемент з потоку і позиціонує його відносно певного контейнера.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що необхідно врахувати (CSS) при розробці мультимовного сайту?
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>Розширення тексту:</strong>
                        <p>Різні мови можуть вимагати різної кількості місця для тексту. Переконайтеся, що ваш дизайн може вміщати текстовий
                            контент, щоб уникнути проблем з макетом. Це особливо важливо для мов, які можуть мати значно більше словесного
                            обсягу.</p>
                    </li>
                    <li>
                        <strong>Напрямок читання:</strong>
                        <p>Мови, такі як арабська та іврит, читаються справа наліво. Це може вплинути на макет та навігацію. Переконайтеся,
                            що ваш дизайн правильно відображає напрямок читання для кожної мови.</p>
                    </li>
                    <li>
                        <strong>Кодування символів:</strong>
                        <p>Використовуйте UTF-8 для кодування символів, щоб підтримувати всі можливі символи та мови. Це дозволить коректно
                            відображати текст у всіх мовах.</p>
                    </li>
                    <li>
                        <strong>Кольори та зображення:</strong>
                        <p>Кольори та зображення можуть мати різні культурні конотації. Вибирайте універсально прийняті кольори та
                            зображення, щоб уникнути можливих непорозумінь або несприятливих асоціацій в різних культурах.</p>
                    </li>
                    <li>
                        <strong>Перемикач мови:</strong>
                        <p>Забезпечте видимість та легкість використання перемикача мов. Користувачі повинні легко змінювати мову на сайті,
                            якщо це необхідно. Це може бути особливо важливо для користувачів, які використовують більше однієї мови.</p>
                    </li>
                </ol>
                <p>Ураховуючи ці аспекти, ви забезпечите, що ваш веб-сайт буде ефективним і коректно працюватиме для користувачів різних мов
                    та культур.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Псевдо-елементи та псевдо-класи
            </div>
            <div class="collapsible-body">
                <p>Псевдокласи і псевдоелементи - це обидві концепції в CSS, але вони використовуються для визначення різних частин
                    елементів або стану елемента. Ось їхні основні відмінності:</p>
                <ol>
                    <li>
                        <strong>Псевдокласи:</strong>
                        <ul>
                            <li>Визначають стан або контекст елемента.</li>
                            <li>Позначаються однією двокрапкою (:) перед ім'ям.</li>
                            <li>Приклади псевдокласів: :hover (для стилізації при наведенні), :active (для стилізації активного стану),
                                :nth-child(n) (для вибору елементів за порядковим номером) і т.д.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Псевдоелементи:</strong>
                        <ul>
                            <li>Визначають конкретні частини елемента.</li>
                            <li>Позначаються двома двокрапками (::) перед ім'ям.</li>
                            <li>Приклади псевдоелементів: ::before (додає контент перед елементом), ::after (додає контент після елемента),
                                ::first-line (стилізація першого рядка тексту в елементі) і т.д.
                            </li>
                        </ul>
                    </li>
                </ol>

                <h6>Приклади елементів: </h6>
                <strong>Псевдокласи:</strong>
                <ol>
                    <li>
                        <strong>:hover</strong>
                        <p>Стилізація, яка застосовується, коли користувач наводить курсор на елемент.</p>
                    </li>
                    <li>
                        <strong>:active</strong>
                        <p>Стилізація для активного стану елемента, тобто коли користувач утримує кнопку миші на елементі.</p>
                    </li>
                    <li>
                        <strong>:focus</strong>
                        <p>Стилізація для стану фокусу, що виникає, коли елемент отримує фокус (наприклад, поле вводу).</p>
                    </li>
                    <li>
                        <strong>:nth-child(n)</strong>
                        <p>Вибір елементів за їхнім порядковим номером в батьківському контейнері.</p>
                    </li>
                    <li>
                        <strong>:not(selector)</strong>
                        <p> Вибір всіх елементів, які не відповідають вказаному селектору.</p>
                    </li>
                    <li>
                        <strong>:first-child</strong>
                        <p>Вибір першого елемента в рядку його батьківського контейнера.</p>
                    </li>
                    <li>
                        <strong>:last-child</strong>
                        <p>Вибір останнього елемента в рядку його батьківського контейнера.</p>
                    </li>
                </ol>
                <strong>Псевдоелементи:</strong>
                <ol>
                    <li>
                        <strong>::before</strong>
                        <p> Додає контент до початку вмісту елемента.</p>
                    </li>
                    <li>
                        <strong>::after</strong>
                        <p>Додає контент в кінець вмісту елемента.</p>
                    </li>
                    <li>
                        <strong>::first-line</strong>
                        <p>Стилізація першого рядка тексту в елементі.</p>
                    </li>
                    <li>
                        <strong>::first-letter</strong>
                        <p>Стилізація першої літери тексту в елементі.</p>
                    </li>
                    <li>
                        <strong>::selection</strong>
                        <p>Стилізація виділеного тексту користувачем.</p>
                    </li>
                </ol>

                <p>Загалом, псевдокласи використовуються для визначення стану елемента в різних ситуаціях, тоді як псевдоелементи
                    використовуються для стилізації конкретних частин цього елемента. Обидва підходи дозволяють розширити можливості
                    стилізації веб-сторінок та забезпечити більше гнучкості в роботі з різними частинами контенту.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Вага селекторів (специфічність)
            </div>
            <div class="collapsible-body">
                <p>Специфічність – це алгоритм, що використовується браузерами для визначення того оголошення CSS, яке найбільше відповідає
                    елементові. </p>
                <p>Вага визначається числом селекторів кожної вагової категорії у селекторі, що дає збіг з елементом (чи псевдоелементом).
                    Якщо є два чи більше оголошень, що надають різні значення властивостей для одного елемента, то застосовується значення
                    оголошення із блоку стилів, що має селектор зі збігом з найбільшою алгоритмічною вагою.</p>
                <p>Алгоритм специфічності по суті є триколонковим порівнянням значень трьох категорій чи ваг – ID, CLASS та TYPE – що
                    відповідають трьом типам селекторів. Це значення представляє кількість компонентів селектора з кожної вагової категорії
                    та записується як ID - CLASS - TYPE. Три колонки утворюються шляхом підрахунку кількості компонентів з кожної вагової
                    категорії у селекторах, що відповідають елементові. (Умовно 1-0-0 - кейс для ID)</p>
                <p>
                    Вага селекторів в CSS визначає, який стилізаційний правило має вищий пріоритет у випадку конфлікту між різними
                    правилами. Вага визначається на основі типу селекторів та їхнього порядку в CSS-правилі.</p>
                <p>
                    Каскад CSS визначає, які стилі застосовуються до елемента на основі трьох основних чинників: важливості, специфічності
                    та порядку джерела. Важливість вказує на вагу, яку має правило стилів. Наприклад, вбудовані стилі мають важливість вище,
                    ніж зовнішні таблиці стилів. Специфічність визначається типом селектора, використовуваного в правилі. Селектори ID мають
                    високу специфічність, тоді як селектори класів мають меншу специфічність. Порядок джерела важливий, коли два правила
                    мають рівну важливість і специфічність; застосовуватиметься останнє правило.</p>
                <p><strong>Важливо!</strong> Якщо одинакова вага селекторів, до прикладу, 1-1-1 і 1-1-1 - застосується те правило, яке
                    умовно "нижче" в файлі, скажімо так - перетирає суперника, який "вище".</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Змінні в CSS
            </div>
            <div class="collapsible-body">
                <p>CSS власні властивості, також відомі як змінні, декларуються двоступінчастим процесом. По-перше, їх визначають всередині
                    селектора, префіксуючи назву властивості двома тире (–). Наприклад: –main-color: black;. Це створює змінну з назвою
                    "main-color" і значенням "black".</p>
                <p>По-друге, для використання цих змінних ми використовуємо функцію var(). Синтаксис виглядає так: color: var(–main-color);.
                    Тут движок CSS під час виконання буде замінювати var(–main-color) відповідним значенням ("black").</p>
                <p>Змінні можуть мати глобальний або локальний обсяг. Якщо вони визначені всередині селектора :root, вони стають глобальними
                    і доступними з будь-якої частини документа. Локальні змінні обмежені селектором, в якому вони визначені.</p>
                <p>Вони надають переваги, такі як можливість повторного використання, зменшення зайвості та полегшення створення тем. Проте
                    перед використанням їх слід перевірити сумісність з браузерами, оскільки не всі браузери підтримують цю
                    функціональність.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як можна оптимізувати CSS для кращого перформансу?
            </div>
            <div class="collapsible-body">
                <p>Оптимізація CSS для поліпшення продуктивності включає кілька стратегій. Мініфікація, яка видаляє непотрібні символи з
                    коду без зміни функціональності, може зменшити розмір файлу та поліпшити час завантаження. Стиснення Gzip додатково
                    зменшує розмір файлу, знаходячи схожі рядки в текстовому файлі і тимчасово їх замінюючи, щоб узагальнений розмір файлу
                    став меншим.</p>
                <p>Ще одна стратегія - використання скорочених властивостей в CSS, що дозволяє встановлювати значення кількох пов'язаних
                    властивостей одночасно. Це не тільки робить ваш код більш зрозумілим, але й зменшує його розмір.</p>
                <p>Ще одна стратегія - використання скорочених властивостей в CSS, що дозволяє встановлювати значення кількох пов'язаних
                    властивостей одночасно. Це не тільки робить ваш код більш зрозумілим, але й зменшує його розмір.</p>
                <p>Селектори CSS також слід оптимізувати. Уникайте складних або зайвих селекторів нащадків, що може допомогти браузерам
                    швидше визначати селектори. Також розміщення таблиць стилів у верхній частині вашого HTML-документа забезпечує
                    прогресивний рендеринг, дозволяючи користувачам бачити стилі раніше.</p>
                <p>Нарешті, використання зовнішніх таблиць стилів замість вбудованих допомагає із кешуванням, зменшуючи кількість даних, які
                    потрібно завантажити при повторному відвідуванні сторінки.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Селектори атрибутів
            </div>
            <div class="collapsible-body">
                <p>Селектори атрибутів в CSS визначають елементи HTML на основі їх атрибутів та значень атрибутів. Вони використовуються для
                    стилізації елементів з конкретними атрибутами чи значеннями атрибутів.</p>
                <p>Існує чотири типи селекторів атрибутів:</p>
                <ol>
                    <li>
                        <strong>[attribute]</strong>
                        <p> Вибирає елементи з вказаним атрибутом, незалежно від його значення.</p>
                    </li>
                    <li>
                        <strong>[attribute=value]</strong>
                        <p>Відповідає елементам з конкретним значенням атрибуту1</p>
                    </li>
                    <li>
                        <strong>[attribute~=value]</strong>
                        <p>Спрямовується на елементи, значення атрибуту яких є списком значень, розділених пробілами, одне з яких відповідає
                            'value'.</p>
                    </li>
                    <li>
                        <strong>[attribute|=value]</strong>
                        <p>Застосовує стилі до елементів зі значенням атрибуту, яке точно дорівнює 'value' або починається з 'value-'.</p>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Позиціонування елементів - "relative", "absolute", "fixed" та "sticky"
            </div>
            <div class="collapsible-body">
                <p>У CSS позиціонування "relative", "absolute", "fixed" та "sticky" мають свої відмінності:</p>
                <ol>
                    <li>
                        <strong>Relative (відносне) позиціонування:</strong>
                        <p>Переміщує елемент відносно його звичайного положення, не впливаючи на оточуючі елементи. Зсув визначається
                            відносно початкового положення.</p>
                    </li>
                    <li>
                        <strong>Absolute (абсолютне) позиціонування:</strong>
                        <p>Забирає елемент з потоку документа. Його положення встановлюється відносно його найближчого позиціонованого
                            предка або контейнера, якщо такого немає.</p>
                    </li>
                    <li>
                        <strong>Fixed (фіксоване) позиціонування:</strong>
                        <p>Теж забирає елемент з потоку документа, але розташовує його відносно видимої області. Він залишається на місці,
                            навіть коли сторінка прокручується.</p>
                    </li>
                    <li>
                        <strong>Sticky (приліплене) позиціонування:</strong>
                        <p>Це гібридний тип, який веде себе як "relative" до певного моменту прокрутки, а потім діє як "fixed". Це дозволяє
                            елементу "прилипати" до верхньої частини екрану під час прокрутки.</p>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Препроцесори
            </div>
            <div class="collapsible-body">
                <p>
                    CSS-препроцесори, такі як SASS, розширюють функціональність базового CSS, вводячи такі можливості, як змінні,
                    вкладеність, міксіни та успадкування. Ці можливості роблять код більш обслуговуваним, переадресованим та
                    масштабованим.</p>
                <p>Використовується SASS для створення адаптивного веб-дизайну в т.ч. Наприклад, змінні для
                    кольорових схем та розмірів шрифтів, що дозволило легко змінювати ці елементи на всьому веб-сайті за допомогою лише
                    однієї зміни значення змінної.</p>
                <p>Міксіни для повторного використання блоків стилів, які часто застосовувалися до різних компонентів. Це зменшило зайвість
                    і покращило читабельність. Вкладеність була ще однією корисною можливістю; вона допомагала тримати пов'язані стилі
                    разом, роблячи таблицю стилів легшею для навігації.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Одиниці вимірювання CSS
            </div>
            <div class="collapsible-body">
                <p>
                    В CSS існує кілька одиниць вимірювання, і кожна з них має свої особливості та використання. Ось кілька основних
                    одиниць:</p>
                <ol>
                    <li>
                        <strong>px (пікселі):</strong>
                        <p>Це абсолютна одиниця вимірювання. Значення вказується в пікселях, які є найменшими екранними елементами. px
                            зручно використовувати для фіксованих розмірів та положень.</p>
                    </li>
                    <li>
                        <strong>em:</strong>
                        <p>Вказує розмір відносно розміру шрифта батьківського елемента. Якщо розмір шрифта батька рівний 16px, 1em буде
                            такий самий, як 16px.</p>
                    </li>
                    <li>
                        <strong>rem (кореневий em):</strong>
                        <p>Подібний до em, але відноситься до розміру шрифта кореневого елемента (зазвичай до елемента < html>). rem
                            зручно використовувати для забезпечення консистентного масштабування шрифтів усієї сторінки.</p>
                    </li>
                    <li>
                        <strong>% (відсотки):</strong>
                        <p>Вказує розмір відносно розміру батьківського елемента. Наприклад, якщо ширина батьківського елемента - 200px, 50%
                            буде рівно 100px.</p>
                    </li>
                    <li>
                        <strong>vw та vh (ширина та висота видимого вікна):</strong>
                        <p>Вказують розмір відносно ширини та висоти видимого вікна відповідно. Наприклад, 1vw представляє 1% ширини
                            видимого вікна.</p>
                    </li>
                    <li>
                        <strong>ch (ширина символу "0"):</strong>
                        <p>Вказує розмір відносно ширини символу "0" у поточному шрифті.</p>
                    </li>
                </ol>
                <p>Коли краще використовувати кожну з цих одиниць залежить від конкретного контексту та потреб вашого проекту. Зазвичай,
                    використання відносних одиниць (em, rem, %, vw, vh) дозволяє створювати більш гнучкий та адаптивний дизайн.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                What steps do you take to ensure your websites are accessible to all users, including those with visual impairments?
            </div>
            <div class="collapsible-body">
                <p>Забезпечення доступності веб-сайтів для користувачів з візуальними порушеннями передбачає використання ряду
                    стратегій.</p>
                <ol>
                    <li>
                        <strong>Використовуйте семантичний HTML</strong>
                        <p>Використання тегів з їх призначенням допомагає створити змістовною структуру, яка легше інтерпретується читачами
                            екрану.</p>
                    </li>
                    <li>
                        <strong>Впроваджуйте ролі та властивості ARIA:</strong>
                        <p>Застосовуйте ARIA для покращення семантики елементів, особливо коли семантичний HTML недостатній.</p>
                        <hr>
                        <strong>ARIA</strong>
                        <p>ARIA (Accessible Rich Internet Applications) — це набір стандартів, які допомагають поліпшити доступність
                            веб-сайтів та веб-додатків для осіб із обмеженими можливостями, зокрема для користувачів з вадами зору або
                            моторики. ARIA додає додаткову інформацію та позначення до елементів HTML, щоб допомогти технологіям допомоги,
                            таким як читачі екрану, краще інтерпретувати та взаємодіяти з контентом.</p>
                        <p>Деякі основні ролі та властивості ARIA включають:</p>
                        <ol>
                            <li>
                                <strong>Ролі:</strong>
                                <ul>
                                    <li>role="navigation": Вказує, що елемент є навігаційним блоком.</li>
                                    <li>role="button": Вказує, що елемент є кнопкою.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Властивості:</strong>
                                <ul>
                                    <li>aria-labelledby: Вказує ідентифікатор елемента, який слід використовувати для надання опису.</li>
                                    <li>aria-hidden="true": Приховує елемент від технологій допомоги.</li>
                                </ul>
                            </li>
                        </ol>
                        <p>Приклад використання ARIA може виглядати так: < button aria-label="Close" onclick="closePopup()">X< /button></p>
                        <p>У цьому прикладі, aria-label вказує на альтернативний текст для кнопки, який буде використовуватися технологіями
                            допомоги. ARIA може бути особливо корисним, коли семантичний HTML не надає достатньої інформації для
                            користувачів з вадами.</p>
                    </li>
                    <li>
                        <strong>Дбайте про контраст кольорів:</strong>
                        <p>Забезпечте достатній контраст між текстом та фоном для полегшення читання особам з кольоровим сліпим або низьким
                            зіром.</p>
                    </li>
                    <li>
                        <strong>Забезпечуйте доступність клавіатури:</strong>
                        <p>Переконайтеся, що всі функції можна використовувати за допомогою клавіатури, особливо корисно для тих, хто не
                            може використовувати мишу.</p>
                    </li>
                    <li>
                        <strong>Включайте альтернативний текст для зображень:</strong>
                        <p>Додавання опису для зображень допомагає людям, які використовують читачі екрану, зрозуміти їхній зміст.</p>
                    </li>
                    <li>
                        <strong>Розробляйте адаптивні макети:</strong>
                        <p>Використовуйте властивості позиції CSS для створення адаптивних макетів, які легко пристосовуються до різних
                            розмірів екрану.</p>
                    </li>
                    <li>
                        <strong>Регулярно тестуйте з технологіями допомоги:</strong>
                        <p>Використовуйте різноманітні технології допомоги для тестування доступності та виявлення можливих проблем.</p>
                    </li>
                </ol>
                <p>Ці поради спрямовані на створення веб-сайтів, які будуть доступними для всіх користувачів, включаючи тих, у кого є
                    візуальні порушення.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="security">Security</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Кращі практики безпеки веб-додатків
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>Валідація вхідних даних</strong>
                        <p>Однією з основних атак, на які піддаються веб-програми, є атака на вхідні дані. Розробники
                            повинні завжди перевіряти та валідувати дані, які отримують від користувачів, щоб запобігти
                            SQL-ін'єкції, крос-сайтовий скриптинг (XSS) та інші атаки.</p>
                    </li>
                    <li>
                        <strong>Захист від автентифікації та керування сеансами</strong>
                        <p>Керування сеансами та автентифікація користувачів - це ключові аспекти безпеки веб-додатків.
                            Надійна автентифікація з використанням сильних паролів та двофакторної автентифікації є
                            обов'язковою. Крім того, сесії користувачів мають бути захищені від перехоплення та
                            підробки.</p>
                    </li>
                    <li>
                        <strong>Оновлення та патчі</strong>
                        <p>Регулярне оновлення та встановлення патчів для веб-додатків, бібліотек та фреймворків, що
                            використовуються, - це обов'язкова умова для забезпечення безпеки. Уразливості, виявлені у
                            сторонніх компонентах, можуть стати легкою здобиччю для зловмисників.</p>
                    </li>
                    <li>
                        <strong>Обмеження прав доступу</strong>
                        <p>Застосування принципу найменших привілеїв (Least Privilege) є важливим для зменшення ризиків.
                            Користувачі та компоненти програми повинні мати лише права доступу, які необхідні для
                            виконання своїх завдань.</p>
                    </li>
                    <li>
                        <strong>Моніторинг та журналювання</strong>
                        <p>Ведення журналів дій користувачів та системних подій дозволяє виявляти аномалії та атаки у
                            реальному часі. Моніторинг дозволяє оперативно реагувати на загрози та запобігати витоку
                            даних.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Основні види вразливостей веб-застосунків
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>SQL-ін'єкції</strong>
                        <p>SQL-ін'єкції виникають, коли зловмисник впроваджує шкідливий SQL-код у запити до бази даних.
                            Це може призвести до незаконного доступу до даних або їх зміни. Правильна валідація та
                            використання параметризованих запитів допомагають запобігти SQL-ін'єкції.</p>
                        <p>SQL ін’єкція (SQLi) — це тип ін’єкційної атаки, яка дозволяє модифікувати SQL команди для
                            отримання даних або виведення з ладу програми. Зловмисники можуть модифікувати команди SQL,
                            які впливають на ваш застосунок, через деякі вхідні дані на вашому сайті, наприклад, поле
                            пошуку.</p>
                        <p>Успішне виконання SQL ін’єкції може призвести до неавторизованого доступу до конфіденційних
                            даних (це може бути дуже «чутлива» інформація — наприклад, паролі, адреси, дані кредитних
                            карток і так далі). За останні кілька років багато випадків витоку інформації стали
                            результатом саме SQL ін’єкцій.</p>
                    </li>
                    <li>
                        <strong>Крос-сайтовий скриптинг (XSS - Cross-Site Scripting)</strong>
                        <p>XSS - це атака, за якої зловмисник впроваджує шкідливий JavaScript-код у веб-сторінку, який
                            виконується у браузері користувача. Захист від XSS включає екранування даних і використання
                            Content Security Policy (CSP).</p>
                        <p>Головна ідея XSS в тому, що зловмиснику вдається додати на сторінку JavaScript-код, якого до
                            цього не було. Цей код буде виконуватися щоразу, коли жертви (тобто користувачі)
                            заходитимуть на сторінку застосунку, де цей код додав зловмисник.</p>
                        <p>XSS вразливість виникає при генерації HTML-сторінки, коли розробнику потрібно помістити туди
                            дані, вказані користувачем. Якщо хакер зможе розмістити довільний HTML-код, то отримає
                            доступ до змін та керування відображенням вебсторінки з правами самого сайту.</p>
                        <p>Наслідки від XSS ін’єкції можуть бути критичними. Так, дана ін’єкція не впливає безпосередньо
                            на застосунок, вона спрямована на користувача. Проте зловмисник може вкрасти авторизаційні
                            cookie користувача застосунку і тим самим його сесію. Також може перенаправити користувача
                            на власний сайт, де розмістить форми вводу, схожі на оригінальні. І якщо користувач введе
                            свої дані, то вони опиняться у зловмисника. Можливість для безперешкодного експлуатування
                            XSS ін’єкції у застосунку може призвести до витоку даних та суттєвих репутаційних втрат для
                            компанії.</p>
                    </li>
                    <li>
                        <strong>Крос-сайтова підробка запиту (CSRF - Cross-Site Request Forgery)</strong>
                        <p>CSRF - це атака, коли зловмисник змушує користувача виконувати небажані дії без його згоди.
                            Захист від CSRF включає використання токенів запитів (CSRF-токени) і перевірку
                            Referer-заголовка.</p>
                    </li>
                    <li>
                        <strong>Недоліки автентифікації та керування сеансами</strong>
                        <p>Слабка автентифікація та керування сеансами можуть призвести до компрометації облікових
                            записів користувачів. Для захисту слід використовувати сильні паролі, двофакторну
                            автентифікацію та надійне керування сеансами.</p>
                        <p><strong>Автентифікація</strong> — це дії, вжиті для встановлення або перевірки чогось або когось. Це процедура
                            встановлення належності користувачеві
                            інформації в системі пред’явленого ним ідентифікатора. В інформаційній безпеці автентифікація є частиною
                            процедури надання доступу користувачу для
                            роботи в застосунку, наступною після ідентифікації та передує авторизації.</p>
                        <p>Автентифікація дуже важливий функціонал застосунку, оскільки дозволяє реалізувати безпечний доступ до даних.
                            Кожен користувач хоче бути впевнений у тому, що його дані неможливо забрутфорсити й вони зберігаються безпечно.
                            В результаті шлях користувача в системі виглядає приблизно так: спочатку користувача ідентифікується з
                            ідентифікатором користувача, а після цього виконується автентифікація на основі наданого користувачем пароля,
                            який відповідає цьому ідентифікатору.</p>
                        <p>Вразливості автентифікації можуть виникати з різних причин, тому немає єдиного алгоритму їх пошуку. Серед
                            найбільш поширених вразливостей можна перерахувати наступні:</p>
                        <ul>
                            <li>атака перебору імені користувача та пароля</li>
                            <li>відсутність перевірки складності пароля</li>
                            <li>некоректний менеджмент сесії</li>
                            <li>неправильна реалізація функціонала зміни та відновлення пароля</li>
                            <li>атаки на JWT токени тощо.</li>
                        </ul>
                        <p>Проблема вразливості автентифікації є однією з найпростіших проблем для розуміння ризиків. І водночас вони можуть
                            бути одними з найбільш критичних через очевидний зв’язок між автентифікацією та безпекою. Крім того, що проблеми
                            автентифікації потенційно дозволяють зловмисникам отримати прямий доступ до конфіденційних даних і функцій, вони
                            також створюють додатковий простір для атаки та інтеграції нових експлойтів. Тому навчитися виявляти та
                            використовувати вразливі місця автентифікації, включаючи те, як обійти загальні заходи захисту, є однією з
                            фундаментальних навичок не тільки кіберфахівців, а й розробників та всіх хто працює з даними користувачів в
                            продукті.</p>
                    </li>
                </ol>
            </div>
        </li>
    </ul>

    <h5 id="network">Network</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are HTTP methods?
            </div>
            <div class="collapsible-body">
                <p>HTTP-методи визначають, яку операцію необхідно виконати для заданого ресурсу. Ось список HTTP-методів та їх
                    пояснення:</p>
                <ol>
                    <li>
                        <strong>GET</strong>
                        <p>Використовується для отримання даних зазначеного ресурсу. Параметри передаються у URL.</p>
                    </li>
                    <li>
                        <strong>POST</strong>
                        <p>Використовується для відправлення даних на сервер для обробки. Зазвичай використовується для відправки даних
                            форм.</p>
                    </li>
                    <li>
                        <strong>PUT</strong>
                        <p>Використовується для оновлення або створення ресурсу на сервері. Весь ресурс замінюється вказаним в запиті.</p>
                    </li>
                    <li>
                        <strong>DELETE</strong>
                        <p>Використовується для видалення зазначеного ресурсу на сервері.</p>
                    </li>
                    <li>
                        <strong>PATCH</strong>
                        <p>Використовується для часткового оновлення ресурсу. Відправляє тільки ті дані, які слід змінити.</p>
                    </li>
                    <li>
                        <strong>HEAD</strong>
                        <p>Аналогічний методу GET, але повертає тільки заголовки відповіді, без самого тіла.</p>
                    </li>
                    <li>
                        <strong>OPTIONS</strong>
                        <p>Використовується для отримання інформації про можливі HTTP-методи для ресурсу, або отримання інформації про
                            конфігурацію сервера.</p>
                    </li>
                    <li>
                        <strong>TRACE</strong>
                        <p>Використовується для тестування шляху до ресурсу, аналізуючи зміни, які вносять проміжні сервери.</p>
                    </li>
                    <li>
                        <strong>CONNECT</strong>
                        <p>Використовується для встановлення тунелю до сервера, який визначений URI, зазвичай для забезпечення безпеки через
                            проксі.</p>
                    </li>
                </ol>
                <p>Ці HTTP-методи визначають різні дії, які клієнт чи сервер можуть виконати з ресурсом, що ідентифікується URI.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Why has it been better to serve site assets from multiple domains?
            </div>
            <div class="collapsible-body">
                <p>Сервіс ресурсів сайту з декількох доменів є практикою, відомою як доменне розділення, і історично це робилося для
                    подолання обмежень, накладених браузерами. Основна причина використання доменного розділення полягала в збільшенні
                    кількості одночасних з'єднань, які браузер може встановити з веб-сервером, тим самим покращуючи загальну продуктивність
                    веб-сайту. Ось ключові причини:</p>
                <ol>
                    <li>
                        <strong>Паралельні з'єднання:</strong>
                        <p>Браузери обмежують кількість одночасних з'єднань, які вони можуть встановити з одним доменом. Використання
                            декількох доменів дозволяє одночасно завантажувати ресурси з різних доменів, що підвищує паралельність і
                            прискорює завантаження сторінки.</p>
                    </li>
                    <li>
                        <strong>Покращення продуктивності:</strong>
                        <p>Коли різні ресурси (зображення, стилі, скрипти) розміщені на різних доменах, браузери можуть завантажувати їх
                            паралельно, що покращує час завантаження сторінки для користувача.
                        </p>
                    </li>
                    <li>
                        <strong>Оминання обмежень браузера:</strong>
                        <p>Декілька доменів дозволяє обійти обмеження браузера на одночасні з'єднання, що дозволяє сторінці ефективніше
                            завантажувати велику кількість ресурсів.</p>
                    </li>
                </ol>
                <p>Однак важливо відзначити, що з покращенням браузерів та їх здатністю ефективно керувати паралельним завантаженням, а
                    також з впровадженням HTTP/2, яке дозволяє одному з'єднанню ефективно передавати багато ресурсів, потреба в доменному
                    розділенні стала менш актуальною. В деяких випадках може бути корисніше концентруватися на оптимізації ресурсів та
                    використанні сучасних підходів до збільшення продуктивності веб-сайту.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Do your best to describe the process from the time you type in a website's URL to it finishing loading on your screen.
            </div>
            <div class="collapsible-body">
                <p>Процес включає в себе декілька етапів:</p>
                <ol>
                    <li>
                        <strong>Користувач вводить URL:</strong>
                        <p>Ви вводите URL веб-сайту (Uniform Resource Locator) у адресний рядок вашого браузера (наприклад,
                            https://www.example.com).</p>
                    </li>
                    <li>
                        <strong>DNS Запит до Сервера:</strong>
                        <p>Браузер відправляє запит до DNS-сервера для отримання IP-адреси введеного домену.</p>
                    </li>
                    <li>
                        <strong>DNS Розгортання:</strong>
                        <p>DNS-сервер повертає браузеру IP-адресу веб-сайту.</p>
                    </li>
                    <li>
                        <strong>Встановлення З'єднання:</strong>
                        <p>Браузер встановлює TCP/IP з'єднання з сервером, використовуючи отриману IP-адресу та порт (зазвичай порт 80 для
                            HTTP або 443 для HTTPS).</p>
                    </li>
                    <li>
                        <strong>HTTP Запит:</strong>
                        <p>Браузер відправляє HTTP (або HTTPS) запит на сервер, запитуючи ресурси сайту.</p>
                    </li>
                    <li>
                        <strong>Сервер Обробляє Запит:</strong>
                        <p>Веб-сервер обробляє отриманий запит, взягаючи ресурси (HTML, CSS, JavaScript та інші).</p>
                    </li>
                    <li>
                        <strong>Відправлення Response:</strong>
                        <p>Сервер відправляє браузеру Response, яка містить HTML-код, зазвичай відповідь містить також посилання на інші
                            ресурси (зображення, стилі, скрипти).</p>
                    </li>
                    <li>
                        <strong>Завантаження Ресурсів:</strong>
                        <p>Браузер починає завантажувати ресурси, зазначені в HTML-коді. Це можуть бути зображення, таблиці стилів, скрипти
                            та інші.</p>
                    </li>
                    <li>
                        <strong>Складання та Відображення:</strong>
                        <p>Браузер компілює отримані дані, обробляє їх та відображає на екрані, показуючи вам веб-сторінку.</p>
                    </li>
                </ol>
                <p>Цей процес дозволяє браузеру відобразити веб-сторінку на вашому екрані після того, як ви ввели URL.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке DNS?
            </div>
            <div class="collapsible-body">
                <p>DNS (Domain Name System або Система доменних імен) - це система, що перетворює зрозумілі для людини доменні імена
                    (наприклад, www.example.com) в IP-адреси, які використовуються комп'ютерами для знаходження один одного в мережі
                    Інтернет.</p>
                <p>Основні функції DNS включають:</p>
                <ol>
                    <li>
                        <strong>Розгортання Доменних Імен:</strong>
                        <p>DNS переводить зрозумілі для користувача доменні імена в IP-адреси, що вказують на конкретні сервери в
                            мережі.</p>
                    </li>
                    <li>
                        <strong>Розподіл Запитів:</strong>
                        <p>DNS розподіляє запити на розгорнуті доменні імена між різними серверами для зменшення навантаження та
                            забезпечення більшої швидкості відповідей.</p>
                    </li>
                    <li>
                        <strong>Система Кешування:</strong>
                        <p>DNS може кешувати раніше отримані відповіді. Це дозволяє уникнути повторного розгортання для одних і тих самих
                            доменних імен та прискорює процес визначення IP-адрес.</p>
                    </li>
                    <li>
                        <strong>Розподілення Доменних Зон:</strong>
                        <p>DNS розділяє Інтернет на доменні зони (наприклад, .com, .org, .gov), керуючи розподілом доменних імен між різними
                            реєстраторами.</p>
                    </li>
                    <li>
                        <strong>Робота в Різних Рівнях:</strong>
                        <p>DNS працює на різних рівнях, від розгортання конкретного домену до визначення IP-адреси конкретного
                            комп'ютера.</p>
                    </li>
                </ol>
                <p>Ця система є ключовою для правильної ідентифікації та знаходження ресурсів в Інтернеті та інших комп'ютерних мережах.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                HTTP/2 vs HTTP 1 - що таке і в чому різниця?
            </div>
            <div class="collapsible-body">
                <p>HTTP/2 і HTTP/1 - це версії протоколу передачі гіпертексту, які використовуються для обміну даними між браузером і
                    веб-сервером. Ось основні різниці між ними:</p>
                <ol>
                    <li>
                        <strong>Множинні З'єднання:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Використовує одночасно тільки одне з'єднання для кожного запиту.</li>
                            <li><strong>HTTP/2:</strong> Дозволяє множинні з'єднання в одному фізичному з'єднанні, зменшуючи затримку
                                завантаження сторінок.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мультиплексування:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Запити та відповіді передаються послідовно, що може спричинити блокування
                                (blocking).
                            </li>
                            <li><strong>HTTP/2:</strong> Використовує мультиплексування, що дозволяє одночасну передачу багатьох запитів та
                                відповідей на одному з'єднанні.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Компресія Заголовків:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Заголовки не компресуються, що призводить до зайвого обсягу даних.</li>
                            <li><strong>HTTP/2:</strong> Використовує компресію заголовків, що зменшує обсяг передачі даних.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Пріоритети та Ваги:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Немає вбудованої підтримки для визначення приоритетів.</li>
                            <li><strong>HTTP/2:</strong> Дозволяє встановлювати приоритети для різних ресурсів, що допомагає браузерам
                                ефективніше вивантажувати сторінки.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Бінарний Протокол:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Використовує текстовий формат, що може бути важким для обробки та розуміння.</li>
                            <li><strong>HTTP/2:</strong> Використовує бінарний протокол, що полегшує обробку та зменшує помилки.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Підтримка TLS:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Підтримує TLS, але часто використовується без шифрування.</li>
                            <li><strong>HTTP/2:</strong> Вимагає використання TLS (HTTPS), забезпечуючи безпеку.</li>
                        </ul>
                    </li>
                </ol>
                <p>Загалом, HTTP/2 має багато покращень у порівнянні з HTTP/1, забезпечуючи швидше завантаження сторінок та ефективнішу
                    взаємодію між браузером та сервером.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                HTTP vs HTTPS - що таке і їх різниця
            </div>
            <div class="collapsible-body">
                <p>
                    HTTP і HTTPS - це протоколи передачі гіпертексту, які використовуються для обміну даними між браузером користувача і
                    веб-сервером. Ось їхні основні характеристики та різниця:
                </p>
                <ol>
                    <li>
                        <strong>HTTP (Hypertext Transfer Protocol):</strong>
                        <ul>
                            <li>Це стандартний протокол передачі даних в Інтернеті.</li>
                            <li>Дані передаються у відкритому тексті, тобто без шифрування.</li>
                            <li>Використовується для передачі неважливих даних, таких як статичні веб-сайти без обробки конфіденційної
                                інформації.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>HTTPS (Hypertext Transfer Protocol Secure):</strong>
                        <ul>
                            <li>Це розширення протоколу HTTP з доданою безпекою шляхом шифрування.</li>
                            <li>Дані передаються зашифровано, що робить їх менш доступними для несанкціонованого перегляду.</li>
                            <li>Використовується для передачі конфіденційних даних, таких як особисті дані, паролі, інформація про платежі
                                тощо.
                            </li>
                        </ul>
                    </li>
                </ol>
                <strong>Основні різниці:</strong>
                <ol>
                    <li>
                        <strong>Шифрування:</strong>
                        <ul>
                            <li>HTTP передає дані у відкритому тексті, тоді як HTTPS використовує шифрування для захисту конфіденційної
                                інформації від проміжних атак і несанкціонованого доступу.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Безпека:</strong>
                        <ul>
                            <li>HTTP не забезпечує безпеку, що робить його непридатним для передачі конфіденційних даних.</li>
                            <li>HTTPS забезпечує безпеку, що робить його відмінним вибором для обробки чутливої інформації.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Порт:</strong>
                        <ul>
                            <li>HTTP використовує порт 80 для передачі даних.</li>
                            <li>HTTPS використовує порт 443 для шифрованого з'єднання.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Сертифікати:</strong>
                        <ul>
                            <li>HTTPS вимагає встановлення SSL/TLS-сертифікату для шифрування даних.</li>
                            <li>HTTP не вимагає встановлення сертифікату.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Довіреність:</strong>
                        <ul>
                            <li>HTTPS вказує на те, що веб-сайт дійсно той, за який він видає себе, завдяки використанню сертифіката від
                                інституцій, які йому довіряють.
                            </li>
                            <li>HTTP не надає такого підтвердження, і дані можуть бути менш безпечними.</li>
                        </ul>
                    </li>
                </ol>
                <p>В сучасному Інтернеті рекомендується використовувати HTTPS, особливо для сайтів, які обробляють конфіденційну
                    інформацію.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are the differences between Long-Polling, Websockets and Server-Sent Events?
            </div>
            <div class="collapsible-body">
                <p>Лонг-полінг (Long-Polling), WebSockets та Server-Sent Events (SSE) - це техніки взаємодії між клієнтом та сервером для
                    обміну даними в реальному часі. Ось їхні основні відмінності:</p>
                <ol>
                    <li>
                        <strong>Лонг-полінг (Long-Polling):</strong>
                        <ul>
                            <li>Опис: Клієнт відправляє запит на сервер, і сервер утримує відповідь до тих пір, поки не буде доступна нова
                                інформація або не вийде таймаут.
                            </li>
                            <li>
                                <strong>Переваги:</strong>
                                <ul>
                                    <li>Простий у використанні, особливо з стандартними HTTP-серверами.</li>
                                    <li>Достатньо ефективний для обміну рідкісними оновленнями.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Недоліки:</strong>
                                <ul>
                                    <li>Збільшена затримка через очікування на оновлення.</li>
                                    <li>Висока кількість запитів та відповідей.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>WebSockets:</strong>
                        <ul>
                            <li>Опис: Встановлює постійне двостороннє з'єднання між клієнтом та сервером, яке дозволяє обидві сторони
                                надсилати дані в будь-який момент.
                            </li>
                            <li>
                                <strong>Переваги:</strong>
                                <ul>
                                    <li>Низька затримка завдяки постійному з'єднанню.</li>
                                    <li>Дозволяє передавати дані як від сервера до клієнта, так і в зворотному напрямку.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Недоліки:</strong>
                                <ul>
                                    <li>Деякі проблеми з проксі та брандмауерами.</li>
                                    <li>Потрібно підтримувати обидві сторони.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Server-Sent Events (SSE):</strong>
                        <ul>
                            <li>Опис: Встановлює одностороннє з'єднання, де сервер може асинхронно надсилати дані клієнту, але клієнт може
                                лише отримувати дані, а не надсилати їх назад.
                            </li>
                            <li>
                                <strong>Переваги:</strong>
                                <ul>
                                    <li>Простий у використанні, легко реалізувати звичайними HTTP-серверами.</li>
                                    <li>Дозволяє серверу асинхронно повідомляти клієнта про оновлення.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Недоліки:</strong>
                                <ul>
                                    <li>Обмежений одностороннім способом спілкування.</li>
                                    <li>Затримка при великій кількості одночасних підключень.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Кожен з цих підходів має свої використання в залежності від конкретного випадку та вимог проекту.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What is domain pre-fetching and how does it help with performance?
            </div>
            <div class="collapsible-body">
                <p>Попереднє завантаження домену - це техніка, яку веб-браузери використовують для покращення продуктивності, передбачально
                    завантажуючи та кешуючи ресурси з зовнішніх доменів перед тим, як вони дійсно будуть потрібні. Цей процес спрямований на
                    зменшення затримок і покращення загальної швидкості завантаження веб-сторінки. Ось як працює попереднє завантаження
                    домену та його переваги:</p>
                <ol>
                    <li>
                        <strong>Попереднє Завантаження Ресурсів:</strong>
                        <p>Браузер передбачає, які ресурси (такі як файли CSS, JavaScript, зображення тощо) буде потрібно завантажити для
                            конкретної сторінки.</p>
                    </li>
                    <li>
                        <strong>Асинхронне Завантаження:</strong>
                        <p>Замість чекання, коли сторінка дійсно потребує цих ресурсів, браузер асинхронно завантажує їх заздалегідь,
                            використовуючи вільні ресурси мережі.</p>
                    </li>
                    <li>
                        <strong>Зменшення Затримок:</strong>
                        <p>Передбаченням та завантаженням ресурсів заздалегідь браузер робить їх доступними майже миттєво, коли вони дійсно
                            знадобляться на сторінці.</p>
                    </li>
                    <li>
                        <strong>Покращення Швидкодії:</strong>
                        <p>Зменшення часу очікування на завантаження ресурсів може суттєво покращити загальну швидкодію завантаження
                            сторінки.</p>
                    </li>
                    <li>
                        <strong>Оптимізація Використання Мережі:</strong>
                        <p>Завантаження ресурсів перед фактичним їхнім запитом дозволяє ефективніше використовувати мережу та зменшує
                            загальний час завантаження.</p>
                    </li>
                    <li>
                        <strong>Покращення Відчуття Швидкості:</strong>
                        <p>Коли ресурси готові без затримок, відчуття швидкості для користувача збільшується, оскільки сторінка відгукується
                            швидше.</p>
                    </li>
                </ol>
                <p>Попереднє завантаження домену можна виконати за допомогою HTML-атрибута rel і значення dns-prefetch. Додайте такий код до
                    ваших HTML-сторінок в розділ
                    < head>: < link rel="dns-prefetch" href="//example.com">
                </p>
                <p>В цьому прикладі href="//example.com" вказує на домен, з якого будуть завантажуватися ресурси. Ви можете додавати
                    кілька таких тегів < link> для різних доменів.</p>
                <p>Також важливо відзначити, що це дозволяє браузеру попередньо вирішити DNS-запити для вказаних доменів, що може зменшити
                    затримку при завантаженні ресурсів з цих доменів у майбутньому.</p>
                <p>Однак важливо враховувати, що неконтрольоване попереднє завантаження може займати додатковий мережевий трафік і споживати
                    ресурси. Тому використовуйте цю техніку обережно та розсудливо, оптимізуючи завантаження лише тих ресурсів, які дійсно
                    необхідні для покращення продуктивності сторінки.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Content Delivery Network (CDN) - що таке і як працює?
            </div>
            <div class="collapsible-body">
                <p>Мережа поставки контенту (Content Delivery Network, CDN) - це розподілена система серверів, розташованих у різних
                    географічних областях, з метою ефективного та швидкого доставлення веб-контенту користувачам. Основна мета CDN -
                    зменшити затримку завантаження ресурсів на веб-сторінці, покращити швидкість відгуку та зменшити навантаження на
                    сервери.</p>

                <p>Основні принципи роботи CDN включають наступні кроки:</p>

                <ol>
                    <li>
                        <strong>Розподілення Серверів:</strong>
                        <p>CDN використовує мережу серверів, розташованих у різних регіонах та країнах. Ці сервери називаються
                            "кеш-серверами" або "крайовими серверами".</p>
                    </li>
                    <li>
                        <strong>Запити до Найближчого Сервера:</strong>
                        <p>Коли користувач робить запит до ресурсу (наприклад, зображення чи стилізований файл), CDN автоматично визначає,
                            який крайовий сервер є найближчим до користувача.</p>
                    </li>
                    <li>
                        <strong>Кешування та Поставка:</strong>
                        <p>Якщо ресурс вже був запитаний раніше, CDN може мати його копію в кеші на крайовому сервері. Це дозволяє швидше
                            відправляти ресурс користувачеві без звертання до основного сервера. Якщо ресурс не знаходиться в кеші або
                            старий, CDN може запитати основний сервер.</p>
                    </li>
                    <li>
                        <strong>Динамічне Оновлення Кешу:</strong>
                        <p>CDN може автоматично оновлювати свій кеш, якщо ресурс на основному сервері змінився. Це гарантує, що користувачі
                            завжди отримують актуальні версії ресурсів.</p>
                    </li>
                    <li>
                        <strong>Навантаження Балансу:</strong>
                        <p>CDN дозволяє розподілити навантаження між різними серверами, зменшуючи тиск на основний сервер та покращуючи
                            масштабованість.</p>
                    </li>
                    <li>
                        <strong>Захист від Атак:</strong>
                        <p>Багато CDN включають інструменти безпеки, такі як захист від DDoS-атак або WAF (Web Application Firewall), що
                            поліпшує захист веб-сайту.</p>
                    </li>
                    <li>
                        <strong>Швидкість завантаження:</strong>
                        <p>Завдяки використанню близьких крайових серверів та оптимізації передачі даних, CDN допомагає покращити швидкість
                            завантаження контенту для користувачів з різних регіонів світу.</p>
                    </li>
                </ol>

                <p>Використання CDN дозволяє покращити продуктивність веб-сайту, забезпечуючи ефективне та швидке доставлення контенту для
                    користувачів незалежно від їхнього місця розташування.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                TCP/IP - що таке і для чого потрібно?
            </div>
            <div class="collapsible-body">
                <p>TCP/IP (Transmission Control Protocol/Internet Protocol) - це набір протоколів, які визначають та регулюють передачу
                    даних в комп'ютерних мережах, зокрема в Інтернеті. Ці протоколи встановлюють стандарти для обміну даними між
                    комп'ютерами і забезпечують надійність та ефективність цього обміну. Основні причини використання TCP/IP включають:</p>
                <ol>
                    <li>
                        <strong>Забезпечення З'єднання:</strong>
                        <p>TCP (Transmission Control Protocol) відповідає за створення та управління з'єднанням між двома пристроями. Воно
                            гарантує, що дані будуть надсилатися та прийматися в правильному порядку.</p>
                    </li>
                    <li>
                        <strong>Розподілення Даних на Пакети:</strong>
                        <p>TCP розбиває дані на пакети перед їх відправленням по мережі. Це полегшує ефективний обмін великими обсягами
                            даних.</p>
                    </li>
                    <li>
                        <strong>Надійність та Відновлення Помилок:</strong>
                        <p>TCP включає механізми перевірки доставки та відновлення помилок. Це дозволяє виявляти та виправляти помилки в
                            передачі даних.</p>
                    </li>
                    <li>
                        <strong>Маршрутизація та Ідентифікація:</strong>
                        <p>IP (Internet Protocol) відповідає за адресацію та маршрутизацію пакетів даних у мережі. Кожен пристрій в мережі
                            має свою унікальну IP-адресу для ідентифікації.</p>
                    </li>
                    <li>
                        <strong>Стандартизація:</strong>
                        <p>TCP/IP є стандартом для інтернет-протоколів, що дозволяє різним пристроям та платформам взаємодіяти між собою в
                            єдиному середовищі.</p>
                    </li>
                    <li>
                        <strong>Підтримка Різних Послуг:</strong>
                        <p>TCP/IP підтримує різні послуги, такі як електронна пошта (SMTP), передача файлів (FTP), веб-перегляд (HTTP) та
                            багато інших.</p>
                    </li>
                    <li>
                        <strong>Глобальна Взаємодія:</strong>
                        <p>TCP/IP є основним протокольним стеком для глобального Інтернету, забезпечуючи взаємодію різних мереж та пристроїв
                            у всьому світі.</p>
                    </li>
                </ol>
                <p>Узагальнено, TCP/IP є фундаментальним для забезпечення сполучення та обміну даними в мережах, зокрема для побудови та
                    функціонування Інтернету.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Авторизація vs аутентифікація
            </div>
            <div class="collapsible-body">
                <p>Аутентифікація та авторизація - це два різних аспекти управління доступом, і вони використовуються для різних цілей:</p>
                <ol>
                    <li>
                        <strong>Аутентифікація:</strong>
                        <ul>
                            <li>
                                <p>Визначення: Аутентифікація - це процес перевірки того, чи користувач є тим, за кого він видає себе.</p>
                            </li>
                            <li>
                                <p>Мета: Головною метою аутентифікації є перевірка ідентичності користувача.</p>
                            </li>
                            <li>
                                <p>Приклад: Введення логіну та пароля, використання біометричних даних, таких як відбитки пальців чи
                                    розпізнавання обличчя.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Авторизація</strong>
                        <ul>
                            <li>
                                <p>Визначення: Авторизація - це процес визначення, які ресурси або дії користувач має право виконувати в
                                    системі.</p>
                            </li>
                            <li>
                                <p>Мета: Головною метою авторизації є контроль доступу та призначення дозволів на використання ресурсів.</p>
                            </li>
                            <li>
                                <p>Приклад: Надання користувачеві прав доступу на читання, запис чи видалення файлів, визначення рівня
                                    доступу веб-сторінок, тощо.</p>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Щоб краще розуміти відмінності:</p>
                <ul>
                    <li>Сценарій: Аутентифікація визначає, "Чи ти той, за кого видаєш себе?", тоді як авторизація визначає, "Чи маєш ти
                        право це робити?".
                    </li>
                    <li>Порядок виконання: Зазвичай аутентифікація відбувається перед авторизацією. Спочатку користувач повинен підтвердити
                        свою ідентичність, і тільки потім визначається, які дії він може виконати.
                    </li>
                    <li>Приклад: Якщо уявити веб-сайт, аутентифікація - це процес введення логіну та пароля, щоб підтвердити, що ви той, за
                        кого ви видаєте себе. Після успішної аутентифікації визначається, які частини сайту (розділи, функції) ви можете
                        використовувати, що є частиною авторизації.
                    </li>
                </ul>
                <p>Узагальнюючи, аутентифікація та авторизація спільно використовуються для забезпечення безпеки та контролю доступу до
                    інформації та ресурсів в системах.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                З чого складається request і response до сервера?
            </div>
            <div class="collapsible-body">
                <strong>Request (запит до сервера):</strong>
                <ol>
                    <li>
                        <strong>Метод (Method):</strong>
                        <p>Вказує на тип запиту. Наприклад, GET, POST, PUT, DELETE.</p>
                    </li>
                    <li>
                        <strong>URL (Uniform Resource Locator): </strong>
                        <p> Адреса ресурсу, який користувач хоче отримати або модифікувати.</p>
                    </li>
                    <li>
                        <strong>Headers (Заголовки):</strong>
                        <p>Мета-інформація про запит, така як тип вмісту (Content-Type), довжина вмісту (Content-Length), використання кешу,
                            мова браузера та інші.</p>
                    </li>
                    <li>
                        <strong>Body (Тіло):</strong>
                        <p>Дані, які відправляються разом із запитом. Це може бути пустий рядок для GET-запитів або містити дані форми,
                            JSON-об'єкт, файл і т.д. для POST-запитів.</p>
                    </li>
                    <li>
                        <strong>Параметри URL (Query Parameters): </strong>
                        <p>Додаткові дані, які можуть передаватися через URL, зазвичай для GET-запитів. Наприклад,
                            ?key1=value1&key2=value2.</p>
                    </li>
                </ol>
                <strong>Response (відповідь від сервера):</strong>
                <ol>
                    <li>
                        <strong>Status Code (Код стану):</strong>
                        <p>Цифровий код, що вказує на результат обробки запиту. Наприклад, 200 (ОК), 404 (Не знайдено), 500 (Внутрішня
                            помилка сервера).</p>
                    </li>
                    <li>
                        <strong>Headers (Заголовки):</strong>
                        <p>Інформація від сервера, така як тип вмісту (Content-Type), розмір вмісту (Content-Length), дата відправки та
                            інші.</p>
                    </li>
                    <li>
                        <strong>Body (Тіло):</strong>
                        <p>Вміст відповіді, який може бути HTML-кодом, JSON-об'єктом, текстом, зображенням чи іншими дані, залежно від
                            природи запиту.</p>
                    </li>
                    <li>
                        <strong>Cookies (Куки):</strong>
                        <p>Інформація, яку сервер може відправити браузеру для збереження та використання при подальших запитах.</p>
                    </li>
                </ol>
                <p>Ці компоненти разом створюють обмін даними між клієнтом та сервером, де клієнт відправляє запит, а сервер повертає
                    відповідь.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <!--    <h5 id="js">JS</h5>-->
    <!--    <ul class="collapsible">-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">filter_drama</i>First</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">place</i>Second</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">whatshot</i>Third</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--    </ul>-->

    <h5 id="npm">NPM</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке NPM і для чого його
                використовувати?
            </div>
            <div class="collapsible-body">
                NPM (Node Package Manager) є системою управління пакетами для JavaScript, яка дозволяє розробникам легко
                встановлювати, оновлювати та використовувати залежності у своїх проектах. В основному, використовується
                для управління бібліотеками та іншими залежностями, які використовуються в проектах на базі Node.js.
                Декілька ключових причин для використання NPM:

                <ol>
                    <li><strong>Установка пакетів:</strong> NPM дозволяє легко встановлювати пакети (бібліотеки,
                        фреймворки, інструменти) для використання в проекті.
                    </li>
                    <li><strong>Управління версіями:</strong> NPM дозволяє вказувати версії пакетів, щоб гарантувати
                        сумісність та уникнути проблем залежностей.
                    </li>
                    <li><strong>Сценарії:</strong> Ви можете визначити різні сценарії (scripts) для автоматизації
                        завдань, таких як запуск сервера, збірка проекту чи тестування.
                    </li>
                    <li><strong>Пакетні файли та конфігурації:</strong> NPM дозволяє визначити пакетні файли та
                        конфігурації, які допомагають у встановленні та налаштуванні проекту.
                    </li>
                    <li><strong>Глобальні та локальні пакети:</strong> NPM дозволяє встановлювати пакети глобально для
                        доступу з будь-якого місця, або локально для конкретного проекту.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Глобальна та локальна установка
                пакетів за допомогою NPM
            </div>
            <div class="collapsible-body">
                Глобальна установка пакетів NPM означає, що пакет встановлюється на рівні системи та може бути
                використаний в будь-якому проекті. Це зазвичай використовується для інструментів командного рядка.
                Локальна установка, навпаки, встановлює пакет лише в межах поточного каталогу проекту. Це гарантує, що
                різні проекти не взаємодіють між собою через різні версії пакетів.
                Для глобальної установки використовується команда npm install -g, а для локальної - npm install.
                Наприклад, глобальна установка може бути корисною для інсталяції інструментів командного рядка, таких як
                create-react-app, які використовуються на рівні системи. Локальна установка, навпаки, дозволяє
                встановлювати бібліотеки, які використовуються тільки в межах конкретного проекту, такі як бібліотеки
                для розробки на React.js.
                Локальні пакети використовуються для забезпечення залежностей конкретного проекту. Це дозволяє уникнути
                конфліктів версій між різними проектами.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Файл Package.json, його функції</div>
            <div class="collapsible-body">

                <p>Package.json - це ключовий файл у проектах Node.js, який виступає як файл маніфесту. Він містить
                    метадані, що стосуються проекту, і включає в себе властивості, такі як ім'я, версія, опис, автор та
                    ліцензія.</p>

                <p>Також він перераховує залежності, необхідні для роботи додатка. Вони вказуються разом зі своїми
                    відповідними версіями у розділах "dependencies" чи "devDependencies". Перший містить пакети,
                    необхідні для продакшн, тоді як другий для розробки.</p>

                <p>Розділ "scripts" визначає скорочення команд, які можна виконати за допомогою npm. Наприклад, скрипт
                    "start" зазвичай запускає додаток.</p>

                <p>Додатково, файл може містити конфігураційні дані для інструментів, що використовуються у вашому
                    проекті у розділі "config", власні поля даних у "private" та вказати основну точку входу вашого
                    додатка у "main".</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як оновити пакет за допомогою NPM?
            </div>
            <div class="collapsible-body">
                Щоб оновити пакет за допомогою NPM, спочатку потрібно перевірити застарілі пакети. Використовуйте
                команду "npm outdated" у терміналі. Це виведе список всіх пакетів, для яких доступні нові версії. Щоб
                оновити конкретний пакет, використовуйте команду "npm update [ім'я-пакету]". Якщо ви хочете оновити всі
                пакети, просто використовуйте "npm update" без вказання імені пакету. Важливо враховувати, що це оновить
                лише мінорні та патч-релізи відповідно до правил семантичної версії. Для оновлення мажорних версій вам
                потрібно використовувати команду "npm install [ім'я-пакету]@latest". Завжди пам'ятайте перевіряти
                оновлення, переглядаючи файл package.json або використовуючи "npm outdated" знову.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як керувати версіями пакетів в NPM?
            </div>
            <div class="collapsible-body">NPM дозволяє управляти версіями пакетів за допомогою семантичного
                версіонування (semver). У вашому файлі package.json залежності перераховуються з їх версіями. Символ
                каретки (^) чи тильда (~) перед номером версії вказує на гнучкість у використанні новіших мінорних чи
                патч-версій відповідно. Щоб встановити конкретну версію, ви можете використовувати "npm install
                [пакет]@[версія]". Для оновлення до останньої мажорної версії команда "npm outdated" показує пакети, які
                потребують оновлення, і "npm update [пакет]" оновлює їх. Якщо декілька проектів вимагають різних версій,
                розгляньте використання nvm від npm чи Docker для ізольованих середовищ.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як використовується Семантичне
                версіонування у проекті?
            </div>
            <div class="collapsible-body">Семантичне версіонування, або SemVer, є системою версіонування для програмного
                забезпечення, яка має на меті передавати значення щодо основних змін у випуску. Вона використовує формат
                MAJOR.MINOR.PATCH, де кожне збільшення представляє різні типи модифікацій. Збільшення мажорної версії
                вказує на несумісні зміни у API, мінорної - на додання функціоналу сумісним способом, а патчу - на
                виправлення помилок, сумісних назад.

                У NPM семантичне версіонування використовується для управління залежностями. Під час встановлення
                пакетів ви можете вказати версію за допомогою нотації SemVer. Наприклад, "^1.0.0" встановить останню
                мінорну або патч-версію вище 1.0.0, але нижче 2.0.0. Це дозволяє розробникам контролювати версії їх
                залежностей, забезпечуючи сумісність та стабільність у їх проектах.>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як видалити пакет?</div>
            <div class="collapsible-body">

                Щоб видалити пакет за допомогою NPM, використовуйте команду "npm uninstall", за якою слідує ім'я пакету.
                Це видаляє його з каталогу node_modules та оновлює ваш файл package.json, відображаючи зміну. Якщо ви
                хочете видалити його глобально, додайте "-g". Щоб зберегти зміни в файлі package-lock.json, включіть
                "--save". Наприклад:
                <strong>npm uninstall < ім'я-пакету></strong><br/>. Це видаляє локально. Для глобального видалення:
                <strong>npm uninstall -g < ім'я-пакету></strong>. <br/>А для оновлення package-lock.json: <strong>npm
                uninstall --save < ім'я-пакету></strong>


            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Для чого використовуємо .npmignore
                файл?
            </div>
            <div class="collapsible-body">
                Файл .npmignore використовується у проектах Node.js для вказівки файлів чи каталогів, які не повинні
                бути включені до пакету, який надсилається до реєстру npm. Він функціонує подібно до файлу .gitignore,
                але спеціально для npm-пакетів. Якщо в каталозі не існує файлу .npmignore, npm використовує файл
                .gitignore замість нього. Однак у разі наявності обох файлів .npmignore має перевагу.

                Це дозволяє розробникам зберігати певні файли у своєму локальному репозиторії, не включаючи їх у
                опублікований пакет, такі як тести, README-файли чи інші необов'язкові файли.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Що як пакет, який використовується в
                проекті, застарів чи перестав підтримуватись?
            </div>
            <div class="collapsible-body">
                У ситуації, коли NPM-пакет, від якого залежить проект, є застарілим або більше не підтримується, я б
                спочатку оцінив вплив цього застаріння. Якщо це критично для проекту, я шукав би альтернативи. Зазвичай
                в обширному репозитарії NPM можна знайти схожі пакети.

                Якщо підходящу заміну знайти не вдається, і пакет є важливим, іншою опцією може бути створення форку
                оригінального пакету і його підтримка. Це передбачає розуміння кодової бази та виправлення будь-яких
                проблем чи вразливостей, що виникають. Однак це слід розглядати як останній захід через час та ресурси,
                які він вимагає.

                Ще одним підходом може бути повне вилучення залежності, якщо вона не приносить значущої користі. Це може
                потребувати рефакторингу деяких частин проекту, але може призвести до більш оптимізованої та ефективної
                кодової бази.

                Незалежно від обраного шляху важливо тщательно тестувати всі зміни, щоб вони не вводили нових помилок чи
                вразливостей у проект.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між npm та yarn</div>
            <div class="collapsible-body">
                NPM і Yarn - обидва менеджери пакетів для JavaScript, але вони відрізняються декількома способами. NPM
                автоматично встановлює пакет, коли ви його додаєте, тоді як Yarn додає пакет лише до списку, поки ви не
                виконаєте 'yarn install'. Це робить Yarn швидшим, оскільки уникнуто непотрібних встановлень. Крім того,
                Yarn вводить офлайн-режим, який кешує кожен завантажений пакет, дозволяючи встановлення без підключення
                до Інтернету. Також він перевіряє контрольні суми перед встановленням пакетів для забезпечення їх
                цілісності. Однак NPM має широку підтримку спільноти завдяки своєму тривалішому існуванню, що робить
                його більш надійним для старіших проектів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між “dependencies” and
                “devDependencies” in package.json?
            </div>
            <div class="collapsible-body">
                У файлі package.json "dependencies" та "devDependencies" мають різні цілі. "Dependencies" включають
                модулі, які необхідні для роботи вашого проекту в продакшн-середовищі. Вони встановлюються, коли ви або
                інший користувач виконує команду "npm install" без будь-яких аргументів.

                З іншого боку, "devDependencies" включають модулі, які потрібні лише під час розробки, а не в
                продакшн-середовищі. Сюди входять фреймворки для тестування, засоби збірки тощо. Вони встановлюються
                лише тоді, коли ви виконуєте "npm install" у своєму локальному середовищі розробки, а не коли
                користувачі встановлюють ваш пакет. Якщо ви використовуєте команду "npm install --production", це
                ігнорує devDependencies.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
            <div class="collapsible-body">
                Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він
                фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені
                залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл
                package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на
                будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію
                вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you handle security
                vulnerabilities in your NPM packages?
            </div>
            <div class="collapsible-body">
                Для роботи з вразливостями безпеки у пакетах NPM я використовую кілька стратегій. По-перше, я
                переконуюся, що всі мої пакети оновлені за допомогою команди 'npm update'. Це тому, що оновлення часто
                містять патчі для відомих вразливостей. По-друге, я використовую npm audit, вбудований інструмент, який
                сканує вразливості і надає детальні звіти. Він також пропонує виправлення, якщо такі є. Для
                автоматизованого сканування вразливостей я інтегрую інструменти, такі як Snyk чи Dependabot, у мій CI/CD
                конвеєр. Ці інструменти надають миттєві сповіщення про нові вразливості і автоматизують процес оновлення
                небезпечних залежностей. Нарешті, я дотримуюся кращих практик, таких як не запускання npm з правами root
                та уникання використання застарілих чи необслуговуваних пакетів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you manually change the version
                of a package using NPM?
            </div>
            <div class="collapsible-body">
                Щоб вручну змінити версію пакету за допомогою NPM, потрібно внести зміни у файл package.json. Цей файл
                містить метадані про ваш проект, включаючи залежності та їх версії. Для зміни версії пакету знайдіть
                його запис у розділі "dependencies" або "devDependencies" та відповідно змініть номер версії.

                Наприклад, якщо ви хочете змінити версію Express з 4.16.3 на 4.17.0, знайдіть рядок "express": "^4.16.3"
                і змініть його на "express": "^4.17.0".

                Після внесення змін у файл package.json виконайте команду `npm install` у вашому терміналі. Ця команда
                оновить ваш каталог node_modules на основі змін, внесених у файл package.json. Якщо виникнуть конфлікти
                між версіями, npm генерує повідомлення про помилку. Розберіть їх перед продовженням.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як вберегти певний файл від того, що
                його апдейтнуть?
            </div>
            <div class="collapsible-body">
                Щоб уникнути оновлення конкретних пакетів у NPM, ви можете скористатися командою "npm shrinkwrap". Це
                створить файл 'npm-shrinkwrap.json', який фіксує версії кожного пакету та його залежностей у вашому
                проекті. Коли цей файл присутній, команда 'npm install' встановлюватиме точні версії з
                'npm-shrinkwrap.json', ігноруючи будь-які новіші версії, вказані у 'package.json'. Замість цього ви
                також можете вказати точний номер версії пакету у файлі 'package.json'. Якщо ви видалите символи каретки
                (^) чи тильда (~) перед номером версії, npm буде використовувати саме вказану версію під час оновлень.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
            <div class="collapsible-body">
                Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він
                фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені
                залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл
                package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на
                будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію
                вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>В чому різниця команд npm і npx?
            </div>
            <div class="collapsible-body">
                npm та npx - це обидві інструменти, пов'язані з Node.js та управлінням пакетами, але вони мають різні
                призначення.
                npm (Node Package Manager):

                npm - це менеджер пакетів, який використовується для встановлення, оновлення та керування пакетами
                Node.js.
                Використовується для встановлення пакетів глобально або локально в вашому проекті.

                Приклад встановлення пакета глобально: npm install -g example-package
                Приклад встановлення пакетів локально в проекті: npm install package-name


                npx:

                npx - це інструмент, який дозволяє виконувати команди, які містяться в пакетах, не встановлюючи ці
                пакети глобально.
                Зазвичай використовується для виконання одноразових або експериментальних команд.
                Приклад використання npx для виконання команди з пакета, що не встановлено глобально: npx package-name
                command

                Отже, основна різниця полягає в тому, що npm використовується для встановлення та керування пакетами,
                тоді як npx дозволяє виконувати команди з пакетів, не встановлюючи їх глобально.
            </div>
        </li>


    </ul>


    <h5 id="git">GIT</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>Git Reset –soft, –mixed, and –hard
            </div>
            <div class="collapsible-body">
                <strong>git reset --soft < commit ></strong>

                Команда git reset відміняє зміни, зроблені в процесі. Дозволяє перемістити HEAD (поточну версію) до
                визначеного коміту.<br/>
                <strong>Git Reset --soft</strong> - переносить HEAD до вибраного комміту, але залишає стейдж незмінним.
                Це означає, що
                всі зміни після вказаного комміта будуть в стейджі, і ми зможемо їх закомітити знову.
                Виглядає це так: A -- B -- C (HEAD -> main), тоді команда <strong>git reset --soft B</strong> переносить
                нас у: A -- B (HEAD -> main), зміни, які ми зробили
                в коміті С - опиняться в стейджі. <br/>

                <strong>Git Reset --hard</strong> - потенційно найбільш небезпечна команда, оскільки переносить HEAD в
                обраний коміт, при цьому видаляє усі наступні.
                `git reset --hard B` - тепер перемістить нас в коміт B, при цьому вибаливши всі зміни з коміту С.
                Зазвичай використовується, щоб повнісю стерти зміни.

                <strong>Git Reset --mixed</strong> - дефолтна опція, переміщує HEAD до вказаного коміту, як в --soft.
                Якщо максимально просто - то `git reset --mixed B'
                команда перемістить нас на версію коміт В, але зміни з С будуть як untracked changes, а не в стейджі, як
                ми маємо це в --soft.

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>git cherry-pick</div>
            <div class="collapsible-body">

                Команда git cherry-pick в Git використовується для застосування конкретного зобов'язання (commit) з
                однієї гілки до іншої. Це дозволяє перенести вибрані
                зміни з одного коміту на інший, незалежно від того, на якій гілці вони були внесені.

                Синтаксис команди виглядає наступним чином: <strong>git cherry-pick < commit_hash ></strong><br/>
                Основні розділи використання git cherry-pick:
                <ol>
                    <li>Копіювання коміту на поточну гілку - git cherry-pick < commit_hash ></li>
                    <li>Копіювання кількох комітів - git cherry-pick < commit_hash1 > < commit_hash2 > ...</li>
                    <li>Автоматичне вирішення конфліктів - У разі, якщо виникнуть конфлікти при застосуванні коміту, Git
                        повідомить про це, і вам слід вирішити конфлікти вручну.
                    </li>
                </ol>
                !!! Ця команда корисна в ситуаціях, коли ви хочете <strong>перенести конкретні зміни з однієї гілки на
                іншу без копіювання всієї історії гілки</strong>. Важливо враховувати, що при
                використанні git cherry-pick важливо уникати переносу змін, які вже існують на цільовій гілці, оскільки
                це може призвести до конфліктів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>git fetch</div>
            <div class="collapsible-body">
                Команда git fetch використовується для завантаження змін іншого репозиторію, але не об'єднання їх з
                вашим робочим каталогом або поточною гілкою.
                Це оновлює інформацію про віддалені гілки та зобов'язання, але не змінює ваш робочий каталог.

                Синтаксис команди виглядає так: <strong>git fetch [remote_name]</strong>, де [remote_name] - це ім'я
                віддаленого репозиторію. Якщо ім'я віддаленого репозиторію не вказано, Git використовує за замовчуванням
                origin.

                Основні варіанти використання git fetch:
                <ol>
                    <li>Завантаження змін з віддаленого репозиторію: git fetch</li>
                    <li>Завантаження змін з конкретного віддаленого репозиторію: git fetch [remote_name]</li>
                </ol>
                Після використання git fetch, ви можете переглянути зміни, що були завантажені, і при необхідності
                об'єднати їх з вашим робочим каталогом за допомогою команди git merge або git rebase.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>
                Git merge vs git rebase vs git squash
            </div>
            <div class="collapsible-body">
                В git є 2 принципи переміщення змін з однієї бренчі в іншу - merge and the rebase. Обидві команди
                служать одній і ті ж меті. Проте є принципова різниця в тому, як вони працюють.
                <strong>Git merge</strong><br/>
                Git merge створює новий коміт об'єднання, git rebase переміщує або об'єднує зміни, змінюючи історію
                комітів.
                <p>Важливо використовувати <strong>git rebase</strong> лише для локальних гілок, оскільки вона може
                    переписати історію, що може створити конфлікти у віддалених гілках.</p>
                git rebase використовується для інтеграції змін з однієї гілки в іншу, переміщаючи або об'єднуючи
                коміти. Він допомагає підтримувати лінійну історію проекту, зробивши її більш чистою, ніж традиційне
                злиття. Зазвичай використовується для оновлення гілки функцій із змінами з основної гілки.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як створити та застосувати теги в Git і
                для чого вони використовуються?
            </div>
            <div class="collapsible-body">
                Теги в Git - це вказівники на конкретні коміти, які дозволяють легко ідентифікувати конкретні версії
                вашого коду. Вони корисні для позначення важливих точок в історії вашого проекту, таких як випуски
                програми або стабільні версії.

                Команда:
                git tag < ім'я тегу>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке .gitignore файл і як його
                налаштувати для виключення файлів та каталогів з репозиторію?
            </div>
            <div class="collapsible-body">Файл .gitignore використовується для вказівки Git на те, які файли та каталоги
                повинні бути ігноровані при відстеженні та коміту в репозиторій. Це особливо корисно, коли ви маєте
                файли або каталоги, які ви не хочете включати в контроль версій, наприклад, файли конфігурації, файли
                локальних налаштувань або кешовані файли.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як організувати безпеку Git-репозиторію?
                Як би ви відреагували на можливі загрози?
            </div>
            <div class="collapsible-body">
                <ul>
                    <li>Регулярно робіть резервні копії</li>
                    <li>Стежіть за безпековими оновленнями</li>
                    <li>Використовуйте правила доступу:
                        Налаштуйте правила доступу до репозиторію, визначаючи, хто і як може змінювати код.
                        Використовуйте рівні доступу (read, write, admin) залежно від ролей учасників.
                    </li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як ви вирішуєте конфлікти під час злиття
                гілок в Git і які інструменти Git ви використовуєте для цього?
            </div>
            <div class="collapsible-body">
                Злиття гілок в Git із конфліктами вимагає ручного вирішення. Для вирішення конфліктів:
                <ol>
                    <li>Після злиття гілок і виникнення конфліктів, Git вказує вам на ці файли та вказує конфліктуючі
                        ділянки коду,
                        які вам потрібно вирішити. Ви редагуєте ці файли, видаляючи мітки конфлікту та виправляючи код
                        так, як вам потрібно;
                    </li>
                    <li>Після вирішення конфліктів відзначте файли як вирішені за допомогою команди git add;</li>
                    <li>Продовжте злиття за допомогою git merge --continue.</li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Чим відрізняється git pull від git fetch?
            </div>
            <div class="collapsible-body">git pull завантажує зміни з віддаленого репозиторію та об'єднує їх у поточну
                гілку. git fetch лише завантажує зміни, але не автоматично їх об'єднує, залишаючи можливість перегляду
                та ручного об'єднання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як ви відміняєте коміт, який вже був
                відправлений в віддалений репозиторій?
            </div>
            <div class="collapsible-body">Відміна коміту включає створення нового коміту, який відміняє зміни. Щоб
                відмінити відправлений коміт, використовуйте <strong>git revert < ідентифікатор-коміту ></strong> і
                потім відправте новий коміт.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Розкажіть про різницю між Git та GitHub
                (або GitLab)
            </div>
            <div class="collapsible-body">Git - це система контролю версій, тоді як GitHub та GitLab - це платформи, що
                надають хостинг для Git-репозиторіїв і додаткові можливості співпраці, такі як відстеження проблем,
                pull-реквести та інше.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке Git hook і як він може бути
                корисним у розробці?
            </div>
            <div class="collapsible-body">Git hook - це скрипт, який автоматично запускається на певних етапах життєвого
                циклу Git. Його можна використовувати для завдань, таких як попередні перевірки перед комітом,
                лінтування чи автоматичного запуску тестування, поліпшуючи розробницький процес.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>git squash command</div>
            <div class="collapsible-body">
                git squash - це команда, яка дозволяє об'єднати кілька послідовних комітів в один. Це корисно, коли ви
                хочете зберегти лише один об'єднаний коміт замість кількох малих комітів.

                Основна ідея у тому, щоб зменшити кількість комітів у історії репозиторію, роблячи її більш зрозумілою
                та легкою для розуміння.

                Щоб скористатися командою git squash, ви можете використовувати інтерактивний режим перебазування. Ось
                приклад:

                <ol>
                    <li>Виберіть команду перебазування для останніх, наприклад, 3-х комітів: <strong>git rebase -i
                        HEAD~3</strong></li>
                    <li>З'явиться текстовий редактор із списком останніх 3 комітів. Замість слова pick для всіх комітів,
                        які ви хочете об'єднати, змініть його на squash або просто s для скорочення.
                        pick abc123 Some commit message <br/>
                        squash def456 Another commit message <br/>
                        squash xyz789 Yet another commit message
                    </li>
                    <li>Збережіть зміни і закрийте редактор. Відкриється новий редактор для об'єднання повідомлень
                        комітів. Залиште той, який вам потрібен, або об'єднайте їх в одне нове повідомлення.
                    </li>
                    <li>Збережіть зміни, закрийте редактор, і Git об'єднає обрані коміти в один, залишаючи новий коміт
                        зі зміненим повідомленням.
                    </li>
                </ol>
                Зауважте, що використання git squash може вплинути на історію комітів, тому важливо враховувати це при
                використанні в спільної роботи з іншими розробниками або при роботі з гілками, які вже були
                опубліковані.
            </div>
        </li>

    </ul>

    <h5 id="principles">Principles & Stuff</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>ООП</div>
            <div class="collapsible-body">
                Пропонуємо ознайомитися з основними принципами об'єктно-орієнтованого програмування – однієї з найбільш
                важливих методологій розробки, яка ґрунтується на уявленні про програму як про сукупність об'єктів,
                кожен з яких є екземпляром певного класу, а класи утворюють ієрархію наслідування.
                Об'єктно-орієнтоване програмування (ООП) включає в себе низку принципів, які допомагають створювати
                гнучкі, розширювані та підтримувані програми. Основні принципи ООП включають такі:
                <ol>
                    <li><strong>Інкапсуляція (Encapsulation)</strong>: Інкапсуляція вказує на об'єднання даних та
                        методів, які працюють з цими даними, в один об'єкт або клас. Змінні часто називаються "полями",
                        а методи - "методами". Забезпечує обмежений доступ до внутрішніх деталей об'єкта та захищає дані
                        від прямого доступу та неправильного використання.
                        Одним з визначальних факторів при проектуванні компонентів програми є приховування внутрішніх
                        даних компоненту і деталей його реалізації від інших компонентів програми та надання набору
                        методів для взаємодії з ним (API). Цей принцип є одним з чотирьох фундаментальних принципів ООП
                        і називається інкапсуляцією.
                        <br/>
                        <strong>Правильна інкапсуляція має велике значення з багатьох причин:</strong>
                        <ol>
                            <li>Вона сприяє повторному використанню компонентів: оскільки в цьому випадку компоненти
                                взаємодіють між собою лише через їх API і нечутливі до змін внутрішньої структури, вони
                                можуть використовуватись в більш широкому контексті.
                            </li>
                            <li>Інкапсуляція пришвидшує процес розробки: слабко пов'язані один з одним компоненти (тобто
                                компоненти, чий код якомога менше звертається або використовує код інших компонентів)
                                можуть розроблятися, тестуватися та доповнюватися незалежно.
                            </li>
                            <li>Правильно інкапсульовані компоненти більш зрозумілі та легше налагоджуються, що спрощує
                                підтримку програми.
                            </li>
                        </ol>
                        інкапсуляція реалізована за допомогою системи класів, які дозволяють зібрати інформацію про
                        об'єкт в одному місці; пакетів, які групують класи по певному критерію, і модифікаторів доступу,
                        якими можна позначити весь клас або його поле чи метод.

                        Всього існує чотири модифікатори доступу:
                        <ul>
                            <li><strong>public</strong> – повний доступ до сутності (полю або методу класу) з будь-якого
                                пакету;
                            </li>
                            <li><strong>protected</strong> – доступ до сутності лише для класів свого пакету і нащадків
                                класу;
                            </li>
                            <li><strong>private</strong> – доступ тільки всередині класу, в якому оголошена сутність;
                            </li>
                            <li><strong>неявний модифікатор за замовчуванням</strong> (за відсутності трьох явних) –
                                доступ до сутності лише для класів свого пакету.
                            </li>
                        </ul>
                        Для досягнення правильної інкапсуляції також необхідно надати коректний API для роботи з
                        компонентом. Наприклад, в сеттер для змінної можна включити логіку перевірки значень, які
                        передаються, або не надавати сеттери в класі взагалі, якщо клас повинен бути доступним лише для
                        читання.
                    </li>
                    <li><strong>Наслідування (Inheritance)</strong>: Спадкування дозволяє створювати новий клас на
                        основі існуючого, успадковуючи його властивості та методи. Новий клас називається "підкласом"
                        або "потомком", а клас, від якого успадковується, - "базовим класом" або "батьківським класом".
                        Дозволяє повторно використовувати код, створювати ієрархії та розширювати функціональність.
                        Наслідування є одним з найвагоміших принципів об'єктно-орієнтованого програмування, оскільки
                        воно дозволяє створювати ієрархічні структури об'єктів. Використовуючи наслідування можна
                        створити загальний клас, який буде визначати характеристики і поведінку, властиві певному набору
                        пов'язаних об'єктів. В подальшому цей клас може наслідуватися іншими, другорядними класами,
                        кожен з яких додаватиме унікальні, властиві лише йому характеристики і доповнюватиме або
                        змінюватиме поведінку базового класу.

                    </li>
                    <li><strong>Поліморфізм (Polymorphism)</strong>:
                        Поліморфізм вказує на можливість об'єктів реагувати на спільні методи, але робити це відповідно
                        до свого власного типу. Може бути реалізований через перевантаження методів та використання
                        інтерфейсів. Забезпечує заміну об'єктів їхніми схожими з точки зору використання, незалежно від
                        конкретного типу.
                        Розглядаючи поліморфізм необхідно пам'ятати, що цей принцип нерозривно пов'язаний з іншим
                        принципом ООП – наслідуванням, яке допомагає реалізувати поліморфізм. Візьмемо для прикладу
                        абстрактний клас «Автомобіль», який наслідують два конкретних класи – «Спортивний автомобіль» та
                        «Вантажний автомобіль».

                        І спортивні, і вантажні автомобілі володітимуть спільними характеристиками і матимуть можливість
                        виконувати загальні для всіх автомобілів дії, вказані в абстрактному батьківському класі, але
                        конкретна реалізація цих дій може бути різною.

                        Наприклад, загальна для всіх автомобілів дія «завестись» у спортивному автомобілі може бути
                        реалізована шляхом натискання кнопки, а у вантажного - за допомогою ключа. Один результат –
                        різні рішення. В цьому і полягає поліморфізм.

                        Більш точно, поліморфізм - один з принципів ООП, який дозволяє викликом перевизначеного методу
                        через змінну батьківського класу отримати поведінку, яка буде відповідати реальному похідному
                        класу, на який посилається ця змінна.
                    </li>
                    <li><strong>Абстракція (Abstraction)</strong>: (від лат. abstractio — виокремлення, відсторонення
                        або відділення) - Абстракція полягає в визначенні загального та необхідного набору властивостей
                        чи методів для класу, приховуючи деталі його реалізації. Спрощує складність, забезпечує
                        спрощення взаємодії та створення високорівневих концепцій.
                        В цьому і полягає абстракція: фокусування розробника на конкретних властивостях об'єкта залежить
                        від тих задач, які повинен вирішувати об'єкт. Наслідком такого підходу є те, що, якщо в
                        імперативних мовах програмісту необхідно думати в термінах комп'ютерної логіки, то в
                        об'єктно-орієнтованих мовах розробник думає в термінах проблемної сфери, в якій він розробляє
                        програму.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>Основні принципи та патерни
                проектування - SOLID
            </div>
            <div class="collapsible-body">
                <ul>
                    <li><strong>Single Responsibility Principle (Принцип єдиної відповідальності)</strong>: Кожен клас
                        повинен мати лише одну причину для зміни. Він повинен виконувати лише одну конкретну роботу.
                    </li>
                    <li>Open/Closed Principle (Принцип відкритості/закритості): Сутності (класи, модулі та ін.) повинні
                        бути відкритими для розширення, але закритими для модифікації. Додавання нового функціоналу
                        повинно бути можливим без зміни існуючого коду.
                    </li>
                    <li>Liskov Substitution Principle (Принцип підстановки Барбари Лісков): Об'єкти базового класу
                        повинні можливо без проблем підставлятися своїми похідними класами без зміни правильності
                        програми.
                    </li>
                    <li>Interface Segregation Principle (Принцип розділення інтерфейсу): Клієнти не повинні залежати від
                        інтерфейсів, які вони не використовують. Маленькі та специфічні інтерфейси краще, ніж великі
                        загальні.
                    </li>
                    <li>Dependency Inversion Principle (DIP) - це один із п'яти принципів SOLID. Він заявляє, що
                        високорівневі модулі не повинні залежати від низькорівневих модулів. Обидва типи модулів повинні
                        залежати від абстракцій, а не деталей.
                    </li>
                </ul>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Основні принципи та патерни проектування
                - KISS (Keep It Simple, Stupid)
            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVC Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>Концепція Модель-Вид-Контролер (MVC)</strong> є парадигмою архітектури програмного забезпечення, яка спрощує
                    розробку та підтримку додатків шляхом розділення їхніх відповідальностей на три основних компоненти.</p>
                <ol>
                    <li>
                        <strong>Модель (Model): </strong>
                        <p>Цей компонент відповідає за представлення та обробку даних додатку. Модель має уявлення про структуру та типи
                            даних, які використовуються в додатку, і відповідає за доступ до цих даних, виконання операцій над ними та
                            повідомлення про будь-які зміни. Це може бути база даних, файлова система або будь-яке інше сховище даних.</p>
                    </li>
                    <li>
                        <strong>Вид (View):</strong>
                        <p>Компонент Виду відповідає за відображення інформації користувачу та взаємодію з користувачем. Він приймає дані
                            від моделі та представляє їх у вигляді, зрозумілому користувачеві. Вид також реагує на введення користувача та
                            надсилає відповідні сигнали Контролеру.</p>
                    </li>
                    <li>
                        <strong>Контролер (Controller): </strong>
                        <p>Цей компонент обробляє введення від користувача та взаємодіє як з Видом, так і з Моделлю для реалізації потрібної
                            функціональності. Контролер взаємодіє з Видом для отримання введення та визначення, які дії слід виконати. Після
                            цього він здійснює відповідні дії з Моделлю для оновлення стану додатку.</p>
                    </li>
                </ol>
                <p>Однією з ключових переваг використання MVC є зменшення взаємозалежності між компонентами, що полегшує модифікацію та
                    розширення коду. Це також дозволяє різним командам або розробникам працювати над окремими компонентами, не впливаючи
                    одне на одне. Розділення відповідальностей робить програму більш читабельною та підтримуваною в майбутньому.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVVM Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>MVVM (Model-View-ViewModel)</strong> - це архітектурний патерн, який використовується для розробки програмних
                    додатків і особливо популярний в розробці веб-додатків та мобільних додатків. Цей патерн виник в межах платформи
                    Microsoft WPF (Windows Presentation Foundation) і став популярним завдяки введенню технології біндингу даних, яка
                    дозволяє легко зв'язувати дані моделі з представленням.</p>
                <p>Основні компоненти MVVM:</p>
                <ol>
                    <li>
                        <strong>Модель (Model):</strong>
                        <p>Модель представляє дані та логіку додатку. Це може бути об'єкт або набір об'єктів, які представляють дані, з
                            якими взаємодіє користувач та додаток.</p>
                    </li>
                    <li>
                        <strong>Вид (View): </strong>
                        <p>Вид відповідає за відображення інтерфейсу користувача (UI). Він отримує дані від ViewModel та відображає їх на
                            екрані.</p>
                    </li>
                    <li>
                        <strong>ViewModel: </strong>
                        <p>ViewModel виконує роль посередника між Моделлю та Видом. Він обробляє логіку, пов'язану з відображенням та
                            взаємодією з користувачем. ViewModel також забезпечує ізоляцію відповідальностей, забезпечуючи, що Модель та Вид
                            не взаємодіють безпосередньо один з одним.</p>
                    </li>
                </ol>
                <p>Основні концепції MVVM:</p>
                <ul>
                    <li>
                        <strong>Двосторонній біндінг (Two-way Data Binding):</strong>
                        <p>Це забезпечує автоматичну синхронізацію між ViewModel і Видом. Якщо дані змінюються в одному компоненті
                            (наприклад, в Виді), вони автоматично оновлюються в іншому (наприклад, у ViewModel) і навпаки.</p>
                    </li>
                    <li>
                        <strong>Команди (Commands):</strong>
                        <p>ViewModel може містити команди, які дозволяють взаємодіяти з користувачем або обробляти події.</p>
                    </li>
                    <li>
                        <strong>Інверсія управління (Inversion of Control): </strong>
                        <p>ViewModel може взаємодіяти з сервісами та іншими компонентами завдяки принципам інверсії управління, забезпечуючи
                            більшу гнучкість та тестованість.</p>
                    </li>
                    <li>
                        <strong>Тестування (Testing): </strong>
                        <p>Розділення логіки додатку між Моделлю і ViewModel полегшує тестування кожного компонента окремо.</p>
                    </li>
                </ul>
                <p>
                    MVVM дозволяє розділити відповідальності між різними компонентами, забезпечуючи більшу гнучкість, підтримку тестування
                    та ефективну розробку користувацьких інтерфейсів.
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVP Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>MVP (Model-View-Presenter)</strong> - це архітектурний патерн, який використовується для розробки програмного
                    забезпечення, особливо в інтерфейсах користувача. Цей патерн розширює базову концепцію Model-View-Controller (MVC) та
                    робить акцент на відокремленні бізнес-логіки від представлення даних та їх обробки.</p>
                <p>Основні компоненти MVP:</p>
                <ol>
                    <li>
                        <strong>Модель (Model):</strong>
                        <p>Модель відповідає за представлення даних та бізнес-логіки додатку. Це може бути об'єкт або група об'єктів, які
                            відображають стан та логіку додатку.</p>
                    </li>
                    <li>
                        <strong>Вид (View): </strong>
                        <p>Вид відповідає за відображення інтерфейсу користувача (UI). Він не має власної бізнес-логіки і взаємодії з
                            даними. Замість цього, він реагує на події та передає їх до Презентера для обробки.</p>
                    </li>
                    <li>
                        <strong>Презентер (Presenter): </strong>
                        <p>Презентер виступає як посередник між Моделлю та Видом. Він обробляє всю бізнес-логіку та логіку взаємодії з
                            даними. Презентер отримує дані від Моделі, обробляє їх та оновлює Вид.</p>
                    </li>
                </ol>
                <p>Основні концепції MVP:</p>
                <ul>
                    <li>
                        <strong>Відокремлення відповідальностей: </strong>
                        <p>MVP відокремлює бізнес-логіку від інтерфейсу користувача, роблячи код більш чистим та підтримуваним.</p>
                    </li>
                    <li>
                        <strong>Тестування: </strong>
                        <p>Розділення логіки між Моделлю, Видом та Презентером полегшує тестування кожного компонента окремо. Презентер може
                            тестуватися без інтерфейсу, що спрощує процес.</p>
                    </li>
                    <li>
                        <strong>Гнучкість та розширюваність: </strong>
                        <p>Оскільки кожен компонент виконує конкретну функцію, система стає більш гнучкою та легко розширюваною.</p>
                    </li>
                </ul>
                <p>
                    Основна ідея MVP - надавати чіткий розділ відповідальностей між компонентами, що полегшує розробку та тестування
                    програмного забезпечення. Проте, важливо враховувати, що реалізація MVP може відрізнятися в різних платформах та
                    технологіях.
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVI Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>MVI (Model-View-Intent)</strong> - це архітектурний патерн, який широко використовується в розробці програмного
                    забезпечення, особливо в мобільних додатках. Цей патерн є еволюцією ідей, що виникали з архітектурних патернів, таких як
                    MVP (Model-View-Presenter) та MVVM (Model-View-ViewModel).</p>
                <p>Основні компоненти MVI:</p>
                <ol>
                    <li>
                        <strong>Модель (Model):</strong>
                        <p>Модель відповідає за представлення даних та бізнес-логіки додатку. Це може бути клас або група класів, що
                            відображають стан та операції, які можна виконати над даними.</p>
                    </li>
                    <li>
                        <strong>Вид (View): </strong>
                        <p>Вид відповідає за відображення інтерфейсу користувача (UI). У випадку MVI, він також відповідає за відображення
                            стану додатку.</p>
                    </li>
                    <li>
                        <strong>Інтент (Intent): </strong>
                        <p>Інтент представляє користувацьке намірення або дію, яку користувач хоче виконати. Він передається від Виду до
                            Процесора (Processor).</p>
                    </li>
                    <li>
                        <strong>Процесор (Processor): </strong>
                        <p>Процесор обробляє інтент, взаємодіє з Моделлю та визначає новий стан додатку. Це може включати в себе виклик
                            методів Моделі, перевірку умов та взаємодію з різними джерелами даних.</p>
                    </li>
                </ol>
                <p>Основні концепції MVI:</p>
                <ul>
                    <li>
                        <strong>Неімутабельність (Immutability): </strong>
                        <p>Стан додатку та об'єкти повинні бути неімутабельними, що означає, що їхні значення не можна змінювати після
                            створення.</p>
                    </li>
                    <li>
                        <strong>Однозначність стану (State Unidirectionality):</strong>
                        <p>Дані та стан додатку повинні рухатися в одному напрямку, що полегшує відслідковуваність та розуміння стану.</p>
                    </li>
                    <li>
                        <strong>Реактивність (Reactivity): </strong>
                        <p>MVI сприяє реактивному підходу, де зміни в додатку відбуваються відповідно до подій та змін стану.</p>
                    </li>
                    <li>
                        <strong>Тестовість (Testability): </strong>
                        <p>Патерн робить код більш тестовим, оскільки стан та логіка відокремлені, а обробка інтентів відбувається
                            визначеною логікою Процесора.</p>
                    </li>
                </ul>
                <p>
                    MVI дозволяє створювати додатки, які є більш декларативними та зменшують побічні ефекти. Він особливо популярний в
                    сучасному розвитку мобільних додатків, де реактивні та функціональні підходи стають стандартом.
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Підходи mvc vs mvp vs mvvm vs mvi - в яких випадках краще використовувати?
            </div>
            <div class="collapsible-body">
                <p>
                    Вибір між архітектурними патернами, такими як MVC, MVP, MVVM чи MVI, може залежати від конкретних вимог та контексту
                    вашого проекту. Ось загальні рекомендації:</p>
                <ol>
                    <li>
                        <strong>MVC (Model-View-Controller):</strong>
                        <ul>
                            <li>Використовуйте, якщо ваша система має простий та невеликий інтерфейс.</li>
                            <li>Підходить для традиційних веб-застосунків.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>MVP (Model-View-Presenter):</strong>
                        <ul>
                            <li>Корисно, коли важлива тестованість і розширюваність коду.</li>
                            <li>Підходить для великих та складних проектів, де важлива чистота коду та його тестування.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>MVVM (Model-View-ViewModel):</strong>
                        <ul>
                            <li>Використовуйте, якщо вам важлива розділеність логіки інтерфейсу користувача від бізнес-логіки.</li>
                            <li>Ідеально підходить для розробки застосунків з великою кількістю динамічного вмісту та даних.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>MVI (Model-View-Intent):</strong>
                        <ul>
                            <li>Корисно, коли пріоритети - це однозначність та сталість стану.</li>
                            <li>Добре підходить для застосунків, де стан дуже важливий, і важлива реакція на введення користувача.</li>
                            <li><strong>Додатки з великим обсягом даних:</strong> MVI може бути корисним для розробки додатків, які
                                взаємодіють з великим
                                обсягом даних, оскільки він дозволяє ефективно керувати потоком даних та оновленнями.
                            </li>
                            <li><strong>Додатки зі складною логікою інтерфейсу: </strong> Для додатків, де інтерфейс користувача має складну
                                логіку та залежить від багатьох факторів, MVI може допомогти структурувати та робити код більш придатним для
                                тестування.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Важливо також враховувати досвід команди розробників, їхні вподобання та специфіку проекту. У деяких випадках
                    комбінування різних патернів може бути найбільш ефективним рішенням.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Порівнюємо способи генерації сторінок: CSR, SSR, SSG, ISR.
            </div>
            <div class="collapsible-body">
                <p>В древні часи, не було ніяких Реактів чи Ангулярів і всі сайти були «багатосторінкові» додатки. Ми відкривали адресу
                    сайту в браузері, йшов запит на сервер, де якийсь умовний PHP генерував нам цілу сторінку (весь HTML, CSS та трішки
                    JS) і повертав клієнту. Коли ми натискали на посилання на іншу сторінку, знову слали такий же запит, сервер генерував
                    нову сторінку і повертав її. Браузер видаляв стару та рендерив нову, при цьому відбувався такий собі «блік» при
                    переходах між сторінками. Даний підхід називається Multi page application (MPA).</p>
                <p>З точки зору SEO — це ідеальний підхід. Ми маємо повну сторінку з усією необхідною інформацією і будь-який пошуковий бот
                    відразу її зчитував, наші сайти в топі пошукової видачі, клієнти (власники цих сайтів) — щасливі.</p>
                <p>З точки зору користувачів сайтів — не все так ідеально. При відкритті кожної наступної сторінки ми чекаємо, доки
                    завантажаться всі ресурси заново та відрендериться сторінка. Звісно, більшість ресурсів уже закешовані, але все одно
                    очікуємо повного відмалювання сторінки. Ну, і бліки при переходах ніхто не скасовував.</p>
                <p>Революцією в цьому підході стала поява фреймворків, які дозволяли реалізовувати так звані односторінкові сайти — Single
                    Page Application (SPA). Суть в тому, що ми один раз завантажуємо CSS, JS та практично порожню HTML-сторінку, і потім JS
                    уже будує все в клієнтському браузері. При переході між сторінками JS перебудовує лише ту частину, яка змінилась, і при
                    цьому, за потреби, робить AJAX запит на сервер, щоб отримати необхідні дані. Ми позбулися бліків!</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Клієнтська генерація сторінок — Client-Side Rendering (CSR)
            </div>
            <div class="collapsible-body">
                <p>Підхід доволі простий, особливо в наші дні. Створений додаток складається з кількох файлів: файл стилів, скрипти та
                    умовно порожня HTML-сторінка, в якій підключаються стилі та скрипти. У файлі index.html з тегів є лише один div з
                    id="root«, де і будується вся сторінка. При переході між сторінками змінюється URL-адреса в браузері та підтягуються
                    дані з сервера, за потреби. Реалізація проста, на сервер навантаження мінімальні, адже не потрібно рендерити сторінку на
                    кожен запит, а лише повернути статичні файли. Якщо потрібні дані, можна створити окремий RESTful сервер, який
                    повертатиме дані в JSON форматі.</p>
                <p>Як бонус — легкість масштабування, і дані можуть використовуватися різними клієнтами (вебсторінки, мобільні додатки, інші
                    сервера). До того ж можна зекономити на хостингу. Вам не потрібно багато ресурсів, щоб повернути декілька файлів.</p>
                <p>Звісно, в даному підході страждає SEO. Додатково можуть виникнути проблеми при спробі поділитися такими сторінками в
                    соціальних мережах, адже їм також потрібно завантажити сторінку, відрендерити її та знайти потрібні дані. Ну, і не
                    забуваємо про користувачів, якщо в них старі слабенькі телефони, то рендеринг сторінки займе цілу вічність.</p>
                <br>
                <strong>Переваги</strong>
                <ul>
                    <li>легкість реалізації</li>
                    <li>менше навантаження на сервер</li>
                    <li>актуальність інформації</li>
                    <li>можна обійтися без сервера</li>
                    <li>легкість масштабування</li>
                    <li>дешевший хостинг</li>
                </ul>
                <strong>Недоліки</strong>
                <ul>
                    <li>страждає SEO</li>
                    <li>social media crawlers та проблеми з share</li>
                    <li>більше навантаження на пристрої клієнтів</li>
                    <li>розмір js файлу при першому завантаженні</li>
                </ul>
                <p><strong>Інструменти: </strong>react-create-app, React і конфігурація вручну.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Серверна генерація сторінок — Server-Side Rendering (SSR)
            </div>
            <div class="collapsible-body">
                <p>Головна особливість цього підходу в тому, що вся сторінка рендериться на сервері при першому запиті, а потім уже в
                    браузері ініціалізується React, і далі додаток працює як звичайний SPA, виконуючи, за потреби, AJAX-запити на сервер.
                    Дані завантажуються завжди актуальні, адже при кожному перезавантаженні сторінки відбувається запит на сервер. З точки
                    зору SEO все також ідеально: повертається повноцінна сторінка. Користувачі також задоволені — працюють зі звичайним SPA,
                    різниці вони не бачать.</p>
                <p>Хоч і виникає потреба в підтримці потужного сервера, який буде обробляти усі запити, тут є і перевага. Можна налаштувати
                    кешування для найпопулярніших запитів, що прискорить завантаження та відображення сторінки.</p>
                <strong>Переваги:</strong>
                <ul>
                    <li>ідеальна реалізація SEO;</li>
                    <li>актуальність інформації;</li>
                    <li>швидкість завантаження та відображення контенту (Time to Interactive);</li>
                    <li>налаштування кеша на сервері.</li>
                </ul>
                <strong>Недоліки:</strong>
                <ul>
                    <li>складність реалізації</li>
                    <li>навантаження на сервер;</li>
                    <li>збільшення розміру файлів що завантажуються з сервера;</li>
                    <li>довша відповідь від сервера (TTFB — Time to first byte).</li>
                </ul>
                <p><strong>Інструменти: </strong>NodeJS; NextJS.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Статична генерація сайтів — Static Site Generation (SSG)
            </div>
            <div class="collapsible-body">
                <p>Чи потрібно нам кожен раз на сервері генерувати цілу сторінку, якщо дані не так часто оновлюються? Для різних лендінгів,
                    сайтів-візиток, блогів, простих інтернет-магазинів, де інформація оновлюється дуже рідко, підтримка серверного
                    рендерингу може бути накладною та надлишковою.</p>
                <p>Тут на сцену виходить SSG. Навіщо виконувати генерацію на кожен запит, якщо можна один раз при побудові додатку
                    згенерувати усі сторінки. Просто складаємо в папку всі HTML (CSS та JS) файли, розміщуємо їх на простенькому файловому
                    сервері чи взагалі в CDN і повертаємо при кожному запиті. Повна відсутність сервера для обробки запитів чи генерування
                    сторінок. Отримуємо максимальну швидкість завантаження та безпеку. Безпечний сервер — той сервер, якого нема.</p>
                <p>З точки зору SEO — це ідеальний варіант. Для користувача сторінка відображається ще швидше ніж при SSR, ми не очікуємо
                    дані на сервері, тому TTFB менший. Для користувачів все залишається незмінним, адже після завантаження сторінки там
                    знову ініціалізуються React і додаток працює, як звичайний SPA.</p>
                <p>Недоліком даного підходу являється те, що при оновленні даних потрібно повністю перезібрати проєкт і відрендерити всі
                    сторінки. Я б не назвав це недоліком, все так, це більше особливість. Якщо сайт містить близько 100 000 сторінок, то
                    генерація може зайняти декілька годин. На це потрібно звернути увагу.</p>
                <p>
                    Також може виникнути питання: а як щодо взаємодії користувача з сайтом? Що робити, якщо потрібно відправити якусь форму
                    або зібрати інформацію? Ніхто не забороняє запустити окремий RESTful сервер, який відповідатиме за обробку різноманітних
                    запитів від клієнтів. Також можна звернути увагу на Serverless або «хмарні функції», рекомендую глянути на AWS Lambda
                    або GCP Cloud functions.
                </p>
                <strong>Переваги:</strong>
                <ul>
                    <li>ідеальна реалізація SEO;</li>
                    <li>швидкість завантаження та відображення;</li>
                    <li>надійність та безпека (нема сервера);</li>
                    <li>дешевий хостинг.</li>
                </ul>
                <strong>Недоліки:</strong>
                <ul>
                    <li>при оновленні контенту потрібно перезбирати проєкт;</li>
                    <li>час на генерацію великої кількості сторінок, наприклад для 100 000 продуктів.</li>
                </ul>
                <p><strong>Інструменти: </strong>GatsbyJS; NextJS.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Інкрементальна регенерація статичних сторінок — Incremental Static Regeneration (ISR)
            </div>
            <div class="collapsible-body">
                <p>Даний метод поєднує переваги двох попередніх. Не завжди потрібно генерувати сторінку при кожному запиті, та й заздалегідь
                    нагенеровані сторінки не є рішенням, якщо контент час від часу оновлюється.</p>
                <p>Рішенням буде розділення сторінок. Ті, що частіше оновлюються, будуть рендеритися за допомогою SSR, ті, що рідко
                    оновлюються, будуть згенеровані за допомогою SSG.</p>
                <strong>Переваги:</strong>
                <ul>
                    <li>ідеальна реалізація SEO;</li>
                    <li>швидкість завантаження та відображення;</li>
                    <li>можна застосовувати для деяких сторінок;</li>
                    <li>відносна актуальність інформації.</li>
                </ul>
                <strong>Недоліки:</strong>
                <ul>
                    <li>складність реалізації;</li>
                    <li>необхідний сервер.</li>
                </ul>
                <p><strong>Інструменти: </strong>NextJS.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Різниця між бібліотекою і фреймворком
            </div>
            <div class="collapsible-body">
                <p><strong>Бібліотека</strong> - це збірка наперед написаного коду, який може бути використаний повторно для виконання
                    конкретних
                    завдань,
                    таких як створення інтерфейсів користувача чи обробка мережевих запитів. Зазвичай бібліотека надає набір функцій чи
                    класів, які можуть бути викликані розробником у його коді для виконання певного завдання. Бібліотеки призначені бути
                    гнучкими і можуть використовуватися в різноманітних застосуваннях.</p>
                <p>З іншого боку, фреймворк - це більш комплексний набір інструментів і конвенцій, який надає структуру для будівництва
                    цілого додатку. Фреймворк зазвичай включає набір бібліотек і інструментів, а також набір правил і найкращих практик, які
                    керують процесом розробки. Фреймворки надають більш предкриптивний підхід до розробки додатків, і розробники часто
                    повинні дотримуватися вказівок фреймворку, щоб забезпечити коректне інтегрування їх коду з іншою частиною додатку.</p>
                <p>У порівнянні бібліотек та фреймворків в питаннях на співбесіді для старшого фронтенд-розробника, можна зазначити, що,
                    хоча обидва надають написаний код для будівництва додатків, основна різниця полягає в їхньому обсязі та рівні
                    абстракції. Бібліотеки є більш гнучкими і можуть бути використані для різних завдань, тоді як фреймворки надають більш
                    комплексний набір інструментів і конвенцій для будівництва цілих додатків.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                CI vs CD vs CD: різниця підходів і чому вони важливі
            </div>
            <div class="collapsible-body">
                <p>Continuous Integration, Delivery та Deployment — процеси, що дозволяють полегшити впровадження змін у застосунку для
                    їхнього швидкого розгортання у середовище (prod, staging, dev та інші). Частіше всього, це реалізується за допомогою
                    створення пайплайнів, що автоматизують певні повторювані дії.</p>
                <p>[Continuous Integration: - Build - Test - Merge]</p>
                <p>[Continuous Delivery - Automated Release]</p>
                <p>[Continuous Deployment: - Automated Deployment]</p>

                <strong>Continuous Integration</strong><br>
                <p>Continuous Integration — це процес об’єднання змін у коді від декількох розробників в один спільний проєкт, що має
                    виконуватись якомога частіше. Загалом цю задачу покладають на систему контролю версій. А чому це необхідно?</p>
                <p>Зараз більшість репозиторіїв налаштовано так, що під час внесення будь-яких змін у систему контролю версій ми запускаємо
                    ланцюжок процесів, що мають перевірити базову працездатність коду — тестування, правила форматування, компіляція
                    останньої версії коду для перевірки, а чи нема в нових змінах помилок, що «завалять» потенційний білд.</p>
                <p>Тож усі ці процеси направлені на те, щоб раніше виявляти потенційні баги, покращувати якість кінцевого продукту та
                    скоротити час верифікації та релізу нового функціоналу. І хоча неможливо уникнути виникнення багів, Continuous
                    Integration може допомогти шляхом їх виявлення та усунення. Це головна причина, чому сьогодні бізнес відходить від
                    застарілих підходів до СІ.</p>
                <p>Якщо на якійсь із цих стадій була виявлена помилка, результат цього пайплайну відображався на сторінці пул реквесту та не
                    дозволяв мерджити гілки. Тож помилка мала бути виправлена, і вже новий успішний пайплайн вважався одним з обов’язкових
                    пунктів для закриття пул реквесту. Так, ми отримали функціонал — протестований і перевірений, — для того, щоб передати
                    його наступній фазі.</p>

                <strong>Continuous Delivery та Deployment</strong><br>
                <p>Continuous Delivery - По суті, це автоматизоване впровадження останньої версії продукту в Production та інші середовища.
                    Але до цього код має пройти автоматизовані Unit-, Integration- та System-тестування, що проводяться на стадії
                    інтеграції.</p>
                <p>Тобто поєднуючи два процеси, наведені вище, ми можемо отримати протестований функціонал одразу розгорнутим у середовищі
                    за допомогою пайплайну в один клік. Звичайно ж, рішення про розгортання нового релізу має ухвалюватися людиною, але
                    підготовкою займається система.</p>
                <p>Розглянемо інший процес, який називається Continuous Deployment. Це наступний крок у розгортанні змін на середовищі. По
                    своїй суті, continuous deployment — це практика у розробці, коли будь-які зміни якнайшвидше потрапляють у
                    production-середовище.</p>
                <p>На меті цей процес ставить лише одне: релізити зміни, які роблять розробники, якомога частіше й швидше доставляти їх
                    кінцевим користувачам. Тобто коли випускається новий реліз, пайплайн підхоплює його, верифікує, чи всі перевірки
                    виконані, та створює білд, який буде розгорнутий одразу на Production.</p>


                <p><strong>У чому ж різниця між Continuous Delivery та Deployment?</strong></p>
                <p>Якщо коротко, то Continuous Delivery спрямований на підтримку коду в стані, коли він завжди готовий піти в реліз та бути
                    розгорнутим у Production, але лише за вказівкою людини, що контролює цей процес.</p>
                <p>На противагу цьому Continuous Deployment скорочує цей процес, та за першої ж можливості, коли тест-плани успішні,
                    розгортає зміни в середовищі.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Як працює стиснення Gzip ?
            </div>
            <div class="collapsible-body">
                Стиснення Gzip - це метод зменшення розміру файлів, що передаються через мережу, шляхом використання алгоритму стиснення
                Gzip.
                <ol>
                    <li>
                        <strong>Алгоритм стиснення:</strong>
                        <p>Gzip використовує алгоритм стиснення DEFLATE для зменшення обсягу текстових файлів. Цей алгоритм використовує
                            кодування LZ77 (алгоритм стиснення з використанням скользячого вікна) та кодування довжин і відстаней.</p>
                    </li>
                    <li>
                        <strong>Виявлення повторень:</strong>
                        <p>Під час стиснення Gzip алгоритм виявляє повторення в тексті і замінює їх коротшими символьними представленнями.
                            Це дозволяє ефективно зменшити розмір файлу.</p>
                    </li>
                    <li>
                        <strong>Блокова стискальна структура:</strong>
                        <p>Закодовані дані розділяються на блоки, кожен з яких стискається незалежно. Це забезпечує ефективність стиснення
                            для різних частин файлу.</p>
                    </li>
                    <li>
                        <strong>Заголовки та мета-інформація:</strong>
                        <p>Кожен стиснутий файл має спеціальний заголовок, що вказує на те, що це стиснутий файл Gzip. Це дозволяє браузерам
                            та серверам розпізнавати такі файли та правильно їх розпаковувати.</p>
                    </li>
                    <li>
                        <strong>Розпакування на боці отримувача:</strong>
                        <p>Коли стиснутий файл досягає веб-браузера або іншого клієнта, він розпаковується перед відображенням або
                            використанням. Цей процес відбувається автоматично, і користувач не бачить розпакованого вмісту.</p>
                    </li>
                </ol>

                <p>Давайте розглянемо приклад стиснення Gzip на основі простого текстового рядка. Припустимо, у нас є наступний текст:</p>
                <p><strong>This is a simple example of Gzip compression.</strong></p>
                <p>Тепер розглянемо, як цей текст може бути стиснений за допомогою алгоритму стиснення DEFLATE, який використовується в
                    Gzip.</p>
                <ol>
                    <li>
                        <strong>Виявлення повторень:</strong>
                        <p>Алгоритм виявляє повторення в тексті. У нашому випадку, наприклад, фраза "is" повторюється.</p>
                    </li>
                    <li>
                        <strong>Заміна повторень:</strong>
                        <p>Повторення замінюються коротшими символьними представленнями. Нехай "is" буде замінено якимось унікальним кодом,
                            скажімо, #1#.</p>
                    </li>
                    <li>
                        <strong>Стискальна структура:</strong>
                        <p>Текст розбивається на блоки, і кожен блок стискається незалежно від інших.</p>
                    </li>
                </ol>
                <p>Отже, після стиснення наш текст може виглядати, наприклад, так:</p>
                <p><strong>Th#1# a simple example of Gz#1#p compr#1#ssion.</strong></p>

                <p>Стиснення Gzip дозволяє значно зменшити розмір файлів, що передаються по мережі, зменшуючи час завантаження сторінок та
                    поліпшуючи продуктивність веб-сайтів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>


    </ul>

</div>
<script src="script.js"></script>
</body>
</html>