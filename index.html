<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" href="src/icons/xmas.ico" type="image/x-icon">
    <link rel="shortcut icon" href="src/icons/xmas.ico" type="image/x-icon">

    <!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>Technical Interview</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
            integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <nav>
        <div class="nav-wrapper">
            <a href="#" data-target="mobile-demo" class="sidenav-trigger"><i class="material-icons">menu</i></a>
            <ul class="right hide-on-med-and-down">
                <li><a href="#js">JS</a></li>
                <li><a href="#js">HTML</a></li>
            </ul>
        </div>
    </nav>

    <ul class="sidenav" id="mobile-demo">
        <li>
            <a href="#js">JS</a>
        </li>
        <li>
            <a href="#html">HTML</a>
        </li>
    </ul>
</header>
<div class="container">

    <h5 id="js">JS</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке "Tree shaking"?
            </div>
            <div class="collapsible-body">
                <p>Tree shaking - це термін, який часто використовується в контексті JavaScript для опису видалення "мертвого" коду.
                    Кандидатам на співбесіді слід розуміти, як це працює і які переваги це має.</p>

                <p>Tree shaking - це метод оптимізації нашого JavaScript-пакета, виключаючи невикористовувані експорти в нашому проекті, тим
                    самим зменшуючи розмір кінцевого пакета. У системі збірки модулів, такій як Webpack чи Rollup, вона статично аналізує
                    всі імпорт та експорт в нашому вихідному коді та видаляє невикористаний код при створенні пакета.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="html">HTML</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Що таке DOCTYPE і навіщо його
                використовують?
            </div>
            <div class="collapsible-body">
                DOCTYPE (Document Type Definition) - це інструкція, яку використовують у HTML-документах для визначення
                типу документа та версії HTML або XHTML, якою він відповідає. Вона розміщується на самому початку
                HTML-коду, перед будь-якими тегами html, head, чи body.
                < !DOCTYPE html > < html lang="uk" > < head > < body > < /html ><br>
                Основна роль DOCTYPE:
                <ol>
                    <li>
                        Визначення режиму рендерингу:

                        Деякі браузери мають різні режими рендерингу для старих версій HTML. DOCTYPE допомагає браузерам
                        вибрати правильний режим рендерингу для забезпечення сумісності із стандартами.

                    </li>
                    <li>
                        Забезпечення сумісності:

                        Декларація DOCTYPE допомагає визначити версію HTML або XHTML, що використовується в документі.
                        Це важливо для того, щоб браузери могли коректно відображати сторінку відповідно до відповідних
                        стандартів.
                    </li>
                    <li>
                        Уникнення квірксів:

                        Зазначення DOCTYPE допомагає уникнути квірксів (різних режимів рендерингу), які можуть виникати
                        при відображенні сторінки в різних браузерах.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які основні теги структури HTML-сторінки?
            </div>
            <div class="collapsible-body">
                <ol>
                    <li><p><code>&lt;!DOCTYPE html&gt;</code>: Визначає тип документа та версію HTML.</p></li>
                    <li><p><code>&lt;html&gt;</code>: Визначає початок та кінець HTML-документа.</p></li>
                    <li><p><code>&lt;head&gt;</code>: Містить мета-інформацію про документ, таку як заголовок,
                        мета-теги, посилання на зовнішні ресурси (стилі, скрипти).</p></li>
                    <li><p><code>&lt;title&gt;</code>: Визначає заголовок сторінки, який відображається в заголовку
                        вкладки браузера або на панелі завдань.</p></li>
                    <li><p><code>&lt;meta charset="UTF-8"&gt;</code>: Вказує кодування символів для сторінки, зазвичай
                        встановлюється на UTF-8.</p></li>
                    <li><p><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>:
                        Встановлює мета-тег для налаштування ширини екрану та масштабування на мобільних пристроях.</p>
                    </li>
                    <li><p><code>&lt;body&gt;</code>: Містить основний вміст сторінки, такий як текст, зображення,
                        таблиці, форми та інші елементи.</p></li>
                    <li><p><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code>: Визначають заголовки різних рівнів.
                        <code>&lt;h1&gt;</code> - найважливіший, <code>&lt;h6&gt;</code> - найменший.</p></li>
                    <li><p><code>&lt;p&gt;</code>: Визначає абзац тексту.</p></li>
                    <li><p><code>&lt;a&gt;</code>: Створює посилання на іншу сторінку або ресурс.</p></li>
                    <li><p><code>&lt;img&gt;</code>: Вставляє зображення на сторінку.</p></li>
                    <li><p><code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>: Визначають
                        ненумерований (ul) або нумерований (ol) список та його елементи (li).</p></li>
                    <li><p><code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, <code>&lt;td&gt;</code>:
                        Визначають таблицю та її елементи.</p></li>
                    <li><p><code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>:
                        Визначають форму та її елементи для введення даних.</p></li>
                    <li><p><code>&lt;div&gt;</code>: Використовується для групування та стилізації інших елементів.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке семантичні теги та навіщо вони потрібні? Наведіть приклади таких тегів.
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>Семантичні теги в HTML це
                    елементи, які мають смислове значення та описують зміст, структуру та значення елементів на
                    сторінці. Використання семантичних тегів допомагає робити HTML-код більш зрозумілим для розробників
                    та браузерів, покращує доступність та SEO.</p>
                    <p>Основні переваги семантичних тегів:</p>
                    <ol>
                        <li><p><strong>Зрозумілість коду:</strong> Імена семантичних тегів самі по собі вказують на їхнє
                            значення, що робить код більш зрозумілим і легким для інших розробників читати.</p></li>
                        <li><p><strong>SEO:</strong> Використання семантичних тегів може поліпшити індексацію сторінок
                            пошуковими системами.</p></li>
                        <li><p><strong>Доступність:</strong> Семантичні теги допомагають робити веб-сайти більш
                            доступними для користувачів з вадами зору, а також для інших асистивних технологій.</p></li>
                    </ol>
                    <p>Приклади семантичних тегів:</p>
                    <ol>
                        <li><p><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</p></li>
                        <li><p><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</p></li>
                        <li><p><code>&lt;main&gt;</code>: Визначає основний контент сторінки.</p></li>
                        <li><p><code>&lt;article&gt;</code>: Визначає незалежний, самостійний контент, який може бути
                            повністю розміщений на іншому ресурсі.</p></li>
                        <li><p><code>&lt;section&gt;</code>: Визначає секцію документа.</p></li>
                        <li><p><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного
                            контенту (наприклад, бічні бари, реклама).</p></li>
                        <li><p><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</p></li>
                        <li><p><code>&lt;figure&gt;</code> і <code>&lt;figcaption&gt;</code>: Визначають зображення або
                            мультимедійний контент та його підпис.</p></li>
                        <li><p><code>&lt;time&gt;</code>: Визначає дату або час.</p></li>
                    </ol>
                    <p>Ці теги допомагають створювати структурований та змістовно збагачений HTML, що полегшує розуміння
                        структури документа як розробниками, так і браузерами та іншими агентами.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які теги добавили в HTML5?
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>HTML5 вніс багато нових тегів і
                    атрибутів, що значно поліпшили можливості мови та розширили функціональність веб-розробки. Ось деякі
                    з нових тегів, які були додані в HTML5:</p>
                    <ol>
                        <li><p><strong>Семантичні блокові елементи:</strong></p>
                            <ul>
                                <li><code>&lt;article&gt;</code>: Визначає самостійний контент, який може існувати
                                    незалежно від інших частин документа.
                                </li>
                                <li><code>&lt;section&gt;</code>: Визначає секцію документа.</li>
                                <li><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</li>
                                <li><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</li>
                                <li><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</li>
                                <li><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного
                                    контенту (наприклад, бічні бари, реклама).
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Елементи для введення форм:</strong></p>
                            <ul>
                                <li><code>&lt;datalist&gt;</code>: Визначає список варіантів для елемента <code>&lt;input&gt;</code>
                                    з атрибутом <code>list</code>.
                                </li>
                                <li><code>&lt;output&gt;</code>: Визначає область виведення для результатів форми.</li>
                            </ul>
                        </li>
                        <li><p><strong>Мультимедійні теги:</strong></p>
                            <ul>
                                <li><code>&lt;audio&gt;</code>: Визначає аудіо-елемент для вставки звукового контенту.
                                </li>
                                <li><code>&lt;video&gt;</code>: Визначає відео-елемент для вставки відео-контенту.</li>
                            </ul>
                        </li>
                        <li><p><strong>Графічні теги:</strong></p>
                            <ul>
                                <li><code>&lt;canvas&gt;</code>: Визначає область, на якій можна малювати за допомогою
                                    JavaScript.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Теги для роботи з ресурсами:</strong></p>
                            <ul>
                                <li><code>&lt;embed&gt;</code>: Вставляє зовнішні ресурси, такі як плагіни, аудіо або
                                    відео.
                                </li>
                                <li><code>&lt;source&gt;</code>: Вказує ресурс для вкладання у елементи <code>&lt;audio&gt;</code>
                                    та <code>&lt;video&gt;</code>.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Атрибути форм:</strong></p>
                            <ul>
                                <li><code>autocomplete</code>: Атрибут для управління автозаповненням полів форми.</li>
                                <li><code>placeholder</code>: Атрибут для встановлення підказки для користувача у полі
                                    введення.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Атрибути гіперпосилань:</strong></p>
                            <ul>
                                <li><code>download</code>: Атрибут для вказання, що посилання призначене для
                                    завантаження файлу замість переходу за ним.
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p>Це лише деякі приклади тегів та атрибутів, які були додані в HTML5. Ці зміни спрямовані на
                        поліпшення структури документа, роботи з мультимедіа та забезпечення більшої доступності та
                        можливостей веб-розробникам.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке data-атрибути, в яких випадках їх використовуєте?
            </div>
            <div class="collapsible-body">
                data-атрибути - це спеціальні атрибути HTML-тегів, які починаються з префіксу data-. Вони призначені для
                зберігання власних даних в елементах HTML, які можуть бути використані для додаткового опису або
                ідентифікації елементів. Використання data-атрибутів дозволяє розробникам зберігати інформацію без
                втручання у стандартні атрибути. Деякі випадки використання data-атрибутів:
                <ol>
                    <li>JavaScript: За допомогою data-атрибутів можна зберігати дані, які JavaScript потрібно
                        використовувати. Наприклад, для зберігання ідентифікаторів чи параметрів, які використовуються в
                        динамічних скриптах. JavaScript може отримати значення data-action для подальших дій.
                    </li>
                    <li>CSS: Можна використовувати data-атрибути для створення CSS-селекторів або передачі додаткових
                        стилів. В CSS: .user[data-status="active"] {} - Це дозволить стилізувати елемент із конкретним
                        data-атрибутом.
                    </li>
                    <li>HTML: Інколи data-атрибути використовуються для вставки додаткової інформації, яку може
                        використовувати браузер або інші інструменти.
                    </li>
                </ol>
                Тут data-analytics та data-location можуть вказувати на аналітичні дані для слідкування кліків та місця
                розташування посилання.

                Важливо пам'ятати, що data-атрибути не повинні використовуватися для зберігання інформації, яка повинна
                бути доступна для користувачів або врахована в пошукових системах. Вони призначені для зберігання
                технічної або внутрішньої інформації, яка не відображається на сторінці напряму.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Шо таке AMP?
            </div>
            <div class="collapsible-body">
                <p>AMP HTML, або Accelerated Mobile Pages, є фреймворком веб-компонентів, призначеним для оптимізації
                    перегляду веб-сторінок на мобільних пристроях. Його основна мета - покращити швидкість завантаження
                    сторінок та користувацький досвід на мобільних пристроях, дотримуючись найкращих практик щодо
                    продуктивності.</p>

                <p>Переваги використання AMP HTML включають в себе швидший час завантаження, кращі позначення у
                    пошукових системах, збільшення взаємодії користувачів та зменшення відсотку відмов. Це досягається
                    за допомогою різних оптимізацій, таких як ліниве завантаження зображень, асинхронне виконання
                    JavaScript та спрощення CSS.</p>

                AMP HTML відрізняється від звичайного HTML кількома способами:
                <ol>
                    <li>Вимагає конкретного заявлення doctype (< !doctype html>) та тегу < html amp>.</li>
                    <li>Користувацькі компоненти AMP замінюють деякі стандартні елементи HTML (наприклад, < amp-img>
                        замість < img>).
                    </li>
                    <li>Зовнішні таблиці стилів не дозволяються; весь CSS повинен бути вбудованим та обмеженим до
                        75KB.
                    </li>
                    <li>Дозволяється лише асинхронне виконання JavaScript із обмеженнями на власні сценарії.</li>
                    <li>Ресурси сторонніх постачальників повинні завантажуватись через схвалені розширення AMP.</li>
                    <li>Макет контенту повинен бути визначений перед завантаженням ресурсів для запобігання
                        переприсвоєнню контенту.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як оптимізувати перформанс сайту?
            </div>
            <div class="collapsible-body">
                Оптимізація продуктивності веб-сайту - це важливий аспект для забезпечення ефективної роботи сайту і
                задоволення користувачів. Ось деякі стратегії для оптимізації продуктивності сайту:

                <ol>
                    <li>
                        <strong>Зменшення розміру та кількості запитань:</strong>
                        <ul>
                            <li>Об'єднання та мінімізація файлів CSS, JavaScript та зображень може допомогти зменшити
                                розмір сторінки і час завантаження.
                            </li>
                            <li>Використання спрайтів для об'єднання зображень може зменшити кількість запитів
                                серверу.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Кешування</strong>
                        <ul>
                            <li>Використовуйте HTTP-заголовки кешування, щоб зберегти копії ресурсів на стороні клієнта
                                та уникнути повторних завантажень при повторних відвідуваннях сайту.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Асинхронне завантаження ресурсів</strong>
                        <ul>
                            <li></li>
                            <li></li>
                        </ul>
                    </li>
                    <li>
                        <strong></strong>
                        <ul>
                            <li>Завантажуйте JavaScript асинхронно та використовуйте атрибут async чи defer.</li>
                            <li>Використання лінивого завантаження для зображень та інших ресурсів, які не є необхідними
                                на початковому етапі завантаження сторінки.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Оптимізація зображень</strong>
                        <ul>
                            <li>Використовуйте формати зображень, що мають високу ступінь стиснення, такі як WebP.</li>
                            <li>Зменшуйте розмір зображень перед їх завантаженням.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мінімізація запитів до сервера</strong>
                        <ul>
                            <li>Зменшення кількості ресурсів на сторінці може допомогти скоротити час завантаження.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Використання CDN</strong>
                        <ul>
                            <li>Використання Content Delivery Network дозволяє розміщувати ресурси на серверах, що
                                розташовані ближче до користувачів, що поліпшує швидкість завантаження.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Аналіз та оптимізація запитів до бази даних</strong>
                        <ul>
                            <li>Оптимізація SQL-запитів та використання кешування можуть покращити відгук сайту.</li>

                        </ul>
                    </li>
                    <li>
                        <strong>Мініфікація HTML, CSS, та JavaScript</strong>
                        <ul>
                            <li>Видалення зайвих пробілів, коментарів та мінімізація коду можуть зменшити обсяг файлів і
                                покращити швидкість завантаження.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Оптимізація сервера</strong>
                        <ul>
                            <li>Використовуйте високопродуктивні сервери та оптимізуйте налаштування серверного
                                програмного забезпечення.
                            </li>
                            <li></li>
                        </ul>
                    </li>
                    <li>
                        <strong>Use a Content Delivery Network (CDN)</strong>
                        <ul>
                            <li>Сервіс по обслуговуванню статичних файлів може бути витребувальним завданням. Оскільки
                                це не є основною діяльністю 99% веб-сайтів, розумно передавати цю частину інфраструктури
                                іншим постачальникам. На щастя, існують спеціальні сервіси саме для цього: мережі
                                доставки контенту або CDN.
                            </li>
                            <li>CDN оптимізують доставку статичних файлів, таких як CSS, зображення, шрифти та
                                JavaScript, для ваших відвідувачів. Їх налаштування, як правило, дуже просте.
                            </li>
                            <li>CDN використовують географічно розподілені сервери. Це означає, що сервер, який
                                найближчий до вашого відвідувача, буде обслуговувати файли. Таким чином, час
                                завантаження, наприклад, зображень, буде однаковим, незалежно від того, де користувач
                                підключається. Загалом, при обслуговуванні статичних файлів з власних серверів час
                                завантаження збільшується, коли користувачі фізично далеко від сервера.
                            </li>
                            <li>Ви можете використовувати Sematext Experience для моніторингу продуктивності файлів,
                                розміщених на CDN, щоб фактично виміряти, чи є сенс передавати цю частину інфраструктури
                                іншим постачальникам. Коли ми вперше почали використовувати CDN для обслуговування
                                ресурсів для Sematext Cloud, ми фактично використовували Sematext Experience, що
                                показало, що ми дійсно обслуговуємо речі швидше для наших користувачів.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Minimize Time to First Byte</strong>
                        <p>Час до першого байта, або TTFB, - це час, який потрібно браузеру для отримання першого байта
                            даних від сервера. Таким чином, це стосується серверної частини, але воно відіграє важливу
                            роль взагалі у продуктивності вашого веб-сайту, тому вам слід приділити час для його
                            поліпшення.</p>
                        <p>Основним фактором, який знаходиться під вашим контролем у відношенні до TTFB, є час обробки
                            сервера. Таким чином, ви можете випробувати деякі поради, рекомендовані Google, для
                            поліпшення TTFB:</p>
                        <ol>
                            <li>Оптимізуйте логіку застосунка сервера для швидшої підготовки сторінок. Якщо ви
                                використовуєте серверний фреймворк, у фреймворка можуть бути рекомендації щодо того, як
                                це зробити.
                            </li>
                            <li>Оптимізуйте, як ваш сервер виконує запити до баз даних або переходіть до швидших систем
                                баз даних.
                            </li>
                            <li>Оновіть апаратне забезпечення сервера для отримання більше пам'яті або ЦП.</li>
                        </ol>
                        <p>TTFB менше 200 мс вважається великим. Діапазон від 200 мс до 500 мс вважається нормальним і
                            прийнятним. TTFB, що постійно перевищує 600 мс, потрібно розглядати для дослідження.
                            Sematext Experience може допомогти вам у цьому, а також в моніторингу інших метрик Web
                            Vitals.</p>
                    </li>
                    <li>
                        <strong>Кешування</strong>
                        <p>Я коротко згадував про кеш, але хочу пояснити, що це таке. Кешування - це процес збереження
                            версії ваших файлів у тимчасовому сховищі - кеші -, до якого можна отримати швидший доступ.
                            Є багато переваг у ввімкненні кешування в браузері, оскільки це може зменшити споживання
                            пропускної здатності, збільшити час завантаження, зменшити затримку та робоче навантаження
                            сервера. Основним недоліком є те, що фактично завжди буде принаймні дві версії вашого
                            веб-сайту у будь-який момент часу. Це може викликати проблеми, якщо ви використовуєте службу
                            в реальному часі, яка залежить від точних даних, але це можна вирішити в певній мірі,
                            вимагаючи очищення підсекції кешу при імпортуванні нових даних.</p>
                    </li>
                    <li>
                        <strong></strong>
                        <ul>
                            <li></li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are the critical rendering paths in a web browser?
            </div>
            <div class="collapsible-body">
                <p><strong>Критичний шлях рендеру (Critical Rendering Paths)</strong> - це послідовність дій, які браузер повинен виконати
                    для відображення вмісту сторінки на екрані користувача. Основним завданням є оптимізація цих шляхів для
                    максимально швидкого і коректного відображення вмісту. Нижче подано опис критичних шляхів у веб-браузері:</p>
                <ol>
                    <li>
                        <strong>Отримання HTML (Fetch HTML):</strong>
                        <p>Браузер починає завантаження сторінки, відправляючи запит на сервер для отримання HTML-коду.</p>
                        <p> Використання Content Delivery Network (CDN), компресія HTML і налаштування кешування.</p>
                    </li>
                    <li>
                        <strong>Обробка HTML (Parse HTML):</strong>
                        <p>Браузер аналізує отриманий HTML-код та створює DOM (Document Object Model) та CSSOM (CSS Object Model).</p>
                        <p>Мінімізація та усунення блокуючих ресурсів, збільшення паралелізму завантаження.</p>
                    </li>
                    <li>
                        <strong>Створення Render Tree (Create Render Tree):</strong>
                        <p> Браузер об'єднує DOM та CSSOM у Render Tree, який визначає порядок відображення елементів.</p>
                        <p>Мінімізація кількості CSS-блокуючих ресурсів, використання ефективних селекторів CSS.</p>
                    </li>
                    <li>
                        <strong>Обчислення розмірів та позицій (Layout):</strong>
                        <p>Браузер визначає розміри та позиції кожного елемента в Render Tree.</p>
                        <p>Використання флексбоксів, грідів, уникання складних таблиць.</p>
                    </li>
                    <li>
                        <strong>Відображення (Paint):</strong>
                        <p>Браузер займається фактичним відображенням сторінки на екрані користувача.</p>
                        <p>Використання анімацій GPU, оптимізація зображень.</p>
                    </li>
                    <li>
                        <strong>Оновлення (Composite): </strong>
                        <p>Браузер обновлює екран згідно з внесеними змінами.</p>
                        <p>Використання апаратного прискорення, уникання зайвих перемальовувань.</p>
                    </li>
                </ol>
                <p>Оптимізація критичних шляхів є ключовою для досягнення високої швидкодії завантаження сторінок та відповіді на запити
                    користувачів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                BOM (Browser Object Model) vs DOM (Document Object Model)
            </div>
            <div class="collapsible-body">
                <p>BOM (Browser Object Model) та DOM (Document Object Model) - це дві різні моделі об'єктів, які використовуються
                    веб-браузерами для представлення вмісту та взаємодії з ним на сторінках в Інтернеті. Нижче подано їхні основні
                    різниці:</p>
                <h6>DOM (Document Object Model):</h6>
                <ol>
                    <li>
                        <strong>Опис</strong>
                        <ul>
                            <li>DOM представляє структуру документа веб-сторінки, яка може бути HTML, XML або XHTML.</li>
                            <li>Кожен елемент, атрибут, текстовий вузол тощо має свій відповідний об'єкт в DOM.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Призначення</strong>
                        <ul>
                            <li>Використовується для доступу, маніпуляції та зміни структури та вмісту веб-документа.</li>
                            <li>Дозволяє скриптам змінювати вигляд та поведінку сторінки.</li>
                        </ul>
                    <li>
                        <strong>Орієнтований на документ</strong>
                        <ul>
                            <li>DOM визначає структуру документа та забезпечує можливість програмного доступу до елементів документа.</li>
                        </ul>
                </ol>

                <h6>BOM (Browser Object Model):</h6>
                <ol>
                    <li>
                        <strong>Опис</strong>
                        <ul>
                            <li>BOM представляє об'єкти браузера, такі як вікна та фрейми, а також деякі додаткові об'єкти, такі як
                                navigator, history, location тощо.
                            </li>
                            <li>Включає об'єкти, які не пов'язані з структурою документа.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Призначення</strong>
                        <ul>
                            <li>Використовується для контролю та взаємодії з самим браузером, а не конкретним документом.</li>
                            <li>Надає доступ до функцій, таких як керування вікнами, робота з історією перегляду, визначення
                                місцезнаходження тощо.
                            </li>
                        </ul>
                    <li>
                        <strong>Орієнтований на браузер</strong>
                        <ul>
                            <li>BOM визначає об'єкти, які представляють браузер і дозволяють контролювати його функціонал.</li>
                        </ul>
                </ol>

                <h6>Загальна Ідея:</h6>
                <ul>
                    <li>DOM відповідає за структуру та вміст веб-сторінки.</li>
                    <li>BOM відповідає за взаємодію з самим браузером та його функціоналом.</li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Доступність веб-сайту (Web Accessibility)
            </div>
            <div class="collapsible-body">
                <p>Доступність веб-сайту (Web Accessibility) — це забезпечення можливості використання та сприйняття веб-ресурсу всіма
                    користувачами, включаючи тих, які мають обмеження чи інвалідність. Ось деякі ключові аспекти доступності веб-сайтів:</p>
                <p>Дотримання принципів доступності дозволяє забезпечити комфортне та рівноправне використання веб-сайту всіма його
                    відвідувачами.</p>

                <ol>
                    <li>
                        <strong>Семантична Розмітка</strong>
                        <ul>
                            <li>Використання правильних HTML-тегів для опису структури сторінки.</li>
                            <li>Забезпечення логічного розташування та взаємодії елементів.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Адаптивний Дизайн:</strong>
                        <ul>
                            <li>Забезпечення читабельності та зручності використання на різних пристроях.</li>
                            <li>Створення веб-сайту, який підлаштовується під різні розміри екранів та пристрої.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Контрастність Кольорів</strong>
                        <ul>
                            <li>Використання достатнього контрасту між текстом та тлом для зручності читання користувачами з обмеженим
                                зором.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Альтернативні Тексти</strong>
                        <ul>
                            <li>Надання текстових описів (альтернативних текстів) для графічних елементів, щоб люди з вадами зору або
                                вимкненим зображенням могли зрозуміти зміст.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Клавішні Спуски</strong>
                        <ul>
                            <li>Забезпечення можливості навігації та використання всіх інтерактивних елементів за допомогою клавіатури, а не
                                лише миші.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Відмова від Миготіння</strong>
                        <ul>
                            <li>Уникання використання миготливих або блимучих елементів, які можуть викликати дискомфорт чи епілептичні
                                напади.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Легенди та Підказки Форм</strong>
                        <ul>
                            <li>Додавання чітких заголовків, підказок та легенд до форм для полегшення їх використання.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мовні Атрибути</strong>
                        <ul>
                            <li>Використання атрибутів мови для правильного визначення та читання текстів на різних мовах.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Навігація та Заголовки</strong>
                        <ul>
                            <li>Додавання структурованої навігації та заголовків для полегшення розуміння контенту та навігації.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Тестування з Користувачами</strong>
                        <ul>
                            <li>Проведення тестів доступності з реальними користувачами з різними потребами та обмеженнями.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>


    </ul>


    <h5 id="css">CSS</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Анімації
            </div>
            <div class="collapsible-body">
                <p>Анімація у CSS дозволяє створювати рухливі та привабливі ефекти на веб-сайтах. Ось основні аспекти використання CSS
                    анімації:</p>
                <ol>
                    <li>
                        <strong>Ключові Кадри (Keyframes)</strong>
                        <ul>
                            <li>Ключові кадри визначають стани елемента на різних етапах анімації.</li>
                            <li>Використовуються ключові слова @keyframes для створення набору кадрів.</li>
                            <li>
                                <pre>
                                    @keyframes example {
                                      0% { opacity: 0; }
                                      50% { opacity: 0.5; }
                                      100% { opacity: 1; }
                                    }
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивість animation</strong>
                        <ul>
                            <li>Властивість animation використовується для визначення анімації для елемента.</li>
                            <li>Зазвичай вказується ім'я ключових кадрів та тривалість анімації.</li>
                            <li>.element { animation: example 3s ease-in-out; }</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Опції Таймінгу:</strong>
                        <ul>
                            <li><strong>ease</strong>: починається повільно, прискорюється, а потім знову сповільнюється.</li>
                            <li><strong>linear</strong>: рухається з однаковою швидкістю протягом всієї тривалості.</li>
                            <li><strong>ease-in</strong>: починається повільно, потім прискорюється.</li>
                            <li><strong>ease-out</strong>: починається швидко, потім сповільнюється.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивості animation-delay та animation-iteration-count</strong>
                        <ul>
                            <li><strong>animation-delay</strong> вказує затримку перед початком анімації.</li>
                            <li><strong>animation-iteration-count</strong> визначає кількість повторень анімації.</li>
                            <li>.element { animation-delay: 2s; animation-iteration-count: infinite; }</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Зміна Властивостей:</strong>
                        <ul>
                            <li>Анімація може змінювати різні властивості, такі як розмір, колір, положення тощо.</li>
                            <li><pre>
                                @keyframes example {
                                    0% { transform: scale(1); }
                                    50% { transform: scale(1.5); }
                                    100% { transform: scale(1); }
                                }
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивість animation-fill-mode:</strong>
                        <ul>
                            <li>Вказує, яким чином стилі мають застосовуватися до елемента поза межами визначеної анімації.</li>
                            <li>.element { animation: example 3s ease-in-out; animation-fill-mode: forwards; }
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Різниця між Grid & Flexbox
            </div>
            <div class="collapsible-body">
                <p>Розуміння різниці між CSS Grid та Flexbox є ключовим для ефективного проектування макету. Особа, яка проходить інтерв'ю,
                    повинна вміти висловлювати ці різниці та їхні випадки використання.</p>

                <p>CSS Grid - це двовимірна система, яка обробляє як рядки, так і стовпці, ідеальна для масштабних макетів. Flexbox - це
                    одновимірна система, яка обробляє один рядок АБО один стовпець одночасно, найбільш підходить для менших макетів, де
                    елементи
                    повинні вирівнюватися або розподілятися відносно один одного. Подавшись для розташування загальної структури, Grid, як
                    правило, використовується для розташування елементів всередині тих самих комірок Grid.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Методології CSS (BEM, OOCSS, SMACSS)
            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Переваги використання препроцесорів в проекті
            </div>
            <div class="collapsible-body">
                <p>
                    Процесори CSS, такі як SASS та LESS, розширюють базові можливості CSS. Вони вводять функції, такі як змінні,
                    вкладеність, міксини та успадкування, що робить CSS більш підтримуваним та організованим. Однак вони вимагають процесу
                    збірки, і створений CSS не завжди може бути оптимізованим. Також відладка може бути складнішою через різницю між
                    написаним кодом та компільованим CSS.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="security">Security</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Кращі практики безпеки веб-додатків
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>Валідація вхідних даних</strong>
                        <p>Однією з основних атак, на які піддаються веб-програми, є атака на вхідні дані. Розробники
                            повинні завжди перевіряти та валідувати дані, які отримують від користувачів, щоб запобігти
                            SQL-ін'єкції, крос-сайтовий скриптинг (XSS) та інші атаки.</p>
                    </li>
                    <li>
                        <strong>Захист від автентифікації та керування сеансами</strong>
                        <p>Керування сеансами та автентифікація користувачів - це ключові аспекти безпеки веб-додатків.
                            Надійна автентифікація з використанням сильних паролів та двофакторної автентифікації є
                            обов'язковою. Крім того, сесії користувачів мають бути захищені від перехоплення та
                            підробки.</p>
                    </li>
                    <li>
                        <strong>Оновлення та патчі</strong>
                        <p>Регулярне оновлення та встановлення патчів для веб-додатків, бібліотек та фреймворків, що
                            використовуються, - це обов'язкова умова для забезпечення безпеки. Уразливості, виявлені у
                            сторонніх компонентах, можуть стати легкою здобиччю для зловмисників.</p>
                    </li>
                    <li>
                        <strong>Обмеження прав доступу</strong>
                        <p>Застосування принципу найменших привілеїв (Least Privilege) є важливим для зменшення ризиків.
                            Користувачі та компоненти програми повинні мати лише права доступу, які необхідні для
                            виконання своїх завдань.</p>
                    </li>
                    <li>
                        <strong>Моніторинг та журналювання</strong>
                        <p>Ведення журналів дій користувачів та системних подій дозволяє виявляти аномалії та атаки у
                            реальному часі. Моніторинг дозволяє оперативно реагувати на загрози та запобігати витоку
                            даних.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Основні види вразливостей веб-застосунків
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>SQL-ін'єкції</strong>
                        <p>SQL-ін'єкції виникають, коли зловмисник впроваджує шкідливий SQL-код у запити до бази даних.
                            Це може призвести до незаконного доступу до даних або їх зміни. Правильна валідація та
                            використання параметризованих запитів допомагають запобігти SQL-ін'єкції.</p>
                        <p>SQL ін’єкція (SQLi) — це тип ін’єкційної атаки, яка дозволяє модифікувати SQL команди для
                            отримання даних або виведення з ладу програми. Зловмисники можуть модифікувати команди SQL,
                            які впливають на ваш застосунок, через деякі вхідні дані на вашому сайті, наприклад, поле
                            пошуку.</p>
                        <p>Успішне виконання SQL ін’єкції може призвести до неавторизованого доступу до конфіденційних
                            даних (це може бути дуже «чутлива» інформація — наприклад, паролі, адреси, дані кредитних
                            карток і так далі). За останні кілька років багато випадків витоку інформації стали
                            результатом саме SQL ін’єкцій.</p>
                    </li>
                    <li>
                        <strong>Крос-сайтовий скриптинг (XSS - Cross-Site Scripting)</strong>
                        <p>XSS - це атака, за якої зловмисник впроваджує шкідливий JavaScript-код у веб-сторінку, який
                            виконується у браузері користувача. Захист від XSS включає екранування даних і використання
                            Content Security Policy (CSP).</p>
                        <p>Головна ідея XSS в тому, що зловмиснику вдається додати на сторінку JavaScript-код, якого до
                            цього не було. Цей код буде виконуватися щоразу, коли жертви (тобто користувачі)
                            заходитимуть на сторінку застосунку, де цей код додав зловмисник.</p>
                        <p>XSS вразливість виникає при генерації HTML-сторінки, коли розробнику потрібно помістити туди
                            дані, вказані користувачем. Якщо хакер зможе розмістити довільний HTML-код, то отримає
                            доступ до змін та керування відображенням вебсторінки з правами самого сайту.</p>
                        <p>Наслідки від XSS ін’єкції можуть бути критичними. Так, дана ін’єкція не впливає безпосередньо
                            на застосунок, вона спрямована на користувача. Проте зловмисник може вкрасти авторизаційні
                            cookie користувача застосунку і тим самим його сесію. Також може перенаправити користувача
                            на власний сайт, де розмістить форми вводу, схожі на оригінальні. І якщо користувач введе
                            свої дані, то вони опиняться у зловмисника. Можливість для безперешкодного експлуатування
                            XSS ін’єкції у застосунку може призвести до витоку даних та суттєвих репутаційних втрат для
                            компанії.</p>
                    </li>
                    <li>
                        <strong>Крос-сайтова підробка запиту (CSRF - Cross-Site Request Forgery)</strong>
                        <p>CSRF - це атака, коли зловмисник змушує користувача виконувати небажані дії без його згоди.
                            Захист від CSRF включає використання токенів запитів (CSRF-токени) і перевірку
                            Referer-заголовка.</p>
                    </li>
                    <li>
                        <strong>Недоліки автентифікації та керування сеансами</strong>
                        <p>Слабка автентифікація та керування сеансами можуть призвести до компрометації облікових
                            записів користувачів. Для захисту слід використовувати сильні паролі, двофакторну
                            автентифікацію та надійне керування сеансами.</p>
                        <p><strong>Автентифікація</strong> — це дії, вжиті для встановлення або перевірки чогось або когось. Це процедура
                            встановлення належності користувачеві
                            інформації в системі пред’явленого ним ідентифікатора. В інформаційній безпеці автентифікація є частиною
                            процедури надання доступу користувачу для
                            роботи в застосунку, наступною після ідентифікації та передує авторизації.</p>
                        <p>Автентифікація дуже важливий функціонал застосунку, оскільки дозволяє реалізувати безпечний доступ до даних.
                            Кожен користувач хоче бути впевнений у тому, що його дані неможливо забрутфорсити й вони зберігаються безпечно.
                            В результаті шлях користувача в системі виглядає приблизно так: спочатку користувача ідентифікується з
                            ідентифікатором користувача, а після цього виконується автентифікація на основі наданого користувачем пароля,
                            який відповідає цьому ідентифікатору.</p>
                        <p>Вразливості автентифікації можуть виникати з різних причин, тому немає єдиного алгоритму їх пошуку. Серед
                            найбільш поширених вразливостей можна перерахувати наступні:</p>
                        <ul>
                            <li>атака перебору імені користувача та пароля</li>
                            <li>відсутність перевірки складності пароля</li>
                            <li>некоректний менеджмент сесії</li>
                            <li>неправильна реалізація функціонала зміни та відновлення пароля</li>
                            <li>атаки на JWT токени тощо.</li>
                        </ul>
                        <p>Проблема вразливості автентифікації є однією з найпростіших проблем для розуміння ризиків. І водночас вони можуть
                            бути одними з найбільш критичних через очевидний зв’язок між автентифікацією та безпекою. Крім того, що проблеми
                            автентифікації потенційно дозволяють зловмисникам отримати прямий доступ до конфіденційних даних і функцій, вони
                            також створюють додатковий простір для атаки та інтеграції нових експлойтів. Тому навчитися виявляти та
                            використовувати вразливі місця автентифікації, включаючи те, як обійти загальні заходи захисту, є однією з
                            фундаментальних навичок не тільки кіберфахівців, а й розробників та всіх хто працює з даними користувачів в
                            продукті.</p>
                    </li>
                </ol>
            </div>
        </li>
    </ul>

    <h5 id="network">Network</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Різниця між HTTP/2 і HTTP/1.1
            </div>
            <div class="collapsible-body">
                <p>Розуміння протоколів HTTP та їх відмінностей є важливим для покращення продуктивності та ефективності веб-застосунку.</p>

                <p>HTTP/2 має кілька переваг перед HTTP/1.1. Він дозволяє мультиплексування, що дозволяє відправляти одночасно кілька запитань
                та відповідей по одному з'єднанню. Крім того, він підтримує серверний push, коли сервер може проктивно надсилати важливі
                ресурси клієнту. HTTP/2 також реалізує стиснення заголовків для зменшення накладних витрат.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <!--    <h5 id="js">JS</h5>-->
    <!--    <ul class="collapsible">-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">filter_drama</i>First</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">place</i>Second</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">whatshot</i>Third</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--    </ul>-->

    <h5 id="npm">NPM</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке NPM і для чого його
                використовувати?
            </div>
            <div class="collapsible-body">
                NPM (Node Package Manager) є системою управління пакетами для JavaScript, яка дозволяє розробникам легко
                встановлювати, оновлювати та використовувати залежності у своїх проектах. В основному, використовується
                для управління бібліотеками та іншими залежностями, які використовуються в проектах на базі Node.js.
                Декілька ключових причин для використання NPM:

                <ol>
                    <li><strong>Установка пакетів:</strong> NPM дозволяє легко встановлювати пакети (бібліотеки,
                        фреймворки, інструменти) для використання в проекті.
                    </li>
                    <li><strong>Управління версіями:</strong> NPM дозволяє вказувати версії пакетів, щоб гарантувати
                        сумісність та уникнути проблем залежностей.
                    </li>
                    <li><strong>Сценарії:</strong> Ви можете визначити різні сценарії (scripts) для автоматизації
                        завдань, таких як запуск сервера, збірка проекту чи тестування.
                    </li>
                    <li><strong>Пакетні файли та конфігурації:</strong> NPM дозволяє визначити пакетні файли та
                        конфігурації, які допомагають у встановленні та налаштуванні проекту.
                    </li>
                    <li><strong>Глобальні та локальні пакети:</strong> NPM дозволяє встановлювати пакети глобально для
                        доступу з будь-якого місця, або локально для конкретного проекту.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Глобальна та локальна установка
                пакетів за допомогою NPM
            </div>
            <div class="collapsible-body">
                Глобальна установка пакетів NPM означає, що пакет встановлюється на рівні системи та може бути
                використаний в будь-якому проекті. Це зазвичай використовується для інструментів командного рядка.
                Локальна установка, навпаки, встановлює пакет лише в межах поточного каталогу проекту. Це гарантує, що
                різні проекти не взаємодіють між собою через різні версії пакетів.
                Для глобальної установки використовується команда npm install -g, а для локальної - npm install.
                Наприклад, глобальна установка може бути корисною для інсталяції інструментів командного рядка, таких як
                create-react-app, які використовуються на рівні системи. Локальна установка, навпаки, дозволяє
                встановлювати бібліотеки, які використовуються тільки в межах конкретного проекту, такі як бібліотеки
                для розробки на React.js.
                Локальні пакети використовуються для забезпечення залежностей конкретного проекту. Це дозволяє уникнути
                конфліктів версій між різними проектами.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Файл Package.json, його функції</div>
            <div class="collapsible-body">

                <p>Package.json - це ключовий файл у проектах Node.js, який виступає як файл маніфесту. Він містить
                    метадані, що стосуються проекту, і включає в себе властивості, такі як ім'я, версія, опис, автор та
                    ліцензія.</p>

                <p>Також він перераховує залежності, необхідні для роботи додатка. Вони вказуються разом зі своїми
                    відповідними версіями у розділах "dependencies" чи "devDependencies". Перший містить пакети,
                    необхідні для продакшн, тоді як другий для розробки.</p>

                <p>Розділ "scripts" визначає скорочення команд, які можна виконати за допомогою npm. Наприклад, скрипт
                    "start" зазвичай запускає додаток.</p>

                <p>Додатково, файл може містити конфігураційні дані для інструментів, що використовуються у вашому
                    проекті у розділі "config", власні поля даних у "private" та вказати основну точку входу вашого
                    додатка у "main".</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як оновити пакет за допомогою NPM?
            </div>
            <div class="collapsible-body">
                Щоб оновити пакет за допомогою NPM, спочатку потрібно перевірити застарілі пакети. Використовуйте
                команду "npm outdated" у терміналі. Це виведе список всіх пакетів, для яких доступні нові версії. Щоб
                оновити конкретний пакет, використовуйте команду "npm update [ім'я-пакету]". Якщо ви хочете оновити всі
                пакети, просто використовуйте "npm update" без вказання імені пакету. Важливо враховувати, що це оновить
                лише мінорні та патч-релізи відповідно до правил семантичної версії. Для оновлення мажорних версій вам
                потрібно використовувати команду "npm install [ім'я-пакету]@latest". Завжди пам'ятайте перевіряти
                оновлення, переглядаючи файл package.json або використовуючи "npm outdated" знову.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як керувати версіями пакетів в NPM?
            </div>
            <div class="collapsible-body">NPM дозволяє управляти версіями пакетів за допомогою семантичного
                версіонування (semver). У вашому файлі package.json залежності перераховуються з їх версіями. Символ
                каретки (^) чи тильда (~) перед номером версії вказує на гнучкість у використанні новіших мінорних чи
                патч-версій відповідно. Щоб встановити конкретну версію, ви можете використовувати "npm install
                [пакет]@[версія]". Для оновлення до останньої мажорної версії команда "npm outdated" показує пакети, які
                потребують оновлення, і "npm update [пакет]" оновлює їх. Якщо декілька проектів вимагають різних версій,
                розгляньте використання nvm від npm чи Docker для ізольованих середовищ.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як використовується Семантичне
                версіонування у проекті?
            </div>
            <div class="collapsible-body">Семантичне версіонування, або SemVer, є системою версіонування для програмного
                забезпечення, яка має на меті передавати значення щодо основних змін у випуску. Вона використовує формат
                MAJOR.MINOR.PATCH, де кожне збільшення представляє різні типи модифікацій. Збільшення мажорної версії
                вказує на несумісні зміни у API, мінорної - на додання функціоналу сумісним способом, а патчу - на
                виправлення помилок, сумісних назад.

                У NPM семантичне версіонування використовується для управління залежностями. Під час встановлення
                пакетів ви можете вказати версію за допомогою нотації SemVer. Наприклад, "^1.0.0" встановить останню
                мінорну або патч-версію вище 1.0.0, але нижче 2.0.0. Це дозволяє розробникам контролювати версії їх
                залежностей, забезпечуючи сумісність та стабільність у їх проектах.>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як видалити пакет?</div>
            <div class="collapsible-body">

                Щоб видалити пакет за допомогою NPM, використовуйте команду "npm uninstall", за якою слідує ім'я пакету.
                Це видаляє його з каталогу node_modules та оновлює ваш файл package.json, відображаючи зміну. Якщо ви
                хочете видалити його глобально, додайте "-g". Щоб зберегти зміни в файлі package-lock.json, включіть
                "--save". Наприклад:
                <strong>npm uninstall < ім'я-пакету></strong><br/>. Це видаляє локально. Для глобального видалення:
                <strong>npm uninstall -g < ім'я-пакету></strong>. <br/>А для оновлення package-lock.json: <strong>npm
                uninstall --save < ім'я-пакету></strong>


            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Для чого використовуємо .npmignore
                файл?
            </div>
            <div class="collapsible-body">
                Файл .npmignore використовується у проектах Node.js для вказівки файлів чи каталогів, які не повинні
                бути включені до пакету, який надсилається до реєстру npm. Він функціонує подібно до файлу .gitignore,
                але спеціально для npm-пакетів. Якщо в каталозі не існує файлу .npmignore, npm використовує файл
                .gitignore замість нього. Однак у разі наявності обох файлів .npmignore має перевагу.

                Це дозволяє розробникам зберігати певні файли у своєму локальному репозиторії, не включаючи їх у
                опублікований пакет, такі як тести, README-файли чи інші необов'язкові файли.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Що як пакет, який використовується в
                проекті, застарів чи перестав підтримуватись?
            </div>
            <div class="collapsible-body">
                У ситуації, коли NPM-пакет, від якого залежить проект, є застарілим або більше не підтримується, я б
                спочатку оцінив вплив цього застаріння. Якщо це критично для проекту, я шукав би альтернативи. Зазвичай
                в обширному репозитарії NPM можна знайти схожі пакети.

                Якщо підходящу заміну знайти не вдається, і пакет є важливим, іншою опцією може бути створення форку
                оригінального пакету і його підтримка. Це передбачає розуміння кодової бази та виправлення будь-яких
                проблем чи вразливостей, що виникають. Однак це слід розглядати як останній захід через час та ресурси,
                які він вимагає.

                Ще одним підходом може бути повне вилучення залежності, якщо вона не приносить значущої користі. Це може
                потребувати рефакторингу деяких частин проекту, але може призвести до більш оптимізованої та ефективної
                кодової бази.

                Незалежно від обраного шляху важливо тщательно тестувати всі зміни, щоб вони не вводили нових помилок чи
                вразливостей у проект.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між npm та yarn</div>
            <div class="collapsible-body">
                NPM і Yarn - обидва менеджери пакетів для JavaScript, але вони відрізняються декількома способами. NPM
                автоматично встановлює пакет, коли ви його додаєте, тоді як Yarn додає пакет лише до списку, поки ви не
                виконаєте 'yarn install'. Це робить Yarn швидшим, оскільки уникнуто непотрібних встановлень. Крім того,
                Yarn вводить офлайн-режим, який кешує кожен завантажений пакет, дозволяючи встановлення без підключення
                до Інтернету. Також він перевіряє контрольні суми перед встановленням пакетів для забезпечення їх
                цілісності. Однак NPM має широку підтримку спільноти завдяки своєму тривалішому існуванню, що робить
                його більш надійним для старіших проектів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між “dependencies” and
                “devDependencies” in package.json?
            </div>
            <div class="collapsible-body">
                У файлі package.json "dependencies" та "devDependencies" мають різні цілі. "Dependencies" включають
                модулі, які необхідні для роботи вашого проекту в продакшн-середовищі. Вони встановлюються, коли ви або
                інший користувач виконує команду "npm install" без будь-яких аргументів.

                З іншого боку, "devDependencies" включають модулі, які потрібні лише під час розробки, а не в
                продакшн-середовищі. Сюди входять фреймворки для тестування, засоби збірки тощо. Вони встановлюються
                лише тоді, коли ви виконуєте "npm install" у своєму локальному середовищі розробки, а не коли
                користувачі встановлюють ваш пакет. Якщо ви використовуєте команду "npm install --production", це
                ігнорує devDependencies.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
            <div class="collapsible-body">
                Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він
                фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені
                залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл
                package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на
                будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію
                вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you handle security
                vulnerabilities in your NPM packages?
            </div>
            <div class="collapsible-body">
                Для роботи з вразливостями безпеки у пакетах NPM я використовую кілька стратегій. По-перше, я
                переконуюся, що всі мої пакети оновлені за допомогою команди 'npm update'. Це тому, що оновлення часто
                містять патчі для відомих вразливостей. По-друге, я використовую npm audit, вбудований інструмент, який
                сканує вразливості і надає детальні звіти. Він також пропонує виправлення, якщо такі є. Для
                автоматизованого сканування вразливостей я інтегрую інструменти, такі як Snyk чи Dependabot, у мій CI/CD
                конвеєр. Ці інструменти надають миттєві сповіщення про нові вразливості і автоматизують процес оновлення
                небезпечних залежностей. Нарешті, я дотримуюся кращих практик, таких як не запускання npm з правами root
                та уникання використання застарілих чи необслуговуваних пакетів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you manually change the version
                of a package using NPM?
            </div>
            <div class="collapsible-body">
                Щоб вручну змінити версію пакету за допомогою NPM, потрібно внести зміни у файл package.json. Цей файл
                містить метадані про ваш проект, включаючи залежності та їх версії. Для зміни версії пакету знайдіть
                його запис у розділі "dependencies" або "devDependencies" та відповідно змініть номер версії.

                Наприклад, якщо ви хочете змінити версію Express з 4.16.3 на 4.17.0, знайдіть рядок "express": "^4.16.3"
                і змініть його на "express": "^4.17.0".

                Після внесення змін у файл package.json виконайте команду `npm install` у вашому терміналі. Ця команда
                оновить ваш каталог node_modules на основі змін, внесених у файл package.json. Якщо виникнуть конфлікти
                між версіями, npm генерує повідомлення про помилку. Розберіть їх перед продовженням.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як вберегти певний файл від того, що
                його апдейтнуть?
            </div>
            <div class="collapsible-body">
                Щоб уникнути оновлення конкретних пакетів у NPM, ви можете скористатися командою "npm shrinkwrap". Це
                створить файл 'npm-shrinkwrap.json', який фіксує версії кожного пакету та його залежностей у вашому
                проекті. Коли цей файл присутній, команда 'npm install' встановлюватиме точні версії з
                'npm-shrinkwrap.json', ігноруючи будь-які новіші версії, вказані у 'package.json'. Замість цього ви
                також можете вказати точний номер версії пакету у файлі 'package.json'. Якщо ви видалите символи каретки
                (^) чи тильда (~) перед номером версії, npm буде використовувати саме вказану версію під час оновлень.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
            <div class="collapsible-body">
                Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він
                фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені
                залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл
                package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на
                будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію
                вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>В чому різниця команд npm і npx?
            </div>
            <div class="collapsible-body">
                npm та npx - це обидві інструменти, пов'язані з Node.js та управлінням пакетами, але вони мають різні
                призначення.
                npm (Node Package Manager):

                npm - це менеджер пакетів, який використовується для встановлення, оновлення та керування пакетами
                Node.js.
                Використовується для встановлення пакетів глобально або локально в вашому проекті.

                Приклад встановлення пакета глобально: npm install -g example-package
                Приклад встановлення пакетів локально в проекті: npm install package-name


                npx:

                npx - це інструмент, який дозволяє виконувати команди, які містяться в пакетах, не встановлюючи ці
                пакети глобально.
                Зазвичай використовується для виконання одноразових або експериментальних команд.
                Приклад використання npx для виконання команди з пакета, що не встановлено глобально: npx package-name
                command

                Отже, основна різниця полягає в тому, що npm використовується для встановлення та керування пакетами,
                тоді як npx дозволяє виконувати команди з пакетів, не встановлюючи їх глобально.
            </div>
        </li>


    </ul>


    <h5 id="git">GIT</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>Git Reset –soft, –mixed, and –hard
            </div>
            <div class="collapsible-body">
                <strong>git reset --soft < commit ></strong>

                Команда git reset відміняє зміни, зроблені в процесі. Дозволяє перемістити HEAD (поточну версію) до
                визначеного коміту.<br/>
                <strong>Git Reset --soft</strong> - переносить HEAD до вибраного комміту, але залишає стейдж незмінним.
                Це означає, що
                всі зміни після вказаного комміта будуть в стейджі, і ми зможемо їх закомітити знову.
                Виглядає це так: A -- B -- C (HEAD -> main), тоді команда <strong>git reset --soft B</strong> переносить
                нас у: A -- B (HEAD -> main), зміни, які ми зробили
                в коміті С - опиняться в стейджі. <br/>

                <strong>Git Reset --hard</strong> - потенційно найбільш небезпечна команда, оскільки переносить HEAD в
                обраний коміт, при цьому видаляє усі наступні.
                `git reset --hard B` - тепер перемістить нас в коміт B, при цьому вибаливши всі зміни з коміту С.
                Зазвичай використовується, щоб повнісю стерти зміни.

                <strong>Git Reset --mixed</strong> - дефолтна опція, переміщує HEAD до вказаного коміту, як в --soft.
                Якщо максимально просто - то `git reset --mixed B'
                команда перемістить нас на версію коміт В, але зміни з С будуть як untracked changes, а не в стейджі, як
                ми маємо це в --soft.

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>git cherry-pick</div>
            <div class="collapsible-body">

                Команда git cherry-pick в Git використовується для застосування конкретного зобов'язання (commit) з
                однієї гілки до іншої. Це дозволяє перенести вибрані
                зміни з одного коміту на інший, незалежно від того, на якій гілці вони були внесені.

                Синтаксис команди виглядає наступним чином: <strong>git cherry-pick < commit_hash ></strong><br/>
                Основні розділи використання git cherry-pick:
                <ol>
                    <li>Копіювання коміту на поточну гілку - git cherry-pick < commit_hash ></li>
                    <li>Копіювання кількох комітів - git cherry-pick < commit_hash1 > < commit_hash2 > ...</li>
                    <li>Автоматичне вирішення конфліктів - У разі, якщо виникнуть конфлікти при застосуванні коміту, Git
                        повідомить про це, і вам слід вирішити конфлікти вручну.
                    </li>
                </ol>
                !!! Ця команда корисна в ситуаціях, коли ви хочете <strong>перенести конкретні зміни з однієї гілки на
                іншу без копіювання всієї історії гілки</strong>. Важливо враховувати, що при
                використанні git cherry-pick важливо уникати переносу змін, які вже існують на цільовій гілці, оскільки
                це може призвести до конфліктів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>git fetch</div>
            <div class="collapsible-body">
                Команда git fetch використовується для завантаження змін іншого репозиторію, але не об'єднання їх з
                вашим робочим каталогом або поточною гілкою.
                Це оновлює інформацію про віддалені гілки та зобов'язання, але не змінює ваш робочий каталог.

                Синтаксис команди виглядає так: <strong>git fetch [remote_name]</strong>, де [remote_name] - це ім'я
                віддаленого репозиторію. Якщо ім'я віддаленого репозиторію не вказано, Git використовує за замовчуванням
                origin.

                Основні варіанти використання git fetch:
                <ol>
                    <li>Завантаження змін з віддаленого репозиторію: git fetch</li>
                    <li>Завантаження змін з конкретного віддаленого репозиторію: git fetch [remote_name]</li>
                </ol>
                Після використання git fetch, ви можете переглянути зміни, що були завантажені, і при необхідності
                об'єднати їх з вашим робочим каталогом за допомогою команди git merge або git rebase.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>
                Git merge vs git rebase vs git squash
            </div>
            <div class="collapsible-body">
                В git є 2 принципи переміщення змін з однієї бренчі в іншу - merge and the rebase. Обидві команди
                служать одній і ті ж меті. Проте є принципова різниця в тому, як вони працюють.
                <strong>Git merge</strong><br/>
                Git merge створює новий коміт об'єднання, git rebase переміщує або об'єднує зміни, змінюючи історію
                комітів.
                <p>Важливо використовувати <strong>git rebase</strong> лише для локальних гілок, оскільки вона може
                    переписати історію, що може створити конфлікти у віддалених гілках.</p>
                git rebase використовується для інтеграції змін з однієї гілки в іншу, переміщаючи або об'єднуючи
                коміти. Він допомагає підтримувати лінійну історію проекту, зробивши її більш чистою, ніж традиційне
                злиття. Зазвичай використовується для оновлення гілки функцій із змінами з основної гілки.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як створити та застосувати теги в Git і
                для чого вони використовуються?
            </div>
            <div class="collapsible-body">
                Теги в Git - це вказівники на конкретні коміти, які дозволяють легко ідентифікувати конкретні версії
                вашого коду. Вони корисні для позначення важливих точок в історії вашого проекту, таких як випуски
                програми або стабільні версії.

                Команда:
                git tag < ім'я тегу>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке .gitignore файл і як його
                налаштувати для виключення файлів та каталогів з репозиторію?
            </div>
            <div class="collapsible-body">Файл .gitignore використовується для вказівки Git на те, які файли та каталоги
                повинні бути ігноровані при відстеженні та коміту в репозиторій. Це особливо корисно, коли ви маєте
                файли або каталоги, які ви не хочете включати в контроль версій, наприклад, файли конфігурації, файли
                локальних налаштувань або кешовані файли.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як організувати безпеку Git-репозиторію?
                Як би ви відреагували на можливі загрози?
            </div>
            <div class="collapsible-body">
                <ul>
                    <li>Регулярно робіть резервні копії</li>
                    <li>Стежіть за безпековими оновленнями</li>
                    <li>Використовуйте правила доступу:
                        Налаштуйте правила доступу до репозиторію, визначаючи, хто і як може змінювати код.
                        Використовуйте рівні доступу (read, write, admin) залежно від ролей учасників.
                    </li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як ви вирішуєте конфлікти під час злиття
                гілок в Git і які інструменти Git ви використовуєте для цього?
            </div>
            <div class="collapsible-body">
                Злиття гілок в Git із конфліктами вимагає ручного вирішення. Для вирішення конфліктів:
                <ol>
                    <li>Після злиття гілок і виникнення конфліктів, Git вказує вам на ці файли та вказує конфліктуючі
                        ділянки коду,
                        які вам потрібно вирішити. Ви редагуєте ці файли, видаляючи мітки конфлікту та виправляючи код
                        так, як вам потрібно;
                    </li>
                    <li>Після вирішення конфліктів відзначте файли як вирішені за допомогою команди git add;</li>
                    <li>Продовжте злиття за допомогою git merge --continue.</li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Чим відрізняється git pull від git fetch?
            </div>
            <div class="collapsible-body">git pull завантажує зміни з віддаленого репозиторію та об'єднує їх у поточну
                гілку. git fetch лише завантажує зміни, але не автоматично їх об'єднує, залишаючи можливість перегляду
                та ручного об'єднання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як ви відміняєте коміт, який вже був
                відправлений в віддалений репозиторій?
            </div>
            <div class="collapsible-body">Відміна коміту включає створення нового коміту, який відміняє зміни. Щоб
                відмінити відправлений коміт, використовуйте <strong>git revert < ідентифікатор-коміту ></strong> і
                потім відправте новий коміт.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Розкажіть про різницю між Git та GitHub
                (або GitLab)
            </div>
            <div class="collapsible-body">Git - це система контролю версій, тоді як GitHub та GitLab - це платформи, що
                надають хостинг для Git-репозиторіїв і додаткові можливості співпраці, такі як відстеження проблем,
                pull-реквести та інше.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке Git hook і як він може бути
                корисним у розробці?
            </div>
            <div class="collapsible-body">Git hook - це скрипт, який автоматично запускається на певних етапах життєвого
                циклу Git. Його можна використовувати для завдань, таких як попередні перевірки перед комітом,
                лінтування чи автоматичного запуску тестування, поліпшуючи розробницький процес.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>git squash command</div>
            <div class="collapsible-body">
                git squash - це команда, яка дозволяє об'єднати кілька послідовних комітів в один. Це корисно, коли ви
                хочете зберегти лише один об'єднаний коміт замість кількох малих комітів.

                Основна ідея у тому, щоб зменшити кількість комітів у історії репозиторію, роблячи її більш зрозумілою
                та легкою для розуміння.

                Щоб скористатися командою git squash, ви можете використовувати інтерактивний режим перебазування. Ось
                приклад:

                <ol>
                    <li>Виберіть команду перебазування для останніх, наприклад, 3-х комітів: <strong>git rebase -i
                        HEAD~3</strong></li>
                    <li>З'явиться текстовий редактор із списком останніх 3 комітів. Замість слова pick для всіх комітів,
                        які ви хочете об'єднати, змініть його на squash або просто s для скорочення.
                        pick abc123 Some commit message <br/>
                        squash def456 Another commit message <br/>
                        squash xyz789 Yet another commit message
                    </li>
                    <li>Збережіть зміни і закрийте редактор. Відкриється новий редактор для об'єднання повідомлень
                        комітів. Залиште той, який вам потрібен, або об'єднайте їх в одне нове повідомлення.
                    </li>
                    <li>Збережіть зміни, закрийте редактор, і Git об'єднає обрані коміти в один, залишаючи новий коміт
                        зі зміненим повідомленням.
                    </li>
                </ol>
                Зауважте, що використання git squash може вплинути на історію комітів, тому важливо враховувати це при
                використанні в спільної роботи з іншими розробниками або при роботі з гілками, які вже були
                опубліковані.
            </div>
        </li>

    </ul>

    <h5 id="principles">Principles</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>ООП</div>
            <div class="collapsible-body">
                Пропонуємо ознайомитися з основними принципами об'єктно-орієнтованого програмування – однієї з найбільш
                важливих методологій розробки, яка ґрунтується на уявленні про програму як про сукупність об'єктів,
                кожен з яких є екземпляром певного класу, а класи утворюють ієрархію наслідування.
                Об'єктно-орієнтоване програмування (ООП) включає в себе низку принципів, які допомагають створювати
                гнучкі, розширювані та підтримувані програми. Основні принципи ООП включають такі:
                <ol>
                    <li><strong>Інкапсуляція (Encapsulation)</strong>: Інкапсуляція вказує на об'єднання даних та
                        методів, які працюють з цими даними, в один об'єкт або клас. Змінні часто називаються "полями",
                        а методи - "методами". Забезпечує обмежений доступ до внутрішніх деталей об'єкта та захищає дані
                        від прямого доступу та неправильного використання.
                        Одним з визначальних факторів при проектуванні компонентів програми є приховування внутрішніх
                        даних компоненту і деталей його реалізації від інших компонентів програми та надання набору
                        методів для взаємодії з ним (API). Цей принцип є одним з чотирьох фундаментальних принципів ООП
                        і називається інкапсуляцією.
                        <br/>
                        <strong>Правильна інкапсуляція має велике значення з багатьох причин:</strong>
                        <ol>
                            <li>Вона сприяє повторному використанню компонентів: оскільки в цьому випадку компоненти
                                взаємодіють між собою лише через їх API і нечутливі до змін внутрішньої структури, вони
                                можуть використовуватись в більш широкому контексті.
                            </li>
                            <li>Інкапсуляція пришвидшує процес розробки: слабко пов'язані один з одним компоненти (тобто
                                компоненти, чий код якомога менше звертається або використовує код інших компонентів)
                                можуть розроблятися, тестуватися та доповнюватися незалежно.
                            </li>
                            <li>Правильно інкапсульовані компоненти більш зрозумілі та легше налагоджуються, що спрощує
                                підтримку програми.
                            </li>
                        </ol>
                        інкапсуляція реалізована за допомогою системи класів, які дозволяють зібрати інформацію про
                        об'єкт в одному місці; пакетів, які групують класи по певному критерію, і модифікаторів доступу,
                        якими можна позначити весь клас або його поле чи метод.

                        Всього існує чотири модифікатори доступу:
                        <ul>
                            <li><strong>public</strong> – повний доступ до сутності (полю або методу класу) з будь-якого
                                пакету;
                            </li>
                            <li><strong>protected</strong> – доступ до сутності лише для класів свого пакету і нащадків
                                класу;
                            </li>
                            <li><strong>private</strong> – доступ тільки всередині класу, в якому оголошена сутність;
                            </li>
                            <li><strong>неявний модифікатор за замовчуванням</strong> (за відсутності трьох явних) –
                                доступ до сутності лише для класів свого пакету.
                            </li>
                        </ul>
                        Для досягнення правильної інкапсуляції також необхідно надати коректний API для роботи з
                        компонентом. Наприклад, в сеттер для змінної можна включити логіку перевірки значень, які
                        передаються, або не надавати сеттери в класі взагалі, якщо клас повинен бути доступним лише для
                        читання.
                    </li>
                    <li><strong>Наслідування (Inheritance)</strong>: Спадкування дозволяє створювати новий клас на
                        основі існуючого, успадковуючи його властивості та методи. Новий клас називається "підкласом"
                        або "потомком", а клас, від якого успадковується, - "базовим класом" або "батьківським класом".
                        Дозволяє повторно використовувати код, створювати ієрархії та розширювати функціональність.
                        Наслідування є одним з найвагоміших принципів об'єктно-орієнтованого програмування, оскільки
                        воно дозволяє створювати ієрархічні структури об'єктів. Використовуючи наслідування можна
                        створити загальний клас, який буде визначати характеристики і поведінку, властиві певному набору
                        пов'язаних об'єктів. В подальшому цей клас може наслідуватися іншими, другорядними класами,
                        кожен з яких додаватиме унікальні, властиві лише йому характеристики і доповнюватиме або
                        змінюватиме поведінку базового класу.

                    </li>
                    <li><strong>Поліморфізм (Polymorphism)</strong>:
                        Поліморфізм вказує на можливість об'єктів реагувати на спільні методи, але робити це відповідно
                        до свого власного типу. Може бути реалізований через перевантаження методів та використання
                        інтерфейсів. Забезпечує заміну об'єктів їхніми схожими з точки зору використання, незалежно від
                        конкретного типу.
                        Розглядаючи поліморфізм необхідно пам'ятати, що цей принцип нерозривно пов'язаний з іншим
                        принципом ООП – наслідуванням, яке допомагає реалізувати поліморфізм. Візьмемо для прикладу
                        абстрактний клас «Автомобіль», який наслідують два конкретних класи – «Спортивний автомобіль» та
                        «Вантажний автомобіль».

                        І спортивні, і вантажні автомобілі володітимуть спільними характеристиками і матимуть можливість
                        виконувати загальні для всіх автомобілів дії, вказані в абстрактному батьківському класі, але
                        конкретна реалізація цих дій може бути різною.

                        Наприклад, загальна для всіх автомобілів дія «завестись» у спортивному автомобілі може бути
                        реалізована шляхом натискання кнопки, а у вантажного - за допомогою ключа. Один результат –
                        різні рішення. В цьому і полягає поліморфізм.

                        Більш точно, поліморфізм - один з принципів ООП, який дозволяє викликом перевизначеного методу
                        через змінну батьківського класу отримати поведінку, яка буде відповідати реальному похідному
                        класу, на який посилається ця змінна.
                    </li>
                    <li><strong>Абстракція (Abstraction)</strong>: (від лат. abstractio — виокремлення, відсторонення
                        або відділення) - Абстракція полягає в визначенні загального та необхідного набору властивостей
                        чи методів для класу, приховуючи деталі його реалізації. Спрощує складність, забезпечує
                        спрощення взаємодії та створення високорівневих концепцій.
                        В цьому і полягає абстракція: фокусування розробника на конкретних властивостях об'єкта залежить
                        від тих задач, які повинен вирішувати об'єкт. Наслідком такого підходу є те, що, якщо в
                        імперативних мовах програмісту необхідно думати в термінах комп'ютерної логіки, то в
                        об'єктно-орієнтованих мовах розробник думає в термінах проблемної сфери, в якій він розробляє
                        програму.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>Основні принципи та патерни
                проектування - SOLID
            </div>
            <div class="collapsible-body">
                <ul>
                    <li><strong>Single Responsibility Principle (Принцип єдиної відповідальності)</strong>: Кожен клас
                        повинен мати лише одну причину для зміни. Він повинен виконувати лише одну конкретну роботу.
                    </li>
                    <li>Open/Closed Principle (Принцип відкритості/закритості): Сутності (класи, модулі та ін.) повинні
                        бути відкритими для розширення, але закритими для модифікації. Додавання нового функціоналу
                        повинно бути можливим без зміни існуючого коду.
                    </li>
                    <li>Liskov Substitution Principle (Принцип підстановки Барбари Лісков): Об'єкти базового класу
                        повинні можливо без проблем підставлятися своїми похідними класами без зміни правильності
                        програми.
                    </li>
                    <li>Interface Segregation Principle (Принцип розділення інтерфейсу): Клієнти не повинні залежати від
                        інтерфейсів, які вони не використовують. Маленькі та специфічні інтерфейси краще, ніж великі
                        загальні.
                    </li>
                    <li>Dependency Inversion Principle (DIP) - це один із п'яти принципів SOLID. Він заявляє, що
                        високорівневі модулі не повинні залежати від низькорівневих модулів. Обидва типи модулів повинні
                        залежати від абстракцій, а не деталей.
                    </li>
                </ul>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Основні принципи та патерни проектування
                - KISS (Keep It Simple, Stupid)
            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Основні принципи та патерни
                проектування - DRY (Don't Repeat Yourself)
            </div>
            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Основні принципи та патерни
                проектування - YAGNI (You Ain't Gonna Need It)
            </div>
            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Основні принципи та патерни
                проектування - Law of Demeter (Принцип Деметриї)
            </div>
            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
        </li>
    </ul>

</div>
<script src="script.js"></script>
</body>
</html>