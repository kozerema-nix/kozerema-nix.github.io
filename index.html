<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" href="src/icons/xmas.ico" type="image/x-icon">
    <link rel="shortcut icon" href="src/icons/xmas.ico" type="image/x-icon">

    <!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>Technical Interview</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <nav>
        <div class="nav-wrapper">
            <a href="#" data-target="mobile-demo" class="sidenav-trigger"><i class="material-icons">menu</i></a>
            <ul class="right hide-on-med-and-down">
                <li><a href="#js">JS</a></li>
                <li><a href="#js">HTML</a></li>
            </ul>
        </div>
    </nav>

    <ul class="sidenav" id="mobile-demo">
        <li>
            <a href="#js">JS</a>
        </li>
        <li>
            <a href="#html">HTML</a>
        </li>
    </ul>
</header>
<div class="container">

    <h5 id="html">HTML</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Що таке DOCTYPE і навіщо його використовують?</div>
            <div class="collapsible-body">
                DOCTYPE (Document Type Definition) - це інструкція, яку використовують у HTML-документах для визначення типу документа та версії HTML або XHTML, якою він відповідає. Вона розміщується на самому початку HTML-коду, перед будь-якими тегами html, head, чи body.
                < !DOCTYPE html > < html lang="uk" > < head >  < body > < /html ><br>
                Основна роль DOCTYPE:
                <ol>
                    <li>
                        Визначення режиму рендерингу:

                        Деякі браузери мають різні режими рендерингу для старих версій HTML. DOCTYPE допомагає браузерам вибрати правильний режим рендерингу для забезпечення сумісності із стандартами.

                    </li>
                    <li>
                        Забезпечення сумісності:

                        Декларація DOCTYPE допомагає визначити версію HTML або XHTML, що використовується в документі. Це важливо для того, щоб браузери могли коректно відображати сторінку відповідно до відповідних стандартів.
                    </li>
                    <li>
                        Уникнення квірксів:

                        Зазначення DOCTYPE допомагає уникнути квірксів (різних режимів рендерингу), які можуть виникати при відображенні сторінки в різних браузерах.
                    </li>
                </ol>
            </div>
        </li>
        <li>
             <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                 Які основні теги структури HTML-сторінки?
             </div>
             <div class="collapsible-body">
                 <ol><li><p><code>&lt;!DOCTYPE html&gt;</code>: Визначає тип документа та версію HTML.</p></li><li><p><code>&lt;html&gt;</code>: Визначає початок та кінець HTML-документа.</p></li><li><p><code>&lt;head&gt;</code>: Містить мета-інформацію про документ, таку як заголовок, мета-теги, посилання на зовнішні ресурси (стилі, скрипти).</p></li><li><p><code>&lt;title&gt;</code>: Визначає заголовок сторінки, який відображається в заголовку вкладки браузера або на панелі завдань.</p></li><li><p><code>&lt;meta charset="UTF-8"&gt;</code>: Вказує кодування символів для сторінки, зазвичай встановлюється на UTF-8.</p></li><li><p><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>: Встановлює мета-тег для налаштування ширини екрану та масштабування на мобільних пристроях.</p></li><li><p><code>&lt;body&gt;</code>: Містить основний вміст сторінки, такий як текст, зображення, таблиці, форми та інші елементи.</p></li><li><p><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code>: Визначають заголовки різних рівнів. <code>&lt;h1&gt;</code> - найважливіший, <code>&lt;h6&gt;</code> - найменший.</p></li><li><p><code>&lt;p&gt;</code>: Визначає абзац тексту.</p></li><li><p><code>&lt;a&gt;</code>: Створює посилання на іншу сторінку або ресурс.</p></li><li><p><code>&lt;img&gt;</code>: Вставляє зображення на сторінку.</p></li><li><p><code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>: Визначають ненумерований (ul) або нумерований (ol) список та його елементи (li).</p></li><li><p><code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, <code>&lt;td&gt;</code>: Визначають таблицю та її елементи.</p></li><li><p><code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>: Визначають форму та її елементи для введення даних.</p></li><li><p><code>&lt;div&gt;</code>: Використовується для групування та стилізації інших елементів.</p></li></ol>
             </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке семантичні теги та навіщо вони потрібні? Наведіть приклади таких тегів.
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>Семантичні теги в HTML це елементи, які мають смислове значення та описують зміст, структуру та значення елементів на сторінці. Використання семантичних тегів допомагає робити HTML-код більш зрозумілим для розробників та браузерів, покращує доступність та SEO.</p><p>Основні переваги семантичних тегів:</p><ol><li><p><strong>Зрозумілість коду:</strong> Імена семантичних тегів самі по собі вказують на їхнє значення, що робить код більш зрозумілим і легким для інших розробників читати.</p></li><li><p><strong>SEO:</strong> Використання семантичних тегів може поліпшити індексацію сторінок пошуковими системами.</p></li><li><p><strong>Доступність:</strong> Семантичні теги допомагають робити веб-сайти більш доступними для користувачів з вадами зору, а також для інших асистивних технологій.</p></li></ol><p>Приклади семантичних тегів:</p><ol><li><p><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</p></li><li><p><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</p></li><li><p><code>&lt;main&gt;</code>: Визначає основний контент сторінки.</p></li><li><p><code>&lt;article&gt;</code>: Визначає незалежний, самостійний контент, який може бути повністю розміщений на іншому ресурсі.</p></li><li><p><code>&lt;section&gt;</code>: Визначає секцію документа.</p></li><li><p><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного контенту (наприклад, бічні бари, реклама).</p></li><li><p><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</p></li><li><p><code>&lt;figure&gt;</code> і <code>&lt;figcaption&gt;</code>: Визначають зображення або мультимедійний контент та його підпис.</p></li><li><p><code>&lt;time&gt;</code>: Визначає дату або час.</p></li></ol><p>Ці теги допомагають створювати структурований та змістовно збагачений HTML, що полегшує розуміння структури документа як розробниками, так і браузерами та іншими агентами.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які теги добавили в HTML5?
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>HTML5 вніс багато нових тегів і атрибутів, що значно поліпшили можливості мови та розширили функціональність веб-розробки. Ось деякі з нових тегів, які були додані в HTML5:</p><ol><li><p><strong>Семантичні блокові елементи:</strong></p><ul><li><code>&lt;article&gt;</code>: Визначає самостійний контент, який може існувати незалежно від інших частин документа.</li><li><code>&lt;section&gt;</code>: Визначає секцію документа.</li><li><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</li><li><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</li><li><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</li><li><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного контенту (наприклад, бічні бари, реклама).</li></ul></li><li><p><strong>Елементи для введення форм:</strong></p><ul><li><code>&lt;datalist&gt;</code>: Визначає список варіантів для елемента <code>&lt;input&gt;</code> з атрибутом <code>list</code>.</li><li><code>&lt;output&gt;</code>: Визначає область виведення для результатів форми.</li></ul></li><li><p><strong>Мультимедійні теги:</strong></p><ul><li><code>&lt;audio&gt;</code>: Визначає аудіо-елемент для вставки звукового контенту.</li><li><code>&lt;video&gt;</code>: Визначає відео-елемент для вставки відео-контенту.</li></ul></li><li><p><strong>Графічні теги:</strong></p><ul><li><code>&lt;canvas&gt;</code>: Визначає область, на якій можна малювати за допомогою JavaScript.</li></ul></li><li><p><strong>Теги для роботи з ресурсами:</strong></p><ul><li><code>&lt;embed&gt;</code>: Вставляє зовнішні ресурси, такі як плагіни, аудіо або відео.</li><li><code>&lt;source&gt;</code>: Вказує ресурс для вкладання у елементи <code>&lt;audio&gt;</code> та <code>&lt;video&gt;</code>.</li></ul></li><li><p><strong>Атрибути форм:</strong></p><ul><li><code>autocomplete</code>: Атрибут для управління автозаповненням полів форми.</li><li><code>placeholder</code>: Атрибут для встановлення підказки для користувача у полі введення.</li></ul></li><li><p><strong>Атрибути гіперпосилань:</strong></p><ul><li><code>download</code>: Атрибут для вказання, що посилання призначене для завантаження файлу замість переходу за ним.</li></ul></li></ol><p>Це лише деякі приклади тегів та атрибутів, які були додані в HTML5. Ці зміни спрямовані на поліпшення структури документа, роботи з мультимедіа та забезпечення більшої доступності та можливостей веб-розробникам.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке data-атрибути, в яких випадках їх використовуєте?
            </div>
            <div class="collapsible-body">
                data-атрибути - це спеціальні атрибути HTML-тегів, які починаються з префіксу data-. Вони призначені для зберігання власних даних в елементах HTML, які можуть бути використані для додаткового опису або ідентифікації елементів. Використання data-атрибутів дозволяє розробникам зберігати інформацію без втручання у стандартні атрибути. Деякі випадки використання data-атрибутів: <ol><li>JavaScript: За допомогою data-атрибутів можна зберігати дані, які JavaScript потрібно використовувати. Наприклад, для зберігання ідентифікаторів чи параметрів, які використовуються в динамічних скриптах. JavaScript може отримати значення data-action для подальших дій.</li><li>CSS: Можна використовувати data-атрибути для створення CSS-селекторів або передачі додаткових стилів. В CSS: .user[data-status="active"] {} - Це дозволить стилізувати елемент із конкретним data-атрибутом.</li><li>HTML: Інколи data-атрибути використовуються для вставки додаткової інформації, яку може використовувати браузер або інші інструменти.</li></ol> Тут data-analytics та data-location можуть вказувати на аналітичні дані для слідкування кліків та місця розташування посилання.

                Важливо пам'ятати, що data-атрибути не повинні використовуватися для зберігання інформації, яка повинна бути доступна для користувачів або врахована в пошукових системах. Вони призначені для зберігання технічної або внутрішньої інформації, яка не відображається на сторінці напряму.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
            </div>
            <div class="collapsible-body"><span>

              </span></div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
            </div>
            <div class="collapsible-body"><span>

              </span></div>
        </li>

<!--        <li>-->
<!--            <div class="collapsible-header"><i class="material-icons">filter_drama</i>-->

<!--            </div>-->
<!--            <div class="collapsible-body">-->

<!--            </div>-->
<!--        </li>-->
    </ul>

<!--    <h5 id="js">JS</h5>-->
<!--    <ul class="collapsible">-->
<!--        <li>-->
<!--            <div class="collapsible-header"><i class="material-icons">filter_drama</i>First</div>-->
<!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
<!--        </li>-->
<!--        <li>-->
<!--            <div class="collapsible-header"><i class="material-icons">place</i>Second</div>-->
<!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
<!--        </li>-->
<!--        <li>-->
<!--            <div class="collapsible-header"><i class="material-icons">whatshot</i>Third</div>-->
<!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
<!--        </li>-->
<!--    </ul>-->

        <h5 id="js">NPM</h5>
        <ul class="collapsible">
            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Що таке NPM і для чого його використовувати?</div>
                <div class="collapsible-body">
                    NPM (Node Package Manager) є системою управління пакетами для JavaScript, яка дозволяє розробникам легко встановлювати, оновлювати та використовувати залежності у своїх проектах. В основному, використовується для управління бібліотеками та іншими залежностями, які використовуються в проектах на базі Node.js.
                    Декілька ключових причин для використання NPM:

                    <ol>
                        <li><strong>Установка пакетів:</strong> NPM дозволяє легко встановлювати пакети (бібліотеки, фреймворки, інструменти) для використання в проекті.</li>
                        <li><strong>Управління версіями:</strong> NPM дозволяє вказувати версії пакетів, щоб гарантувати сумісність та уникнути проблем залежностей.</li>
                        <li><strong>Сценарії:</strong> Ви можете визначити різні сценарії (scripts) для автоматизації завдань, таких як запуск сервера, збірка проекту чи тестування.</li>
                        <li><strong>Пакетні файли та конфігурації:</strong> NPM дозволяє визначити пакетні файли та конфігурації, які допомагають у встановленні та налаштуванні проекту.</li>
                        <li><strong>Глобальні та локальні пакети:</strong> NPM дозволяє встановлювати пакети глобально для доступу з будь-якого місця, або локально для конкретного проекту.</li>
                    </ol>
                </div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Глобальна та локальна установка пакетів за допомогою NPM</div>
                <div class="collapsible-body">
                    Глобальна установка пакетів NPM означає, що пакет встановлюється на рівні системи та може бути використаний в будь-якому проекті. Це зазвичай використовується для інструментів командного рядка. Локальна установка, навпаки, встановлює пакет лише в межах поточного каталогу проекту. Це гарантує, що різні проекти не взаємодіють між собою через різні версії пакетів.
                    Для глобальної установки використовується команда npm install -g, а для локальної - npm install. Наприклад, глобальна установка може бути корисною для інсталяції інструментів командного рядка, таких як create-react-app, які використовуються на рівні системи. Локальна установка, навпаки, дозволяє встановлювати бібліотеки, які використовуються тільки в межах конкретного проекту, такі як бібліотеки для розробки на React.js.
                    Локальні пакети використовуються для забезпечення залежностей конкретного проекту. Це дозволяє уникнути конфліктів версій між різними проектами.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Файл Package.json, його функції</div>
                <div class="collapsible-body">

                    <p>Package.json - це ключовий файл у проектах Node.js, який виступає як файл маніфесту. Він містить метадані, що стосуються проекту, і включає в себе властивості, такі як ім'я, версія, опис, автор та ліцензія.</p>

                    <p>Також він перераховує залежності, необхідні для роботи додатка. Вони вказуються разом зі своїми відповідними версіями у розділах "dependencies" чи "devDependencies". Перший містить пакети, необхідні для продакшн, тоді як другий для розробки.</p>

                    <p>Розділ "scripts" визначає скорочення команд, які можна виконати за допомогою npm. Наприклад, скрипт "start" зазвичай запускає додаток.</p>

                    <p>Додатково, файл може містити конфігураційні дані для інструментів, що використовуються у вашому проекті у розділі "config", власні поля даних у "private" та вказати основну точку входу вашого додатка у "main".</p>
                </div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Як оновити пакет за лопомогою NPM?</div>
                <div class="collapsible-body">
                    Щоб оновити пакет за допомогою NPM, спочатку потрібно перевірити застарілі пакети. Використовуйте команду "npm outdated" у терміналі. Це виведе список всіх пакетів, для яких доступні нові версії. Щоб оновити конкретний пакет, використовуйте команду "npm update [ім'я-пакету]". Якщо ви хочете оновити всі пакети, просто використовуйте "npm update" без вказання імені пакету. Важливо враховувати, що це оновить лише мінорні та патч-релізи відповідно до правил семантичної версії. Для оновлення мажорних версій вам потрібно використовувати команду "npm install [ім'я-пакету]@latest". Завжди пам'ятайте перевіряти оновлення, переглядаючи файл package.json або використовуючи "npm outdated" знову.
                </div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Як керувати версіями пакетів в NPM?</div>
                <div class="collapsible-body">NPM дозволяє управляти версіями пакетів за допомогою семантичного версіонування (semver). У вашому файлі package.json залежності перераховуються з їх версіями. Символ каретки (^) чи тильда (~) перед номером версії вказує на гнучкість у використанні новіших мінорних чи патч-версій відповідно. Щоб встановити конкретну версію, ви можете використовувати "npm install [пакет]@[версія]". Для оновлення до останньої мажорної версії команда "npm outdated" показує пакети, які потребують оновлення, і "npm update [пакет]" оновлює їх. Якщо декілька проектів вимагають різних версій, розгляньте використання nvm від npm чи Docker для ізольованих середовищ.</div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Як використовується Семантичне версіонування у проекті?</div>
                <div class="collapsible-body">Семантичне версіонування, або SemVer, є системою версіонування для програмного забезпечення, яка має на меті передавати значення щодо основних змін у випуску. Вона використовує формат MAJOR.MINOR.PATCH, де кожне збільшення представляє різні типи модифікацій. Збільшення мажорної версії вказує на несумісні зміни у API, мінорної - на додання функціоналу сумісним способом, а патчу - на виправлення помилок, сумісних назад.

                    У NPM семантичне версіонування використовується для управління залежностями. Під час встановлення пакетів ви можете вказати версію за допомогою нотації SemVer. Наприклад, "^1.0.0" встановить останню мінорну або патч-версію вище 1.0.0, але нижче 2.0.0. Це дозволяє розробникам контролювати версії їх залежностей, забезпечуючи сумісність та стабільність у їх проектах.></div>
            </li>            <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як видалити пакет?</div>
            <div class="collapsible-body">

                Щоб видалити пакет за допомогою NPM, використовуйте команду "npm uninstall", за якою слідує ім'я пакету. Це видаляє його з каталогу node_modules та оновлює ваш файл package.json, відображаючи зміну. Якщо ви хочете видалити його глобально, додайте "-g". Щоб зберегти зміни в файлі package-lock.json, включіть "--save". Наприклад:
                <strong>npm uninstall < ім'я-пакету></strong><br />. Це видаляє локально. Для глобального видалення: <strong>npm uninstall -g < ім'я-пакету></strong>. <br />А для оновлення package-lock.json: <strong>npm uninstall --save < ім'я-пакету></strong>


            </div>
        </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Для чого використовуємо .npmignore файл?</div>
                <div class="collapsible-body">
                    Файл .npmignore використовується у проектах Node.js для вказівки файлів чи каталогів, які не повинні бути включені до пакету, який надсилається до реєстру npm. Він функціонує подібно до файлу .gitignore, але спеціально для npm-пакетів. Якщо в каталозі не існує файлу .npmignore, npm використовує файл .gitignore замість нього. Однак у разі наявності обох файлів .npmignore має перевагу.

                    Це дозволяє розробникам зберігати певні файли у своєму локальному репозиторії, не включаючи їх у опублікований пакет, такі як тести, README-файли чи інші необов'язкові файли.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Що як пакет, який використовується в проекті, застарів чи перестав підтримуватись?</div>
                <div class="collapsible-body">
                    У ситуації, коли NPM-пакет, від якого залежить проект, є застарілим або більше не підтримується, я б спочатку оцінив вплив цього застаріння. Якщо це критично для проекту, я шукав би альтернативи. Зазвичай в обширному репозитарії NPM можна знайти схожі пакети.

                    Якщо підходящу заміну знайти не вдається, і пакет є важливим, іншою опцією може бути створення форку оригінального пакету і його підтримка. Це передбачає розуміння кодової бази та виправлення будь-яких проблем чи вразливостей, що виникають. Однак це слід розглядати як останній захід через час та ресурси, які він вимагає.

                    Ще одним підходом може бути повне вилучення залежності, якщо вона не приносить значущої користі. Це може потребувати рефакторингу деяких частин проекту, але може призвести до більш оптимізованої та ефективної кодової бази.

                    Незалежно від обраного шляху важливо тщательно тестувати всі зміни, щоб вони не вводили нових помилок чи вразливостей у проект.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між npm та yarn</div>
                <div class="collapsible-body">
                    NPM і Yarn - обидва менеджери пакетів для JavaScript, але вони відрізняються декількома способами. NPM автоматично встановлює пакет, коли ви його додаєте, тоді як Yarn додає пакет лише до списку, поки ви не виконаєте 'yarn install'. Це робить Yarn швидшим, оскільки уникнуто непотрібних встановлень. Крім того, Yarn вводить офлайн-режим, який кешує кожен завантажений пакет, дозволяючи встановлення без підключення до Інтернету. Також він перевіряє контрольні суми перед встановленням пакетів для забезпечення їх цілісності. Однак NPM має широку підтримку спільноти завдяки своєму тривалішому існуванню, що робить його більш надійним для старіших проектів.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між “dependencies” and “devDependencies” in package.json?</div>
                <div class="collapsible-body">
                    У файлі package.json "dependencies" та "devDependencies" мають різні цілі. "Dependencies" включають модулі, які необхідні для роботи вашого проекту в продакшн-середовищі. Вони встановлюються, коли ви або інший користувач виконує команду "npm install" без будь-яких аргументів.

                    З іншого боку, "devDependencies" включають модулі, які потрібні лише під час розробки, а не в продакшн-середовищі. Сюди входять фреймворки для тестування, засоби збірки тощо. Вони встановлюються лише тоді, коли ви виконуєте "npm install" у своєму локальному середовищі розробки, а не коли користувачі встановлюють ваш пакет. Якщо ви використовуєте команду "npm install --production", це ігнорує devDependencies.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
                <div class="collapsible-body">
                    Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you handle security vulnerabilities in your NPM packages?</div>
                <div class="collapsible-body">
                    Для роботи з вразливостями безпеки у пакетах NPM я використовую кілька стратегій. По-перше, я переконуюся, що всі мої пакети оновлені за допомогою команди 'npm update'. Це тому, що оновлення часто містять патчі для відомих вразливостей. По-друге, я використовую npm audit, вбудований інструмент, який сканує вразливості і надає детальні звіти. Він також пропонує виправлення, якщо такі є. Для автоматизованого сканування вразливостей я інтегрую інструменти, такі як Snyk чи Dependabot, у мій CI/CD конвеєр. Ці інструменти надають миттєві сповіщення про нові вразливості і автоматизують процес оновлення небезпечних залежностей. Нарешті, я дотримуюся кращих практик, таких як не запускання npm з правами root та уникання використання застарілих чи необслуговуваних пакетів.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you manually change the version of a package using NPM?</div>
                <div class="collapsible-body">
                    Щоб вручну змінити версію пакету за допомогою NPM, потрібно внести зміни у файл package.json. Цей файл містить метадані про ваш проект, включаючи залежності та їх версії. Для зміни версії пакету знайдіть його запис у розділі "dependencies" або "devDependencies" та відповідно змініть номер версії.

                    Наприклад, якщо ви хочете змінити версію Express з 4.16.3 на 4.17.0, знайдіть рядок "express": "^4.16.3" і змініть його на "express": "^4.17.0".

                    Після внесення змін у файл package.json виконайте команду `npm install` у вашому терміналі. Ця команда оновить ваш каталог node_modules на основі змін, внесених у файл package.json. Якщо виникнуть конфлікти між версіями, npm генерує повідомлення про помилку. Розберіть їх перед продовженням.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Як вберегти певний файл від того, що його апдейтнуть?</div>
                <div class="collapsible-body">
                    Щоб уникнути оновлення конкретних пакетів у NPM, ви можете скористатися командою "npm shrinkwrap". Це створить файл 'npm-shrinkwrap.json', який фіксує версії кожного пакету та його залежностей у вашому проекті. Коли цей файл присутній, команда 'npm install' встановлюватиме точні версії з 'npm-shrinkwrap.json', ігноруючи будь-які новіші версії, вказані у 'package.json'. Замість цього ви також можете вказати точний номер версії пакету у файлі 'package.json'. Якщо ви видалите символи каретки (^) чи тильда (~) перед номером версії, npm буде використовувати саме вказану версію під час оновлень.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
                <div class="collapsible-body">
                    Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">filter_drama</i>В чому різниця команд npm і npx?</div>
                <div class="collapsible-body">
                    npm та npx - це обидві інструменти, пов'язані з Node.js та управлінням пакетами, але вони мають різні призначення.
                    npm (Node Package Manager):

                    npm - це менеджер пакетів, який використовується для встановлення, оновлення та керування пакетами Node.js.
                    Використовується для встановлення пакетів глобально або локально в вашому проекті.

                    Приклад встановлення пакета глобально: npm install -g example-package
                    Приклад встановлення пакетів локально в проекті: npm install package-name


                    npx:

                    npx - це інструмент, який дозволяє виконувати команди, які містяться в пакетах, не встановлюючи ці пакети глобально.
                    Зазвичай використовується для виконання одноразових або експериментальних команд.
                    Приклад використання npx для виконання команди з пакета, що не встановлено глобально: npx package-name command

                    Отже, основна різниця полягає в тому, що npm використовується для встановлення та керування пакетами, тоді як npx дозволяє виконувати команди з пакетів, не встановлюючи їх глобально.
                </div>
            </li>


        </ul>



    <h5 id="git">GIT</h5>
        <ul class="collapsible">
            <li>
                <div class="collapsible-header"><i class="material-icons">filter_drama</i>Git Reset –soft, –mixed, and –hard</div>
                <div class="collapsible-body">
                    <strong>git reset --soft < commit ></strong>

                    Команда git reset відміняє зміни, зроблені в процесі. Дозволяє перемістити HEAD (поточну версію) до визначеного коміту.<br />
                    <strong>Git Reset --soft</strong> - переносить HEAD до вибраного комміту, але залишає стейдж незмінним. Це означає, що
                    всі зміни після вказаного комміта будуть в стейджі, і ми зможемо їх закомітити знову.
                    Виглядає це так: A -- B -- C (HEAD -> main), тоді команда <strong>git reset --soft B</strong> переносить нас у: A -- B (HEAD -> main), зміни, які ми зробили
                    в коміті С - опиняться в стейджі. <br />

                    <strong>Git Reset --hard</strong> - потенційно найбільш небезпечна команда, оскільки переносить HEAD в обраний коміт, при цьому видаляє усі наступні.
                    `git reset --hard B` - тепер перемістить нас в коміт B, при цьому вибаливши всі зміни з коміту С. Зазвичай використовується, щоб повнісю стерти зміни.

                    <strong>Git Reset --mixed</strong> - дефолтна опція, переміщує HEAD до вказаного коміту, як в --soft. Якщо максимально просто - то `git reset --mixed B'
                    команда перемістить нас на версію коміт В, але зміни з С будуть як untracked changes, а не в стейджі, як ми маємо це в --soft.

                </div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>git cherry-pick</div>
                <div class="collapsible-body">

                    Команда git cherry-pick в Git використовується для застосування конкретного зобов'язання (commit) з однієї гілки до іншої. Це дозволяє перенести вибрані
                    зміни з одного коміту на інший, незалежно від того, на якій гілці вони були внесені.

                    Синтаксис команди виглядає наступним чином: <strong>git cherry-pick < commit_hash ></strong><br />
                    Основні розділи використання git cherry-pick:
                    <ol>
                        <li>Копіювання коміту на поточну гілку - git cherry-pick < commit_hash ></li>
                        <li>Копіювання кількох комітів - git cherry-pick < commit_hash1 > < commit_hash2 > ...</li>
                        <li>Автоматичне вирішення конфліктів - У разі, якщо виникнуть конфлікти при застосуванні коміту, Git повідомить про це, і вам слід вирішити конфлікти вручну.</li>
                    </ol>
                    !!! Ця команда корисна в ситуаціях, коли ви хочете <strong>перенести конкретні зміни з однієї гілки на іншу без копіювання всієї історії гілки</strong>. Важливо враховувати, що при
                    використанні git cherry-pick важливо уникати переносу змін, які вже існують на цільовій гілці, оскільки це може призвести до конфліктів.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>git fetch</div>
                <div class="collapsible-body">
                    Команда git fetch використовується для завантаження змін іншого репозиторію, але не об'єднання їх з вашим робочим каталогом або поточною гілкою.
                    Це оновлює інформацію про віддалені гілки та зобов'язання, але не змінює ваш робочий каталог.

                    Синтаксис команди виглядає так: <strong>git fetch [remote_name]</strong>, де [remote_name] - це ім'я віддаленого репозиторію. Якщо ім'я віддаленого репозиторію не вказано, Git використовує за замовчуванням origin.

                    Основні варіанти використання git fetch:
                    <ol>
                        <li>Завантаження змін з віддаленого репозиторію: git fetch</li>
                        <li>Завантаження змін з конкретного віддаленого репозиторію: git fetch [remote_name]</li>
                    </ol>
                    Після використання git fetch, ви можете переглянути зміни, що були завантажені, і при необхідності об'єднати їх з вашим робочим каталогом за допомогою команди git merge або git rebase.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>
                    Git merge vs git rebase vs git squash
                </div>
                <div class="collapsible-body">
                    В git є 2 принципи переміщення змін з однієї бренчі в іншу - merge and the rebase. Обидві команди служать одній і ті ж меті. Проте є принципова різниця в тому, як вони працюють.
                    <strong>Git merge</strong><br />
                    Git merge створює новий коміт об'єднання, git rebase переміщує або об'єднує зміни, змінюючи історію комітів.
                    <p>Важливо використовувати <strong>git rebase</strong> лише для локальних гілок, оскільки вона може переписати історію, що може створити конфлікти у віддалених гілках.</p>
                    git rebase використовується для інтеграції змін з однієї гілки в іншу, переміщаючи або об'єднуючи коміти. Він допомагає підтримувати лінійну історію проекту, зробивши її більш чистою, ніж традиційне злиття. Зазвичай використовується для оновлення гілки функцій із змінами з основної гілки.
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Як створити та застосувати теги в Git і для чого вони використовуються?</div>
                <div class="collapsible-body">
                    Теги в Git - це вказівники на конкретні коміти, які дозволяють легко ідентифікувати конкретні версії вашого коду. Вони корисні для позначення важливих точок в історії вашого проекту, таких як випуски програми або стабільні версії.

                    Команда:
                    git tag < ім'я тегу>
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Що таке .gitignore файл і як його налаштувати для виключення файлів та каталогів з репозиторію?
                </div>
                <div class="collapsible-body">Файл .gitignore використовується для вказівки Git на те, які файли та каталоги повинні бути ігноровані при відстеженні та коміту в репозиторій. Це особливо корисно, коли ви маєте файли або каталоги, які ви не хочете включати в контроль версій, наприклад, файли конфігурації, файли локальних налаштувань або кешовані файли.</div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Як організувати безпеку Git-репозиторію? Як би ви відреагували на можливі загрози?</div>
                <div class="collapsible-body">
                    <ul>
                        <li>Регулярно робіть резервні копії</li>
                        <li>Стежіть за безпековими оновленнями</li>
                        <li>Використовуйте правила доступу:
                            Налаштуйте правила доступу до репозиторію, визначаючи, хто і як може змінювати код. Використовуйте рівні доступу (read, write, admin) залежно від ролей учасників.</li>
                    </ul>
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Як ви вирішуєте конфлікти під час злиття гілок в Git і які інструменти Git ви використовуєте для цього?</div>
                <div class="collapsible-body">
                    Злиття гілок в Git із конфліктами вимагає ручного вирішення. Для вирішення конфліктів:
                    <ol>
                        <li>Після злиття гілок і виникнення конфліктів, Git вказує вам на ці файли та вказує конфліктуючі ділянки коду,
                            які вам потрібно вирішити. Ви редагуєте ці файли, видаляючи мітки конфлікту та виправляючи код так, як вам потрібно;</li>
                        <li>Після вирішення конфліктів відзначте файли як вирішені за допомогою команди git add;</li>
                        <li>Продовжте злиття за допомогою git merge --continue.</li>
                    </ol>
                </div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Чим відрізняється git pull від git fetch?</div>
                <div class="collapsible-body">git pull завантажує зміни з віддаленого репозиторію та об'єднує їх у поточну гілку. git fetch лише завантажує зміни, але не автоматично їх об'єднує, залишаючи можливість перегляду та ручного об'єднання.</div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Як ви відміняєте коміт, який вже був відправлений в віддалений репозиторій?</div>
                <div class="collapsible-body">Відміна коміту включає створення нового коміту, який відміняє зміни. Щоб відмінити відправлений коміт, використовуйте <strong>git revert < ідентифікатор-коміту ></strong> і потім відправте новий коміт.</div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Розкажіть про різницю між Git та GitHub (або GitLab)</div>
                <div class="collapsible-body">Git - це система контролю версій, тоді як GitHub та GitLab - це платформи, що надають хостинг для Git-репозиторіїв і додаткові можливості співпраці, такі як відстеження проблем, pull-реквести та інше.</div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Що таке Git hook і як він може бути корисним у розробці?</div>
                <div class="collapsible-body">Git hook - це скрипт, який автоматично запускається на певних етапах життєвого циклу Git. Його можна використовувати для завдань, таких як попередні перевірки перед комітом, лінтування чи автоматичного запуску тестування, поліпшуючи розробницький процес.</div>
            </li>

            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>git squash command</div>
                <div class="collapsible-body">
                    git squash - це команда, яка дозволяє об'єднати кілька послідовних комітів в один. Це корисно, коли ви хочете зберегти лише один об'єднаний коміт замість кількох малих комітів.

                    Основна ідея у тому, щоб зменшити кількість комітів у історії репозиторію, роблячи її більш зрозумілою та легкою для розуміння.

                    Щоб скористатися командою git squash, ви можете використовувати інтерактивний режим перебазування. Ось приклад:

                    <ol>
                        <li>Виберіть команду перебазування для останніх, наприклад, 3-х комітів: <strong>git rebase -i  HEAD~3</strong></li>
                        <li>З'явиться текстовий редактор із списком останніх 3 комітів. Замість слова pick для всіх комітів, які ви хочете об'єднати, змініть його на squash або просто s для скорочення.
                            pick abc123 Some commit message <br />
                            squash def456 Another commit message <br />
                            squash xyz789 Yet another commit message
                        </li>
                        <li>Збережіть зміни і закрийте редактор. Відкриється новий редактор для об'єднання повідомлень комітів. Залиште той, який вам потрібен, або об'єднайте їх в одне нове повідомлення.</li>
                        <li>Збережіть зміни, закрийте редактор, і Git об'єднає обрані коміти в один, залишаючи новий коміт зі зміненим повідомленням.</li>
                    </ol>
                    Зауважте, що використання git squash може вплинути на історію комітів, тому важливо враховувати це при використанні в спільної роботи з іншими розробниками або при роботі з гілками, які вже були опубліковані.
                </div>
            </li>

        </ul>

        <h5 id="principles">Principles</h5>
        <ul class="collapsible">
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>ООП</div>
                <div class="collapsible-body">
                    Пропонуємо ознайомитися з основними принципами об'єктно-орієнтованого програмування – однієї з найбільш важливих методологій розробки, яка ґрунтується на уявленні про програму як про сукупність об'єктів, кожен з яких є екземпляром певного класу, а класи утворюють ієрархію наслідування.
                    Об'єктно-орієнтоване програмування (ООП) включає в себе низку принципів, які допомагають створювати гнучкі, розширювані та підтримувані програми. Основні принципи ООП включають такі:
                    <ol>
                        <li><strong>Інкапсуляція (Encapsulation)</strong>: Інкапсуляція вказує на об'єднання даних та методів, які працюють з цими даними, в один об'єкт або клас. Змінні часто називаються "полями", а методи - "методами". Забезпечує обмежений доступ до внутрішніх деталей об'єкта та захищає дані від прямого доступу та неправильного використання.
                            Одним з визначальних факторів при проектуванні компонентів програми є приховування внутрішніх даних компоненту і деталей його реалізації від інших компонентів програми та надання набору методів для взаємодії з ним (API). Цей принцип є одним з чотирьох фундаментальних принципів ООП і називається інкапсуляцією.
                            <br />
                            <strong>Правильна інкапсуляція має велике значення з багатьох причин:</strong>
                            <ol>
                                <li>Вона сприяє повторному використанню компонентів: оскільки в цьому випадку компоненти взаємодіють між собою лише через їх API і нечутливі до змін внутрішньої структури, вони можуть використовуватись в більш широкому контексті.</li>
                                <li>Інкапсуляція пришвидшує процес розробки: слабко пов'язані один з одним компоненти (тобто компоненти, чий код якомога менше звертається або використовує код інших компонентів) можуть розроблятися, тестуватися та доповнюватися незалежно.</li>
                                <li>Правильно інкапсульовані компоненти більш зрозумілі та легше налагоджуються, що спрощує підтримку програми.</li>
                            </ol>
                            інкапсуляція реалізована за допомогою системи класів, які дозволяють зібрати інформацію про об'єкт в одному місці; пакетів, які групують класи по певному критерію, і модифікаторів доступу, якими можна позначити весь клас або його поле чи метод.

                            Всього існує чотири модифікатори доступу:
                            <ul>
                                <li><strong>public</strong> – повний доступ до сутності (полю або методу класу) з будь-якого пакету;</li>
                                <li><strong>protected</strong> – доступ до сутності лише для класів свого пакету і нащадків класу;</li>
                                <li><strong>private</strong> – доступ тільки всередині класу, в якому оголошена сутність;</li>
                                <li><strong>неявний модифікатор за замовчуванням</strong> (за відсутності трьох явних) – доступ до сутності лише для класів свого пакету.</li>
                            </ul>
                            Для досягнення правильної інкапсуляції також необхідно надати коректний API для роботи з компонентом. Наприклад, в сеттер для змінної можна включити логіку перевірки значень, які передаються, або не надавати сеттери в класі взагалі, якщо клас повинен бути доступним лише для читання.
                        </li>
                        <li><strong>Наслідування (Inheritance)</strong>: Спадкування дозволяє створювати новий клас на основі існуючого, успадковуючи його властивості та методи. Новий клас називається "підкласом" або "потомком", а клас, від якого успадковується, - "базовим класом" або "батьківським класом". Дозволяє повторно використовувати код, створювати ієрархії та розширювати функціональність.
                            Наслідування є одним з найвагоміших принципів об'єктно-орієнтованого програмування, оскільки воно дозволяє створювати ієрархічні структури об'єктів. Використовуючи наслідування можна створити загальний клас, який буде визначати характеристики і поведінку, властиві певному набору пов'язаних об'єктів. В подальшому цей клас може наслідуватися іншими, другорядними класами, кожен з яких додаватиме унікальні, властиві лише йому характеристики і доповнюватиме або змінюватиме поведінку базового класу.

                        </li>
                        <li><strong>Поліморфізм (Polymorphism)</strong>:
                            Поліморфізм вказує на можливість об'єктів реагувати на спільні методи, але робити це відповідно до свого власного типу. Може бути реалізований через перевантаження методів та використання інтерфейсів. Забезпечує заміну об'єктів їхніми схожими з точки зору використання, незалежно від конкретного типу.
                            Розглядаючи поліморфізм необхідно пам'ятати, що цей принцип нерозривно пов'язаний з іншим принципом ООП – наслідуванням, яке допомагає реалізувати поліморфізм. Візьмемо для прикладу абстрактний клас «Автомобіль», який наслідують два конкретних класи – «Спортивний автомобіль» та «Вантажний автомобіль».

                            І спортивні, і вантажні автомобілі володітимуть спільними характеристиками і матимуть можливість виконувати загальні для всіх автомобілів дії, вказані в абстрактному батьківському класі, але конкретна реалізація цих дій може бути різною.

                            Наприклад, загальна для всіх автомобілів дія «завестись» у спортивному автомобілі може бути реалізована шляхом натискання кнопки, а у вантажного - за допомогою ключа. Один результат – різні рішення. В цьому і полягає поліморфізм.

                            Більш точно, поліморфізм - один з принципів ООП, який дозволяє викликом перевизначеного методу через змінну батьківського класу отримати поведінку, яка буде відповідати реальному похідному класу, на який посилається ця змінна.
                        </li>
                        <li><strong>Абстракція (Abstraction)</strong>: (від лат. abstractio — виокремлення, відсторонення або відділення) - Абстракція полягає в визначенні загального та необхідного набору властивостей чи методів для класу, приховуючи деталі його реалізації. Спрощує складність, забезпечує спрощення взаємодії та створення високорівневих концепцій.
                            В цьому і полягає абстракція: фокусування розробника на конкретних властивостях об'єкта залежить від тих задач, які повинен вирішувати об'єкт. Наслідком такого підходу є те, що, якщо в імперативних мовах програмісту необхідно думати в термінах комп'ютерної логіки, то в об'єктно-орієнтованих мовах розробник думає в термінах проблемної сфери, в якій він розробляє програму.
                        </li>
                    </ol>
                </div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">filter_drama</i>Основні принципи та патерни проектування - SOLID</div>
                <div class="collapsible-body">
                    <ul>
                        <li><strong>Single Responsibility Principle (Принцип єдиної відповідальності)</strong>: Кожен клас повинен мати лише одну причину для зміни. Він повинен виконувати лише одну конкретну роботу.</li>
                        <li>Open/Closed Principle (Принцип відкритості/закритості): Сутності (класи, модулі та ін.) повинні бути відкритими для розширення, але закритими для модифікації. Додавання нового функціоналу повинно бути можливим без зміни існуючого коду.</li>
                        <li>Liskov Substitution Principle (Принцип підстановки Барбари Лісков): Об'єкти базового класу повинні можливо без проблем підставлятися своїми похідними класами без зміни правильності програми.</li>
                        <li>Interface Segregation Principle (Принцип розділення інтерфейсу): Клієнти не повинні залежати від інтерфейсів, які вони не використовують. Маленькі та специфічні інтерфейси краще, ніж великі загальні.</li>
                        <li>Dependency Inversion Principle (DIP) - це один із п'яти принципів SOLID. Він заявляє, що високорівневі модулі не повинні залежати від низькорівневих модулів. Обидва типи модулів повинні залежати від абстракцій, а не деталей.</li>
                    </ul>
                </div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">place</i>Основні принципи та патерни проектування - KISS (Keep It Simple, Stupid)</div>
                <div class="collapsible-body">

                </div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Основні принципи та патерни проектування - DRY (Don't Repeat Yourself)</div>
                <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Основні принципи та патерни проектування - YAGNI (You Ain't Gonna Need It)</div>
                <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
            </li>
            <li>
                <div class="collapsible-header"><i class="material-icons">whatshot</i>Основні принципи та патерни проектування - Law of Demeter (Принцип Деметриї)</div>
                <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
            </li>
        </ul>

</div>
<script src="script.js"></script>
</body>
</html>