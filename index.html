<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" href="src/icons/xmas.ico" type="image/x-icon">
    <link rel="shortcut icon" href="src/icons/xmas.ico" type="image/x-icon">

    <!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>Technical Interview</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
            integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <nav>
        <div class="nav-wrapper">
            <a href="#" data-target="mobile-demo" class="sidenav-trigger"><i class="material-icons">menu</i></a>
            <ul class="right hide-on-med-and-down">
                <li><a href="#js">JS</a></li>
                <li><a href="#js">HTML</a></li>
            </ul>
        </div>
    </nav>

    <ul class="sidenav" id="mobile-demo">
        <li>
            <a href="#js">JS</a>
        </li>
        <li>
            <a href="#html">HTML</a>
        </li>
    </ul>
</header>
<div class="container">

    <h5 id="js">JS</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Замикання (closure)
            </div>
            <div class="collapsible-body">
                <p>
                    Замикання (closure) в JavaScript - це механізм, за допомогою якого функція має доступ до змінних з зовнішнього області
                    видимості, навіть після того, як зовнішня функція вже виконана. Замикання виникають, коли внутрішня функція зберігає
                    посилання на змінні з області видимості зовнішньої функції.</p>
                <p>Ось приклад, як можна створити замикання в JavaScript і як їх можна використати:</p>
                <pre>
                    function outerFunction() {
                        let outerVariable = 'I am from the outer function';

                        function innerFunction() {
                            console.log(outerVariable); // Внутрішня функція має доступ до змінної зовнішньої функції
                        }

                        return innerFunction;
                    }

                    const closureExample = outerFunction();
                    closureExample(); // Output: I am from the outer function
                </pre>
                <p>У цьому прикладі innerFunction - це замикання. Вона має доступ до змінної outerVariable, яка була оголошена у функції
                    outerFunction, навіть після того, як outerFunction вже викликана і завершила свою роботу.</p>

                <p>
                    Ще один, доволі прагматичний та начоний приклад, що пояснює замикання в JavaScript - це використання
                    замикання для створення лічильника (counter). У цьому випадку
                    замикання допомагає зберігати стан лічильника і забезпечує можливість зміни його значення ззовні.</p>

                <pre>
                    function createCounter() {
                        let count = 0; // Локальна змінна, яка буде доступна внутрішній функції

                        function increment() {
                            count++; // Збільшуємо значення лічильника на 1
                            console.log(count); // Виводимо поточне значення лічильника
                        }

                        function decrement() {
                            count--; // Зменшуємо значення лічильника на 1
                            console.log(count); // Виводимо поточне значення лічильника
                        }

                        return {
                            increment: increment,
                            decrement: decrement
                        };
                    }

                    const counter = createCounter();

                    counter.increment(); // Output: 1
                    counter.increment(); // Output: 2
                    counter.decrement(); // Output: 1

                </pre>

                <p>У цьому прикладі функція createCounter створює дві локальні функції: increment та decrement, які мають доступ до змінної
                    count, оголошеної у тілі зовнішньої функції. При кожному виклику increment або decrement змінна count збільшується або
                    зменшується на 1 відповідно, а поточне значення лічильника виводиться в консоль.</p>
                <p>Коли ми викликаємо createCounter(), вона повертає об'єкт з методами increment та decrement, які дозволяють нам
                    маніпулювати лічильником. Кожен об'єкт, створений за допомогою createCounter(), має свій власний екземпляр лічильника,
                    що дозволяє нам мати багато незалежних лічильників у нашому коді.</p>

                <p>Замикання в JavaScript дійсно мають кілька корисних властивостей і застосувань:</p>

                <ol>
                    <li>
                        <b>Створення приватних даних</b>
                        <p>Замикання дозволяють створювати змінні, які не доступні ззовні. У випадку лічильника, який ми розглядали раніше,
                            змінна count є приватною і недоступною для зміни або доступу ззовні. Це дозволяє приховати деякі деталі
                            реалізації і забезпечити безпеку даних.</p>
                    </li>
                    <li>
                        <b>Ізольовані області видимості</b>
                        <p>Замикання мають свою власну область видимості, що дозволяє уникнути конфліктів імен та забезпечити ізоляцію
                            змінних та функцій. Це дозволяє створювати чистий і організований код.</p>
                    </li>
                    <li>
                        <b>Реалізація функціонального підходу до програмування</b>
                        <p>Замикання є однією з ключових концепцій у функціональному програмуванні. Вони дозволяють передавати функції як
                            аргументи, повертати функції як результати та створювати нові функції на основі існуючих. Це зроблює код більш
                            гнучким, зрозумілим та повторно використовуваним.</p>
                    </li>
                    <li>
                        <b>Створення модулів</b>
                        <p>Замикання часто використовуються для створення модульної структури в JavaScript. Модулі дозволяють організувати
                            код у логічні блоки, які можна повторно використовувати та підтримувати. Кожен модуль може мати свою власну
                            область видимості, що дозволяє уникнути конфліктів імен і забезпечити безпеку даних.</p>
                    </li>
                </ol>
                <p>В цілому, замикання - це потужний механізм в JavaScript, який дозволяє підтримувати приватні дані, створювати модульну
                    структуру, реалізовувати функціональний підхід до програмування і забезпечувати безпеку даних у вашому коді.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке scope в js?
            </div>
            <div class="collapsible-body">
                <p>У JavaScript "scope" визначає область видимості змінних. В залежності від того, де ви визначаєте змінну, вона може бути
                    доступна лише в певній області коду. Є три типи scope в JavaScript:</p>
                <ol>
                    <li>
                        <b></b>
                        <p></p>
                        <pre></pre>
                    </li>
                </ol>
                <p>Зверніть увагу, що let та const використовують блочну область видимості, що робить їхню поведінку більш передбачуваною,
                    особливо у вкладених блоках.</p>
                <p>
                    Змінні, оголошені з допомогою ключового слова var, мають функціональний scope, а не блочний, що може призвести до деяких
                    проблем, особливо коли мова йде про вкладені функції або цикли. Ось декілька прикладів проблем, що можуть виникнути при
                    використанні var:</p>
                <ol>
                    <li>
                        <b>мінні, оголошені з var, можуть бути перекриті в середині функцій:</b>
                        <pre>
                            var x = 10;

                            function printX() {
                                var x = 20;
                                console.log(x); // Виведе 20, оскільки x перекривається в середині функції
                            }

                            printX();
                            console.log(x); // Виведе 10, оскільки зовнішній x не змінюється
                        </pre>
                    </li>
                    <li>
                        <b>Змінні, оголошені з var, можуть "витікати" за межі блоків:</b>
                        <pre>
                            if (true) {
                                var y = 30;
                            }

                            console.log(y); // Виведе 30, оскільки y витікає за межі блока
                        </pre>
                    </li>
                    <li>
                        <b>Проблеми в циклах:</b>
                        <pre>
                            for (var i = 0; i < 3; i++) {
                                setTimeout(function() {
                                    console.log(i); // Виведе 3, 3, 3, оскільки і вже має значення 3
                                }, 1000);
                            }
                        </pre>
                        <p>У цьому випадку, через те, що i вже має значення 3, коли функція setTimeout викликається, вона виводить 3 тричі.
                            Це трапляється через те, що i має функціональний scope, а не блочний, і цикл завершується, поки i не стає
                            більшим за 3.</p>
                    </li>
                </ol>
                <p>Ці проблеми з scope можуть призвести до неочікуваного поведінки вашої програми, тому рекомендується використовувати let
                    або const замість var, оскільки вони мають блочний scope і зменшують ймовірність виникнення таких проблем.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке hoisting в JS?
            </div>
            <div class="collapsible-body">
                <p>Підняття" (hoisting) - це механізм в JavaScript, який дозволяє визначати змінні та функції перед їх фактичним визначенням
                    у коді. В результаті цього змінні можуть використовуватись до їх оголошення, але зі значенням undefined. Функції можуть
                    бути викликані до їх оголошення.</p>
                <p>Ось приклади:</p>
                <ol>
                    <li>
                        <b>Hoisting змінних:</b>
                        <pre>
                            console.log(x); // Виведе undefined, а не ReferenceError, оскільки змінна x піднята
                            var x = 5;
                        </pre>
                        <p>У цьому випадку, хоча console.log(x) знаходиться перед оголошенням змінної x, код працює, оскільки оголошення
                            змінної x "піднімається" вгору до початку виконання коду. Однак на момент виклику console.log, значення змінної
                            x ще не визначено, тому виведе undefined.</p>
                        <pre>
                           console.log(x1); // Uncaught ReferenceError: x1 is not defined
                            const x1 = 5;
                        </pre>
                    </li>
                    <li>
                        <b>Hoisting функцій:</b>
                        <pre>
                            sayHello(); // Виведе "Hello", оскільки функція піднята вгору до початку виконання коду

                            function sayHello() {
                                console.log("Hello");
                            }

                        </pre>
                        <p>У цьому випадку функція sayHello може бути викликана до її оголошення через механізм підняття. Коли викликається
                            sayHello перед оголошенням функції, JavaScript "піднімає" оголошення функції вгору до початку виконання коду,
                            тому функція може бути викликана в будь-якому місці після цього оголошення.</p>
                    </li>
                </ol>
                <p>
                    Змінні, оголошені з допомогою const та let, також мають характеристику "підняття" (hoisting), але вони не можуть бути
                    використані до їх оголошення. Також, вони мають блочний scope, що робить їхню поведінку більш передбачуваною.</p>
                <p>З arrow functions (стрілковими функціями) в JavaScript також спостерігається ефект підняття (hoisting), але вони
                    поводяться трохи інакше порівняно з звичайними функціями.</p>
                <p><b>Оголошення з arrow functions піднімаються, але не ініціалізуються:</b></p>
                <pre>
                        sayHello(); // Помилка: sayHello не є функцією

                        var sayHello = () => {
                            console.log("Hello");
                        };
                    </pre>
                <pre>
                       sayHello1(); // Помилка: sayHello1 is not defined

                        const sayHello1 = () => {
                            console.log("Hello");
                        };
                </pre>
                <p><b>Arrow functions мають lexical scope:</b></p>
                <pre>
                    var name = "John";

                    var printName = () => {
                        console.log(name);
                    };

                    printName(); // Виведе "John"
                </pre>
                <p>У цьому прикладі, arrow function printName має доступ до змінної name, оголошеної у глобальному scope. Arrow functions
                    використовують lexical scope, тому вони можуть отримувати доступ до змінних з зовнішнього контексту, де вони були
                    створені.</p>
                <p>Хоча підняття дозволяє використовувати змінні та функції перед їх оголошенням, це може призвести до неочікуваної
                    поведінки коду та збільшити його складність. Рекомендується оголошувати змінні та функції перед їх використанням для
                    кращої зрозумілості та передбачуваності коду.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Callbacks в JS
            </div>
            <div class="collapsible-body">
                <p>
                    <b>Callback (функція зворотнього виклику)</b> - це функція, яка передається в іншу функцію як аргумент і викликається
                    пізніше під час виконання програми.
                    Callbacks широко використовуються в JavaScript для реалізації асинхронного програмування та подій. Ось деякі приклади
                    використання callbacks:</p>
                <ol>
                    <li>
                        <b>Asynchronous Callbacks (Асинхронні callback-и):</b>
                        <pre>
                            function fetchData(url, callback) {
                                // Симуляція асинхронного запиту
                                setTimeout(() => {
                                    const data = { name: "John", age: 30 };
                                    callback(data); // Виклик callback-функції з отриманими даними
                                }, 1000);
                            }

                            function processData(data) {
                                console.log("Data received:", data);
                            }

                            fetchData("https://example.com/api/data", processData);

                        </pre>
                        <p>У цьому прикладі функція fetchData приймає URL і callback-функцію. Вона викликає цю callback-функцію після
                            отримання даних з сервера.</p>
                    </li>
                    <li>
                        <b>Event Handling (Обробка подій):</b>
                        <pre>
                            document.getElementById("myButton").addEventListener("click", function() {
                                console.log("Button clicked");
                            });
                        </pre>
                        <p>У цьому прикладі анонімна callback-функція передається методу addEventListener, який буде викликаний при кліку на
                            кнопку з id "myButton".</p>
                    </li>
                    <li>
                        <b>Callback Hell:</b>
                        <pre>
                            asyncFunction1(function(result1) {
                                asyncFunction2(result1, function(result2) {
                                    asyncFunction3(result2, function(result3) {
                                        // І так далі...
                                    });
                                });
                            });
                        </pre>
                        <p>Це негативний патерн використання callback-ів, коли їх занадто багато вкладено, що робить код важким для
                            розуміння та обслуговування. Для уникнення цього можна використовувати Promises або async/await.</p>
                    </li>
                </ol>
                <p>Callbacks є потужним засобом для роботи з асинхронним кодом та подіями в JavaScript, але їх слід використовувати
                    обережно, оскільки можуть виникати проблеми з читабельністю та обслуговуванням коду, особливо в разі великої
                    вкладеності.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Event Loop
            </div>
            <div class="collapsible-body">
                <p><b>Event Loop</b> - це механізм в JavaScript, який дозволяє реалізувати асинхронність. В JavaScript виконується в
                    однопотоковому середовищі, що означає, що код виконується по черзі, а не одночасно. Event Loop відповідає за управління
                    виконанням коду, обробку подій та виконання асинхронних операцій.
                </p>
                <p>Основні концепції Event Loop:</p>
                <ol>
                    <li>
                        <b>Call Stack (Стек викликів)</b>
                        <p>Це механізм, за допомогою якого JavaScript відстежує виконання функцій. Кожен раз, коли функція викликається,
                            вона додається до вершини стеку викликів, і коли функція завершується, вона видаляється зі стеку.</p>
                    </li>
                    <li>
                        <b>Heap (Куча)</b>
                        <p>Це область пам'яті, де зберігаються об'єкти та інші дані.</p>
                    </li>
                    <li>
                        <b>Callback Queue (Черга callback-ів)</b>
                        <p>Всі callback-функції, які мають бути виконані, зберігаються в цій черзі. Коли функція завершується, вона
                            перевіряє чергу callback-ів та виконує наступну функцію в черзі.</p>
                    </li>
                    <li>
                        <b>Event Loop (Петля подій)</b>
                        <p>Це цикл, який постійно перевіряє стан стеку викликів та чергу callback-ів. Якщо стек викликів порожній, а черга
                            callback-ів не порожня, Event Loop бере першу функцію з черги callback-ів та виконує її.</p>
                    </li>
                </ol>
                <p>Основна ідея Event Loop полягає в тому, що JavaScript може продовжувати виконувати код, обробляти події та виконувати
                    асинхронні операції, не блокуючи основний потік виконання. Це дозволяє створювати реактивні, швидкі та відзивчиві
                    додатки в браузері та на сервері.</p>
                <p>Event Loop існує у всіх реалізаціях JavaScript, як на стороні клієнта (браузер), так і на серверній стороні (наприклад,
                    Node.js). Так як JavaScript є однопотоковою мовою програмування, Event Loop використовується для управління виконанням
                    коду та обробки подій в цьому одному потоці виконання.</p>
                <ul>
                    <li>
                        <b>У браузері</b>
                        <p>У браузері Event Loop відповідає за виконання JavaScript-коду на сторінці, обробку подій, таких як клік мишею або
                            завантаження сторінки, та виконання асинхронних операцій, таких як запити XHR (XMLHttpRequest) або отримання
                            ресурсів.</p>
                    </li>
                    <li>
                        <b>У середовищі Node.js</b>
                        <p>У Node.js Event Loop відповідає за виконання JavaScript-коду на сервері, обробку подій, таких як запуск сервера
                            або отримання запитів від клієнтів, та виконання асинхронних операцій, таких як читання/запис в файл або
                            виконання запитів до бази даних.</p>
                    </li>
                </ul>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке this в JS?
            </div>
            <div class="collapsible-body">
                <p>У JavaScript this - це спеціальне ключове слово, яке використовується в контексті об'єкта чи функції і посилається на
                    об'єкт, з яким виконується поточний код. Точне значення this залежить від того, як викликається функція.</p>
                <p>Якщо коротко - <b>значення this визначається контекстом виконання функції</b>. Під контекстом розуміється те, як
                    викликається функція.</p>
                <p>Основні правила визначення this:</p>
                <ol>
                    <li>
                        <p><b>Глобальний контекст</b>: У глобальному контексті, поза будь-якою функцією, this вказує на глобальний об'єкт
                            (window у
                            веб-браузері, або global у Node.js).</p>
                        <p>Приклад:
                            <br>
                            console.log(this === window); // Верне true в браузері
                        </p>
                    </li>
                    <li>
                        <p><b>В контексті функції</b>: У викликаній функції this може мати різне значення, залежно від того, як викликана
                            функція.</p>
                        <ul>
                            <li><b>Стрілкові функції:</b> В стрілковій функції this залежить від зовнішнього контексту, і вона не має
                                власного this. Вона успадковує значення this з області видимості, в якій вона була створена.
                            </li>
                            <li><b>Звичайні функції:</b> В звичайній функції this може змінюватися залежно від того, як вона була викликана.
                                Наприклад, в методі об'єкта this вказує на об'єкт, до якого відноситься метод.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><b>В конструкторі</b>: У конструкторі, this вказує на новостворений об'єкт, який буде ініціалізований за
                            допомогою конструктора.</p>
                        <p>Приклад:</p>
                        <pre>
                            function Person(name) {
                                this.name = name;
                            }

                            const john = new Person('John');
                            console.log(john.name); // Output: John
                        </pre>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Методи call, apply, bind - що таке і як використовувати? (пов'язане зі this з попереднього питання)
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <b>Call</b>
                        <p>Метод call() викликає функцію з вказаним контекстом і передає аргументи як окремі параметри.</p>
                        <pre>
                            function greet(name) {
                                console.log(`Hello, ${name}! I am ${this.role}.`);
                            }

                            const context = { role: 'a developer' };
                            greet.call(context, 'John');
                            // Output: Hello, John! I am a developer.
                        </pre>
                    </li>
                    <li>
                        <b>Apply</b>
                        <p>Метод apply() робить те саме, що і call(), але приймає аргументи у вигляді масиву.</p>
                        <pre>
                            function greet(name) {
                                console.log(`Hello, ${name}! I am ${this.role}.`);
                            }

                            const context = { role: 'a developer' };
                            greet.apply(context, ['John']);
                            // Output: Hello, John! I am a developer.

                        </pre>
                    </li>
                    <li>
                        <b>Bind</b>
                        <p>Метод bind() створює нову функцію, яка буде мати вказаний контекст при виклику. Він не викликає функцію, а лише
                            повертає нову функцію зі зміненим контекстом.
                            Приклад:</p>
                        <pre>
                            function greet(name) {
                                console.log(`Hello, ${name}! I am ${this.role}.`);
                            }

                            const context = { role: 'a developer' };
                            const greetWithRole = greet.bind(context);
                            greetWithRole('John');
                            // Output: Hello, John! I am a developer.

                        </pre>
                    </li>
                </ol>
                <p>Ці методи <b>дозволяють контролювати контекст</b>>, у якому функція викликається, що є корисним у багатьох ситуаціях,
                    таких як робота з об'єктами та класами в JavaScript.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Функції вишого порядку, що таке і як використовувати?
            </div>
            <div class="collapsible-body">
                <p>Функції вищого порядку - це функції, які приймають одну або декілька функцій в якості аргументів, або повертають іншу
                    функцію як результат. Вони є потужним інструментом в програмуванні, оскільки дозволяють передавати функції як дані та
                    працювати з ними так само, як і з будь-яким іншим типом даних.</p>
                <p>Основні способи використання функцій вищого порядку:</p>
                <ol>
                    <li>
                        <strong>Прийняття функції як аргумента</strong>
                        <p>Функції можуть бути передані в якості аргументів іншим функціям. Це дозволяє зробити код більш гнучким і
                            загальним, оскільки можна передавати різні функції для різних операцій.</p>
                        <pre>
                            function operateOnArray(array, operation) {
                                return array.map(operation);
                            }

                            const numbers = [1, 2, 3, 4, 5];
                            const doubled = operateOnArray(numbers, function(x) {
                                return x * 2;
                            });
                            console.log(doubled); // Output: [2, 4, 6, 8, 10]
                        </pre>
                    </li>
                    <li>
                        <strong>Повернення функції як результату</strong>
                        <p>Функції можуть повертати інші функції як результат. Це дозволяє створювати нові функції на основі умов або
                            параметрів, які передаються в основну функцію.</p>
                        <pre>
                            function createMultiplier(factor) {
                                return function(x) {
                                    return x * factor;
                                };
                            }

                            const double = createMultiplier(2);
                            console.log(double(5)); // Output: 10

                        </pre>
                    </li>
                    <li>
                        <strong>Функції зворотного виклику (callback functions)</strong>
                        <p>Функції вищого порядку часто використовуються в якості зворотних викликів. Це означає передачу функції як
                            аргумента в іншу функцію, яка буде викликана пізніше або при виконанні певної умови.</p>
                        <pre>
                            function fetchData(url, callback) {
                                // Симулюємо отримання даних з сервера
                                setTimeout(function() {
                                    const data = { name: 'John', age: 30 };
                                    callback(data);
                                }, 1000);
                            }

                            fetchData('https://example.com/data', function(data) {
                                console.log(data); // Output: { name: 'John', age: 30 }
                            });
                        </pre>
                    </li>
                </ol>
                <p>Функції вищого порядку допомагають робити код більш зрозумілим, модульним і повторно використовуваним, а також
                    забезпечують більшу гнучкість в програмуванні, дозволяючи працювати з функціями як зі значеннями.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Set, WeakSet
            </div>
            <div class="collapsible-body">
                <p>
                    <b>Set і WeakSet</b> - це дві структури даних в JavaScript, які дозволяють зберігати унікальні значення. Основна різниця
                    між ними полягає в тому, як вони використовують пам'ять.
                </p>
                <ol>
                    <li>
                        <b>Set</b>
                        <ul>
                            <li>
                                Set - це колекція унікальних значень будь-якого типу, які можна легко додавати, видаляти та перевіряти на
                                наявність.
                            </li>
                            <li>
                                Приклад використання Set:

                                <pre>
                                    const mySet = new Set();

                                    mySet.add(1);
                                    mySet.add(2);
                                    mySet.add(3);
                                    mySet.add(1); // Дублікат не буде доданий

                                    console.log(mySet); // Set { 1, 2, 3 }

                                    console.log(mySet.has(2)); // true

                                    mySet.delete(2);
                                    console.log(mySet); // Set { 1, 3 }

                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <b>WeakSet</b>
                        <ul>
                            <li>WeakSet - це спеціальний тип Set, де значення можуть бути тільки об'єктами, а не примітивними типами.</li>
                            <li>Він не утримує посилань на об'єкти, які він містить, і тому не заважає сборці сміття, коли немає посилань на
                                об'єкти ззовні.
                            </li>
                            <li>
                                Приклад використання WeakSet:
                                <pre>
                                    let obj1 = { name: 'John' };
                                    let obj2 = { name: 'Jane' };

                                    const weakSet = new WeakSet();

                                    weakSet.add(obj1);
                                    weakSet.add(obj2);

                                    console.log(weakSet.has(obj1)); // true

                                    obj1 = null; // Об'єкт obj1 більше не має посилання на нього
                                    console.log(weakSet.has(obj1)); // false
                                </pre>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Отже, Set і WeakSet використовуються для зберігання унікальних значень, проте WeakSet має певні особливості, пов'язані зі
                    зборкою сміття.</p>
                <p>
                    Set може бути корисним для різних завдань в програмуванні, де потрібно працювати з унікальними значеннями і може
                    спрощувати різні завдання, де потрібно виключити дублікати або відслідковувати унікальність даних.. Ось деякі
                    практичні використання Set:</p>
                <ol>
                    <li>
                        <b>Видалення дублікатів з масиву:</b>
                        <pre>
                            const numbers = [1, 2, 3, 4, 5, 1, 2, 3];
                            const uniqueNumbers = [...new Set(numbers)];
                            console.log(uniqueNumbers); // [1, 2, 3, 4, 5]
                        </pre>
                    </li>
                    <li>
                        <b>Зберігання унікальних значень для перевірки дублікатів:</b>
                        <pre>
                            const visitedPages = new Set();

                            function trackPage(pageUrl) {
                                if (visitedPages.has(pageUrl)) {
                                    console.log('This page has already been visited');
                                } else {
                                    visitedPages.add(pageUrl);
                                    console.log('Adding page to visited pages');
                                }
                            }
                        </pre>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Map, WeakMap
            </div>
            <div class="collapsible-body">
                <p>Map і WeakMap - це дві структури даних в JavaScript, які використовуються для зберігання ключ-значення. Основна
                    відмінність між ними полягає в тому, як вони використовують пам'ять.</p>
                <ol>
                    <li>
                        <b>Map</b>
                        <ul>
                            <li>Map - це колекція пар ключ-значення, де кожен ключ і його відповідне значення можуть бути будь-якого типу.
                            </li>
                            <li>Приклад використання Map:
                                <pre>
                                    const myMap = new Map();

                                    const key1 = 'key1';
                                    const key2 = { id: 1 };
                                    const key3 = function() {};

                                    myMap.set(key1, 'value1');
                                    myMap.set(key2, 'value2');
                                    myMap.set(key3, 'value3');

                                    console.log(myMap.get(key1)); // 'value1'
                                    console.log(myMap.get(key2)); // 'value2'
                                    console.log(myMap.get(key3)); // 'value3'

                                    console.log(myMap.size); // 3

                                </pre>
                            </li>
                        </ul>
                        <p>Методи та властивості:</p>
                        <ul>
                            <li>
                                <b>new Map()</b>
                                <p>створює колекцію.</p>
                            </li>
                            <li>
                                <b>map.set(key, value)</b>
                                <p>зберігає значення value за ключем key.</p>
                            </li>
                            <li>
                                <b>map.get(key)</b>
                                <p>повертає значення за ключем; повертає undefined якщо key немає в колекції.</p>
                            </li>
                            <li>
                                <b>map.has(key)</b>
                                <p>повертає true якщо key існує, інакше false.</p>
                            </li>
                            <li>
                                <b>map.delete(key)</b>
                                <p>видаляє елемент (пару ключ/значення) за ключем.</p>
                            </li>
                            <li>
                                <b>map.clear()</b>
                                <p>видаляє всі елементи колекції.</p>
                            </li>
                            <li>
                                <b>map.size</b>
                                <p>повертає поточну кількість елементів.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <b>WeakMap</b>
                        <ul>
                            <li>WeakMap - це спеціальний тип Map, де ключі повинні бути об'єктами, а значення можуть бути будь-якого типу.
                            </li>
                            <li>WeakMap не утримує посилань на ключі, що не зберігаються десь інде в програмі, і тому не заважає сборці
                                сміття.
                            </li>
                            <li>Приклад використання WeakMap:
                                <pre>
                                let obj1 = {};
                                let obj2 = {};

                                const weakMap = new WeakMap();

                                weakMap.set(obj1, 'value1');
                                weakMap.set(obj2, 'value2');

                                console.log(weakMap.get(obj1)); // 'value1'

                                obj1 = null; // Об'єкт obj1 більше не має посилання на нього
                                console.log(weakMap.get(obj1)); // undefined

                            </pre>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Щодо практичної сторони - ключове тут це зберігання даних у структурі ключ-значення:</p>
                <p>Отже, Map і WeakMap використовуються для зберігання ключ-значення, проте WeakMap має певні особливості, пов'язані зі
                    зборкою сміття.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке "Tree shaking"?
            </div>
            <div class="collapsible-body">
                <p>Tree shaking - це термін, який часто використовується в контексті JavaScript для опису видалення "мертвого" коду.
                    Кандидатам на співбесіді слід розуміти, як це працює і які переваги це має.</p>

                <p>Tree shaking - це метод оптимізації нашого JavaScript-пакета, виключаючи невикористовувані експорти в нашому проекті, тим
                    самим зменшуючи розмір кінцевого пакета. У системі збірки модулів, такій як Webpack чи Rollup, вона статично аналізує
                    всі імпорт та експорт в нашому вихідному коді та видаляє невикористаний код при створенні пакета.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке Promises в JS?
            </div>
            <div class="collapsible-body">
                <p>Promise - це об'єкт в JavaScript, який представляють собою результат асинхронної операції. Вони використовуються для
                    управління асинхронним кодом та роблять його більш читабельним та прогнозованим. Promise може бути в трьох станах:
                    pending (очікування), fulfilled (виконано) або rejected (відхилено).</p>
                <p>Основні концепції Promises:</p>

                <ul>
                    <li>
                        <b>Створення Promise:</b>
                        <pre>const myPromise = new Promise((resolve, reject) => {
                                // Виконання асинхронної операції
                                const result = someAsynchronousOperation();

                                // Якщо операція успішна, викликаємо resolve з результатом
                                resolve(result);

                                // Якщо операція не вдалася, викликаємо reject з помилкою
                                reject(new Error('Something went wrong'));
                            });
                            </pre>
                    </li>
                    <li>
                        <b>Використання Promise:</b>
                        <pre>
                            myPromise.then((result) => {
                                console.log('Operation successful:', result);
                            }).catch((error) => {
                                console.error('Operation failed:', error);
                            });

                        </pre>
                        <p>У цьому прикладі, коли myPromise виконується, метод then викликається з результатом успішної операції, або метод
                            catch викликається з помилкою, якщо операція відхилено.</p>
                    </li>
                    <li>
                        <b>Послідовність декількох Promise:</b>
                        <pre>
                            const firstPromise = fetch('https://api.example.com/data');
                            const secondPromise = firstPromise.then(response => response.json());
                            const thirdPromise = secondPromise.then(data => processData(data));

                            thirdPromise.catch(error => console.error('Error:', error));

                        </pre>
                        <p>У цьому прикладі ми послідовно виконуємо три Promise: спочатку робимо запит до API, потім парсимо отримані дані у
                            форматі JSON, і нарешті обробляємо ці дані. Якщо будь-який з Promise відхилено, помилка буде передана до методу
                            catch.</p>
                    </li>
                    <li>
                        <b>Хендл декількох Promise водночас</b>
                        <p>Метод Promise.all() використовується для обробки кількох промісів одночасно та очікує, коли всі ці проміси будуть
                            виконані або хоча б один з них буде відхилений. Потім він повертає новий проміс, який вирішить, коли всі проміси
                            вже вирішені або хоча б один з них відхилений</p>
                        <pre>
                            const promise1 = fetch('https://api.example.com/data1');
                            const promise2 = fetch('https://api.example.com/data2');
                            const promise3 = fetch('https://api.example.com/data3');

                            Promise.all([promise1, promise2, promise3])
                                .then(responses => {
                                    // Отримуємо масив відповідей, коли всі проміси вирішені успішно
                                    return Promise.all(responses.map(response => response.json()));
                                })
                                .then(data => {
                                    // Отримуємо дані в форматі JSON
                                    console.log('All data:', data);
                                })
                                .catch(error => {
                                    // Обробка помилки, якщо хоча б один проміс відхилено
                                    console.error('Error:', error);
                                });

                        </pre>
                        <p>У цьому прикладі ми використовуємо Promise.all() для виконання трьох асинхронних запитів до різних ресурсів.
                            Після отримання відповідей ми конвертуємо їх у формат JSON за допомогою методу .json(). Коли всі проміси успішно
                            виконуються, ми отримуємо масив з даними з кожного запиту. Якщо хоча б один проміс відхилено, ми отримаємо
                            помилку за допомогою методу .catch().
                        </p>
                    </li>
                </ul>
                <p>Promises дозволяють покращити читабельність та обробку асинхронного коду, зокрема уникнути callback hell, коли функції
                    вкладаються одна в одну через callback-и.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Способи роботи з асинхронним кодом в JS
            </div>
            <div class="collapsible-body">
                <p>У JavaScript існує кілька способів роботи з асинхронним кодом, щоб забезпечити ефективність та реалізувати необхідну
                    логіку. Ось декілька з них:</p>
                <ol>
                    <li>
                        <b>Callback-функції</b>
                        <p>Це один з найпоширеніших способів роботи з асинхронним кодом в JavaScript. Ви передаєте функцію в якості
                            аргументу до асинхронної функції, і ця функція (callback) буде викликана, коли асинхронна операція завершиться.
                            Наприклад:</p>
                        <pre>
                            function fetchData(url, callback) {
                                // Симулюємо асинхронний запит
                                setTimeout(() => {
                                    const data = { name: "John", age: 30 };
                                    callback(data);
                                }, 1000);
                            }

                            function processData(data) {
                                console.log("Data received:", data);
                            }

                            fetchData("https://example.com/api/data", processData);
                        </pre>
                    </li>
                    <li>
                        <b>Promises</b>
                        <p>Вони є зручнішим і потужнішим способом управління асинхронним кодом. Вони дозволяють обробляти успішне завершення
                            або відхилення асинхронної операції. Наприклад:</p>
                        <pre>
                            function fetchData(url) {
                                return new Promise((resolve, reject) => {
                                    // Симулюємо асинхронний запит
                                    setTimeout(() => {
                                        const data = { name: "John", age: 30 };
                                        resolve(data);
                                    }, 1000);
                                });
                            }

                            fetchData("https://example.com/api/data")
                                .then(data => {
                                    console.log("Data received:", data);
                                })
                                .catch(error => {
                                    console.error("Error:", error);
                                });
                        </pre>
                    </li>
                    <li>
                        <b>Async/await</b>
                        <p>Це синтаксичний цукор для роботи з промісами, який робить код більш читабельним. async визначає функцію, яка
                            повертає проміс, а await заставляє функцію чекати на завершення асинхронної операції перед продовженням
                            виконання коду. Наприклад:</p>
                        <pre>
                            async function fetchData(url) {
                                // Симулюємо асинхронний запит
                                return new Promise((resolve, reject) => {
                                    setTimeout(() => {
                                        const data = { name: "John", age: 30 };
                                        resolve(data);
                                    }, 1000);
                                });
                            }

                            async function getData() {
                                try {
                                    const data = await fetchData("https://example.com/api/data");
                                    console.log("Data received:", data);
                                } catch (error) {
                                    console.error("Error:", error);
                                }
                            }

                            getData();
                        </pre>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Методи для роботи зі String
            </div>
            <div class="collapsible-body">

                <ol>
                    <li>
                        <b>Length</b>
                        <p>The length property returns the length of a string:</p>
                        <pre>
                            let text = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                            let length = text.length; // 26
                        </pre>
                    </li>
                    <li>
                        <b>Extracting String Characters</b>
                        <p>
                            There are 4 methods for extracting string characters:</p>
                        <ul>
                            <li>The at(position) Method</li>
                            <li>The charAt(position) Method</li>
                            <li>The charCodeAt(position) Method - The method returns a UTF-16 code (an integer between 0 and 65535 - in our
                                case it's not "H", but 72 number).
                            </li>
                            <li>Using property access [] like in arrays</li>
                        </ul>

                        <b>charAt()</b>
                        <p>The charAt() method returns the character at a specified index (position) in a string:</p>
                        <pre>
                            let text = "HELLO WORLD";
                            let char = text.charAt(0); // "H"
                        </pre>

                        <b>String at()</b>
                        <p>ES2022 introduced the string method at():</p>
                        <pre>
                            Get the third letter of name:

                            const name = "W3Schools";
                            let letter = name.at(2); // 'S'

                            or:

                            const name = "W3Schools";
                            let letter = name[2];
                        </pre>
                        <p>The at() method is a new addition to JavaScript. The at() method returns the character at a specified index
                            (position) in a string. It allows the use of negative indexes while charAt() do not. The at() method is
                            supported in all modern browsers since March 2022. Now
                            you can use myString.at(-2) instead of charAt(myString.length-2).</p>
                    </li>

                </ol>

                <div>
                    <h6><b>Extracting String Parts</b></h6>
                    <p>There are 3 methods for extracting a part of a string:</p>
                    <ul>
                        <li>slice(start, end)</li>
                        <li>substring(start, end)</li>
                        <li>substr(start, length)</li>
                    </ul>
                    <hr>
                    <h5><b>slice()</b></h5>
                    <p>slice() extracts a part of a string and returns the extracted part in a new string. The method takes 2 parameters:
                        start position, and end position (end not included). JavaScript counts positions from zero. First position is 0.
                        Second position is 1.
                        <br>Example: Slice out a portion of a string from position 7 to position 13:</p>
                    <pre>
                        let text = "Apple, Banana, Kiwi";
                        let part = text.slice(7, 13); // "Banana"

                        // If you omit the second parameter, the method will slice out the rest of the string:
                        let part2 = text.slice(7); // "Banana, Kiwi"

                        // If a parameter is negative, the position is counted from the end of the string:
                         let part3 = text.slice(-12); //  "Banana, Kiwi"

                        // This example slices out a portion of a string from position -12 to position -6:
                        let part4 = text.slice(-12, -6); //  "Banana"
                    </pre>
                    <hr>
                    <h5><b>substring()</b></h5>
                    <p>substring() is similar to slice(). The difference is that start and end values less than 0 are treated as 0 in
                        substring(). If you omit the second parameter, substring() will slice out the rest of the string.</p>
                    <pre>
                        let str = "Apple, Banana, Kiwi";
                        let part = str.substring(7, 13); // "Banana"
                    </pre>
                    <hr>
                    <h5><b>substr()</b></h5>
                    <p>substr() is similar to slice(). The difference is that the second parameter specifies the length of the extracted
                        part. </p>
                    <pre>
                        let str = "Apple, Banana, Kiwi";
                        let part = str.substr(7, 6); // "Banana"

                        // If you omit the second parameter, substr() will slice out the rest of the string.
                        let part2 = str.substr(7); // "Banana, Kiwi"

                        // If the first parameter is negative, the position counts from the end of the string.
                        let part3 = str.substr(-4); // "Kiwi"
                    </pre>
                    <hr>
                    <h5><b>toUpperCase() / toLowerCase()</b></h5>
                    <p>A string is converted to upper case with toUpperCase() and toLowerCase() in the opposite case: </p>
                    <pre>
                        let text1 = "Hello World!";
                        let text2 = text1.toUpperCase(); // "HELLO WORLD!"
                        let text3 = text1.toLowerCase(); // "hello world!"
                    </pre>
                    <hr>
                    <h5><b>concat()</b></h5>
                    <p>concat() joins two or more strings. All string methods return a new string. They don't modify the original string.
                        Formally said: Strings are immutable: Strings cannot be changed, only replaced.</p>
                    <pre>
                        let text1 = "Hello";
                        let text2 = "World";
                        let text3 = text1.concat(" ", text2); // "Hello World"

                        // The concat() method can be used instead of the plus operator. These two lines do the same:
                        text = "Hello" + " " + "World!";
                        text = "Hello".concat(" ", "World!");
                    </pre>
                    <hr>
                    <h5><b>trim() / trimStart() / trimEnd()</b></h5>
                    <p>The trim() method removes whitespace from both sides of a string. ECMAScript 2019 added String methods
                        trimStart() and trimEnd to JavaScript. The trimStart() method works like trim(), but
                        removes whitespace only from the start of a string. The trimEnd() method works like trim(), but removes whitespace
                        only from the end of a string.</p>
                    <pre>
                        let text1 = "      Hello World!      ";
                        let text2 = text1.trim(); // "Hello World!"
                    </pre>
                    <hr>
                    <h4><b>Replacing String Content</b></h4>
                    <h5><b>replace()</b></h5>
                    <p>The replace() method replaces a specified value with another value in a string.</p>
                    <pre>
                        let text = "Please visit Microsoft!";
                        let newText = text.replace("Microsoft", "W3Schools"); // "Please visit W3Schools!"
                    </pre>
                    <p>The replace() method does not change the string it is called on. The replace() method returns a new string. The
                        replace() method replaces only the first match. If you want to replace all matches, use a regular expression with
                        the /g flag set.</p>
                    <pre>
                        // By default, the replace() method is case sensitive. Writing MICROSOFT (with upper-case) will not work:

                        let text = "Please visit Microsoft!";
                        let newText = text.replace("MICROSOFT", "W3Schools"); // "Please visit Microsoft!" - it won't work

                        // To replace case insensitive, <b>use a regular expression with an /i flag (insensitive):</b>
                        newText = text.replace(/MICROSOFT/i, "W3Schools");

                        // !!! Regular expressions are written without quotes.

                        // To replace all matches, <b>use a regular expression with a /g flag (global match):   </b>
                        let text = "Please visit Microsoft and Microsoft!";
                        let newText = text.replace(/Microsoft/g, "W3Schools"); // "Please visit W3Schools and W3Schools!"
                    </pre>
                    <hr>
                    <h5><b>replaceAll()</b></h5>
                    <p>In 2021, JavaScript introduced the string method replaceAll() - it enhance the replace() method </p>
                    <pre>text = text.replaceAll("cats","dogs");</pre>
                    <p>The replaceAll() method allows you to specify a regular expression instead of a string to be replaced.
                        replaceAll() is an ES2021 feature. replaceAll() does not work in Internet Explorer.
                        <br>
                        text = text.replaceAll(/cats/g,"dogs");</p>
                    <hr>
                    <h5><b>split()</b></h5>
                    <p>Converting a String to an Array</p>
                    <pre>
                        text.split(",")    // Split on commas
                        text.split(" ")    // Split on spaces
                        text.split("|")    // Split on pipe

                        // If the separator is omitted, the returned array will contain the whole string in index [0].
                        ['I love you']

                        // If the separator is "", the returned array will be an array of single characters:
                        text.split("") // ['I', 'l', 'o', 'v', 'e']
                    </pre>
                </div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="react">React</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке Redux? Як це працює?
            </div>
            <div class="collapsible-body">
                <p>

                    Redux - це бібліотека управління станом для JavaScript-додатків, особливо популярна в додатках на базі React.js. Вона
                    допомагає управляти станом додатка у зручний спосіб та забезпечує передбачуваність та однозначність у взаємодії між
                    компонентами.
                </p>
                <p>Основні принципи роботи Redux:</p>
                <ul>
                    <li>
                        <strong>Централізований стан</strong>
                        <p>Стан всього додатка зберігається в одному центральному об'єкті, відомому як "store". Цей стан є незмінним, і
                            зміни відбуваються шляхом створення та відправлення "дій" (actions) до "редукторів" (reducers).</p>
                    </li>
                    <li>
                        <strong>Дії (Actions)</strong>
                        <p>Дії є простими об'єктами, які містять інформацію про те, що сталося у додатку. Вони відправляються до Redux за
                            допомогою функції "dispatch".</p>
                    </li>
                    <li>
                        <strong>Редюсери (Reducers)</strong>
                        <p>Редюсери - це чисті функції, які приймають поточний стан та дію, і повертають новий стан. Вони визначають, яким
                            чином стан додатка має змінитися відповідно до отриманих дій.</p>
                    </li>
                    <li>
                        <strong>Store</strong>
                        <p>Store - це об'єкт, який об'єднує дії та редуктори. Він зберігає стан додатка та дозволяє вам отримувати доступ до
                            стану, відправляти дії та реєструвати підписчиків для відстеження змін стану.</p>
                    </li>
                    <li>
                        <strong>Підписка на стан (Subscriptions)</strong>
                        <p>Компоненти можуть підписатися на зміни стану та отримувати повідомлення, коли стан змінюється. Це дозволяє
                            компонентам оновлювати свій вміст у відповідь на зміни стану.</p>
                    </li>
                </ul>
                <p>Основна ідея Redux полягає в тому, що стан додатка представлений як дерево об'єктів, яке зберігається в одному місці і
                    керується чіткими правилами. Це дозволяє підтримувати великі та складні додатки, зменшуючи залежність між компонентами
                    та полегшуючи налагодження та тестування.</p>
                <p>
                    Приклад використання:
                </p>
                <pre>
                    import { createStore } from 'redux';
                    import { Provider, connect } from 'react-redux';

                    // Головний компонент додатку
                    const App = () => (
                      < Provider store={store}>
                        < ConnectedCounter />
                      < /Provider>
                    );

                    // Створення Store
                    const store = createStore(counterReducer);

                    // Actions
                    const increment = () => ({ type: 'INCREMENT' });
                    const decrement = () => ({ type: 'DECREMENT' });

                    // Reducer
                    const counterReducer = (state = { count: 0 }, action) => {
                      switch (action.type) {
                        case 'INCREMENT':
                          return { count: state.count + 1 };
                        case 'DECREMENT':
                          return { count: state.count - 1 };
                        default:
                          return state;
                      }
                    };
                </pre>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="html">HTML</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Що таке DOCTYPE і навіщо його
                використовують?
            </div>
            <div class="collapsible-body">
                DOCTYPE (Document Type Definition) - це інструкція, яку використовують у HTML-документах для визначення
                типу документа та версії HTML або XHTML, якою він відповідає. Вона розміщується на самому початку
                HTML-коду, перед будь-якими тегами html, head, чи body.
                < !DOCTYPE html > < html lang="uk" > < head > < body > < /html ><br>
                Основна роль DOCTYPE:
                <ol>
                    <li>
                        Визначення режиму рендерингу:

                        Деякі браузери мають різні режими рендерингу для старих версій HTML. DOCTYPE допомагає браузерам
                        вибрати правильний режим рендерингу для забезпечення сумісності із стандартами.

                    </li>
                    <li>
                        Забезпечення сумісності:

                        Декларація DOCTYPE допомагає визначити версію HTML або XHTML, що використовується в документі.
                        Це важливо для того, щоб браузери могли коректно відображати сторінку відповідно до відповідних
                        стандартів.
                    </li>
                    <li>
                        Уникнення квірксів:

                        Зазначення DOCTYPE допомагає уникнути квірксів (різних режимів рендерингу), які можуть виникати
                        при відображенні сторінки в різних браузерах.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які основні теги структури HTML-сторінки?
            </div>
            <div class="collapsible-body">
                <ol>
                    <li><p><code>&lt;!DOCTYPE html&gt;</code>: Визначає тип документа та версію HTML.</p></li>
                    <li><p><code>&lt;html&gt;</code>: Визначає початок та кінець HTML-документа.</p></li>
                    <li><p><code>&lt;head&gt;</code>: Містить мета-інформацію про документ, таку як заголовок,
                        мета-теги, посилання на зовнішні ресурси (стилі, скрипти).</p></li>
                    <li><p><code>&lt;title&gt;</code>: Визначає заголовок сторінки, який відображається в заголовку
                        вкладки браузера або на панелі завдань.</p></li>
                    <li><p><code>&lt;meta charset="UTF-8"&gt;</code>: Вказує кодування символів для сторінки, зазвичай
                        встановлюється на UTF-8.</p></li>
                    <li><p><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>:
                        Встановлює мета-тег для налаштування ширини екрану та масштабування на мобільних пристроях.</p>
                    </li>
                    <li><p><code>&lt;body&gt;</code>: Містить основний вміст сторінки, такий як текст, зображення,
                        таблиці, форми та інші елементи.</p></li>
                    <li><p><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code>: Визначають заголовки різних рівнів.
                        <code>&lt;h1&gt;</code> - найважливіший, <code>&lt;h6&gt;</code> - найменший.</p></li>
                    <li><p><code>&lt;p&gt;</code>: Визначає абзац тексту.</p></li>
                    <li><p><code>&lt;a&gt;</code>: Створює посилання на іншу сторінку або ресурс.</p></li>
                    <li><p><code>&lt;img&gt;</code>: Вставляє зображення на сторінку.</p></li>
                    <li><p><code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>: Визначають
                        ненумерований (ul) або нумерований (ol) список та його елементи (li).</p></li>
                    <li><p><code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, <code>&lt;td&gt;</code>:
                        Визначають таблицю та її елементи.</p></li>
                    <li><p><code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>:
                        Визначають форму та її елементи для введення даних.</p></li>
                    <li><p><code>&lt;div&gt;</code>: Використовується для групування та стилізації інших елементів.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке семантичні теги та навіщо вони потрібні? Наведіть приклади таких тегів.
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>Семантичні теги в HTML це
                    елементи, які мають смислове значення та описують зміст, структуру та значення елементів на
                    сторінці. Використання семантичних тегів допомагає робити HTML-код більш зрозумілим для розробників
                    та браузерів, покращує доступність та SEO.</p>
                    <p>Основні переваги семантичних тегів:</p>
                    <ol>
                        <li><p><strong>Зрозумілість коду:</strong> Імена семантичних тегів самі по собі вказують на їхнє
                            значення, що робить код більш зрозумілим і легким для інших розробників читати.</p></li>
                        <li><p><strong>SEO:</strong> Використання семантичних тегів може поліпшити індексацію сторінок
                            пошуковими системами.</p></li>
                        <li><p><strong>Доступність:</strong> Семантичні теги допомагають робити веб-сайти більш
                            доступними для користувачів з вадами зору, а також для інших асистивних технологій.</p></li>
                    </ol>
                    <p>Приклади семантичних тегів:</p>
                    <ol>
                        <li><p><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</p></li>
                        <li><p><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</p></li>
                        <li><p><code>&lt;main&gt;</code>: Визначає основний контент сторінки.</p></li>
                        <li><p><code>&lt;article&gt;</code>: Визначає незалежний, самостійний контент, який може бути
                            повністю розміщений на іншому ресурсі.</p></li>
                        <li><p><code>&lt;section&gt;</code>: Визначає секцію документа.</p></li>
                        <li><p><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного
                            контенту (наприклад, бічні бари, реклама).</p></li>
                        <li><p><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</p></li>
                        <li><p><code>&lt;figure&gt;</code> і <code>&lt;figcaption&gt;</code>: Визначають зображення або
                            мультимедійний контент та його підпис.</p></li>
                        <li><p><code>&lt;time&gt;</code>: Визначає дату або час.</p></li>
                    </ol>
                    <p>Ці теги допомагають створювати структурований та змістовно збагачений HTML, що полегшує розуміння
                        структури документа як розробниками, так і браузерами та іншими агентами.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які теги добавили в HTML5?
            </div>
            <div class="collapsible-body">
                <div class="markdown prose w-full break-words dark:prose-invert dark"><p>HTML5 вніс багато нових тегів і
                    атрибутів, що значно поліпшили можливості мови та розширили функціональність веб-розробки. Ось деякі
                    з нових тегів, які були додані в HTML5:</p>
                    <ol>
                        <li><p><strong>Семантичні блокові елементи:</strong></p>
                            <ul>
                                <li><code>&lt;article&gt;</code>: Визначає самостійний контент, який може існувати
                                    незалежно від інших частин документа.
                                </li>
                                <li><code>&lt;section&gt;</code>: Визначає секцію документа.</li>
                                <li><code>&lt;nav&gt;</code>: Визначає блок для навігаційних посилань.</li>
                                <li><code>&lt;header&gt;</code>: Визначає верхню частину сторінки або секції.</li>
                                <li><code>&lt;footer&gt;</code>: Визначає нижню частину сторінки або секції.</li>
                                <li><code>&lt;aside&gt;</code>: Визначає контент, який стоїть віддільно від головного
                                    контенту (наприклад, бічні бари, реклама).
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Елементи для введення форм:</strong></p>
                            <ul>
                                <li><code>&lt;datalist&gt;</code>: Визначає список варіантів для елемента <code>&lt;input&gt;</code>
                                    з атрибутом <code>list</code>.
                                </li>
                                <li><code>&lt;output&gt;</code>: Визначає область виведення для результатів форми.</li>
                            </ul>
                        </li>
                        <li><p><strong>Мультимедійні теги:</strong></p>
                            <ul>
                                <li><code>&lt;audio&gt;</code>: Визначає аудіо-елемент для вставки звукового контенту.
                                </li>
                                <li><code>&lt;video&gt;</code>: Визначає відео-елемент для вставки відео-контенту.</li>
                            </ul>
                        </li>
                        <li><p><strong>Графічні теги:</strong></p>
                            <ul>
                                <li><code>&lt;canvas&gt;</code>: Визначає область, на якій можна малювати за допомогою
                                    JavaScript.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Теги для роботи з ресурсами:</strong></p>
                            <ul>
                                <li><code>&lt;embed&gt;</code>: Вставляє зовнішні ресурси, такі як плагіни, аудіо або
                                    відео.
                                </li>
                                <li><code>&lt;source&gt;</code>: Вказує ресурс для вкладання у елементи <code>&lt;audio&gt;</code>
                                    та <code>&lt;video&gt;</code>.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Атрибути форм:</strong></p>
                            <ul>
                                <li><code>autocomplete</code>: Атрибут для управління автозаповненням полів форми.</li>
                                <li><code>placeholder</code>: Атрибут для встановлення підказки для користувача у полі
                                    введення.
                                </li>
                            </ul>
                        </li>
                        <li><p><strong>Атрибути гіперпосилань:</strong></p>
                            <ul>
                                <li><code>download</code>: Атрибут для вказання, що посилання призначене для
                                    завантаження файлу замість переходу за ним.
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p>Це лише деякі приклади тегів та атрибутів, які були додані в HTML5. Ці зміни спрямовані на
                        поліпшення структури документа, роботи з мультимедіа та забезпечення більшої доступності та
                        можливостей веб-розробникам.</p></div>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке data-атрибути, в яких випадках їх використовуєте?
            </div>
            <div class="collapsible-body">
                data-атрибути - це спеціальні атрибути HTML-тегів, які починаються з префіксу data-. Вони призначені для
                зберігання власних даних в елементах HTML, які можуть бути використані для додаткового опису або
                ідентифікації елементів. Використання data-атрибутів дозволяє розробникам зберігати інформацію без
                втручання у стандартні атрибути. Деякі випадки використання data-атрибутів:
                <ol>
                    <li>JavaScript: За допомогою data-атрибутів можна зберігати дані, які JavaScript потрібно
                        використовувати. Наприклад, для зберігання ідентифікаторів чи параметрів, які використовуються в
                        динамічних скриптах. JavaScript може отримати значення data-action для подальших дій.
                    </li>
                    <li>CSS: Можна використовувати data-атрибути для створення CSS-селекторів або передачі додаткових
                        стилів. В CSS: .user[data-status="active"] {} - Це дозволить стилізувати елемент із конкретним
                        data-атрибутом.
                    </li>
                    <li>HTML: Інколи data-атрибути використовуються для вставки додаткової інформації, яку може
                        використовувати браузер або інші інструменти.
                    </li>
                </ol>
                Тут data-analytics та data-location можуть вказувати на аналітичні дані для слідкування кліків та місця
                розташування посилання.

                Важливо пам'ятати, що data-атрибути не повинні використовуватися для зберігання інформації, яка повинна
                бути доступна для користувачів або врахована в пошукових системах. Вони призначені для зберігання
                технічної або внутрішньої інформації, яка не відображається на сторінці напряму.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Шо таке AMP?
            </div>
            <div class="collapsible-body">
                <p>AMP HTML, або Accelerated Mobile Pages, є фреймворком веб-компонентів, призначеним для оптимізації
                    перегляду веб-сторінок на мобільних пристроях. Його основна мета - покращити швидкість завантаження
                    сторінок та користувацький досвід на мобільних пристроях, дотримуючись найкращих практик щодо
                    продуктивності.</p>

                <p>Переваги використання AMP HTML включають в себе швидший час завантаження, кращі позначення у
                    пошукових системах, збільшення взаємодії користувачів та зменшення відсотку відмов. Це досягається
                    за допомогою різних оптимізацій, таких як ліниве завантаження зображень, асинхронне виконання
                    JavaScript та спрощення CSS.</p>

                AMP HTML відрізняється від звичайного HTML кількома способами:
                <ol>
                    <li>Вимагає конкретного заявлення doctype (< !doctype html>) та тегу < html amp>.</li>
                    <li>Користувацькі компоненти AMP замінюють деякі стандартні елементи HTML (наприклад, < amp-img>
                        замість < img>).
                    </li>
                    <li>Зовнішні таблиці стилів не дозволяються; весь CSS повинен бути вбудованим та обмеженим до
                        75KB.
                    </li>
                    <li>Дозволяється лише асинхронне виконання JavaScript із обмеженнями на власні сценарії.</li>
                    <li>Ресурси сторонніх постачальників повинні завантажуватись через схвалені розширення AMP.</li>
                    <li>Макет контенту повинен бути визначений перед завантаженням ресурсів для запобігання
                        переприсвоєнню контенту.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як оптимізувати перформанс сайту?
            </div>
            <div class="collapsible-body">
                Оптимізація продуктивності веб-сайту - це важливий аспект для забезпечення ефективної роботи сайту і
                задоволення користувачів. Ось деякі стратегії для оптимізації продуктивності сайту:

                <ol>
                    <li>
                        <strong>Зменшення розміру та кількості запитань:</strong>
                        <ul>
                            <li>Об'єднання та мінімізація файлів CSS, JavaScript та зображень може допомогти зменшити
                                розмір сторінки і час завантаження.
                            </li>
                            <li>Використання спрайтів для об'єднання зображень може зменшити кількість запитів
                                серверу.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Кешування</strong>
                        <ul>
                            <li>Використовуйте HTTP-заголовки кешування, щоб зберегти копії ресурсів на стороні клієнта
                                та уникнути повторних завантажень при повторних відвідуваннях сайту.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Асинхронне завантаження ресурсів</strong>
                        <ul>
                            <li></li>
                            <li></li>
                        </ul>
                    </li>
                    <li>
                        <strong></strong>
                        <ul>
                            <li>Завантажуйте JavaScript асинхронно та використовуйте атрибут async чи defer.</li>
                            <li>Використання лінивого завантаження для зображень та інших ресурсів, які не є необхідними
                                на початковому етапі завантаження сторінки.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Оптимізація зображень</strong>
                        <ul>
                            <li>Використовуйте формати зображень, що мають високу ступінь стиснення, такі як WebP.</li>
                            <li>Зменшуйте розмір зображень перед їх завантаженням.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мінімізація запитів до сервера</strong>
                        <ul>
                            <li>Зменшення кількості ресурсів на сторінці може допомогти скоротити час завантаження.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Використання CDN</strong>
                        <ul>
                            <li>Використання Content Delivery Network дозволяє розміщувати ресурси на серверах, що
                                розташовані ближче до користувачів, що поліпшує швидкість завантаження.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Аналіз та оптимізація запитів до бази даних</strong>
                        <ul>
                            <li>Оптимізація SQL-запитів та використання кешування можуть покращити відгук сайту.</li>

                        </ul>
                    </li>
                    <li>
                        <strong>Мініфікація HTML, CSS, та JavaScript</strong>
                        <ul>
                            <li>Видалення зайвих пробілів, коментарів та мінімізація коду можуть зменшити обсяг файлів і
                                покращити швидкість завантаження.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Оптимізація сервера</strong>
                        <ul>
                            <li>Використовуйте високопродуктивні сервери та оптимізуйте налаштування серверного
                                програмного забезпечення.
                            </li>
                            <li></li>
                        </ul>
                    </li>
                    <li>
                        <strong>Use a Content Delivery Network (CDN)</strong>
                        <ul>
                            <li>Сервіс по обслуговуванню статичних файлів може бути витребувальним завданням. Оскільки
                                це не є основною діяльністю 99% веб-сайтів, розумно передавати цю частину інфраструктури
                                іншим постачальникам. На щастя, існують спеціальні сервіси саме для цього: мережі
                                доставки контенту або CDN.
                            </li>
                            <li>CDN оптимізують доставку статичних файлів, таких як CSS, зображення, шрифти та
                                JavaScript, для ваших відвідувачів. Їх налаштування, як правило, дуже просте.
                            </li>
                            <li>CDN використовують географічно розподілені сервери. Це означає, що сервер, який
                                найближчий до вашого відвідувача, буде обслуговувати файли. Таким чином, час
                                завантаження, наприклад, зображень, буде однаковим, незалежно від того, де користувач
                                підключається. Загалом, при обслуговуванні статичних файлів з власних серверів час
                                завантаження збільшується, коли користувачі фізично далеко від сервера.
                            </li>
                            <li>Ви можете використовувати Sematext Experience для моніторингу продуктивності файлів,
                                розміщених на CDN, щоб фактично виміряти, чи є сенс передавати цю частину інфраструктури
                                іншим постачальникам. Коли ми вперше почали використовувати CDN для обслуговування
                                ресурсів для Sematext Cloud, ми фактично використовували Sematext Experience, що
                                показало, що ми дійсно обслуговуємо речі швидше для наших користувачів.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Minimize Time to First Byte</strong>
                        <p>Час до першого байта, або TTFB, - це час, який потрібно браузеру для отримання першого байта
                            даних від сервера. Таким чином, це стосується серверної частини, але воно відіграє важливу
                            роль взагалі у продуктивності вашого веб-сайту, тому вам слід приділити час для його
                            поліпшення.</p>
                        <p>Основним фактором, який знаходиться під вашим контролем у відношенні до TTFB, є час обробки
                            сервера. Таким чином, ви можете випробувати деякі поради, рекомендовані Google, для
                            поліпшення TTFB:</p>
                        <ol>
                            <li>Оптимізуйте логіку застосунка сервера для швидшої підготовки сторінок. Якщо ви
                                використовуєте серверний фреймворк, у фреймворка можуть бути рекомендації щодо того, як
                                це зробити.
                            </li>
                            <li>Оптимізуйте, як ваш сервер виконує запити до баз даних або переходіть до швидших систем
                                баз даних.
                            </li>
                            <li>Оновіть апаратне забезпечення сервера для отримання більше пам'яті або ЦП.</li>
                        </ol>
                        <p>TTFB менше 200 мс вважається великим. Діапазон від 200 мс до 500 мс вважається нормальним і
                            прийнятним. TTFB, що постійно перевищує 600 мс, потрібно розглядати для дослідження.
                            Sematext Experience може допомогти вам у цьому, а також в моніторингу інших метрик Web
                            Vitals.</p>
                    </li>
                    <li>
                        <strong>Кешування</strong>
                        <p>Я коротко згадував про кеш, але хочу пояснити, що це таке. Кешування - це процес збереження
                            версії ваших файлів у тимчасовому сховищі - кеші -, до якого можна отримати швидший доступ.
                            Є багато переваг у ввімкненні кешування в браузері, оскільки це може зменшити споживання
                            пропускної здатності, збільшити час завантаження, зменшити затримку та робоче навантаження
                            сервера. Основним недоліком є те, що фактично завжди буде принаймні дві версії вашого
                            веб-сайту у будь-який момент часу. Це може викликати проблеми, якщо ви використовуєте службу
                            в реальному часі, яка залежить від точних даних, але це можна вирішити в певній мірі,
                            вимагаючи очищення підсекції кешу при імпортуванні нових даних.</p>
                    </li>
                    <li>
                        <strong></strong>
                        <ul>
                            <li></li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are the critical rendering paths in a web browser?
            </div>
            <div class="collapsible-body">
                <p><strong>Критичний шлях рендеру (Critical Rendering Paths)</strong> - це послідовність дій, які браузер повинен виконати
                    для відображення вмісту сторінки на екрані користувача. Основним завданням є оптимізація цих шляхів для
                    максимально швидкого і коректного відображення вмісту. Нижче подано опис критичних шляхів у веб-браузері:</p>
                <ol>
                    <li>
                        <strong>Отримання HTML (Fetch HTML):</strong>
                        <p>Браузер починає завантаження сторінки, відправляючи запит на сервер для отримання HTML-коду.</p>
                        <p> Використання Content Delivery Network (CDN), компресія HTML і налаштування кешування.</p>
                    </li>
                    <li>
                        <strong>Обробка HTML (Parse HTML):</strong>
                        <p>Браузер аналізує отриманий HTML-код та створює DOM (Document Object Model) та CSSOM (CSS Object Model).</p>
                        <p>Мінімізація та усунення блокуючих ресурсів, збільшення паралелізму завантаження.</p>
                    </li>
                    <li>
                        <strong>Створення Render Tree (Create Render Tree):</strong>
                        <p> Браузер об'єднує DOM та CSSOM у Render Tree, який визначає порядок відображення елементів.</p>
                        <p>Мінімізація кількості CSS-блокуючих ресурсів, використання ефективних селекторів CSS.</p>
                    </li>
                    <li>
                        <strong>Обчислення розмірів та позицій (Layout):</strong>
                        <p>Браузер визначає розміри та позиції кожного елемента в Render Tree.</p>
                        <p>Використання флексбоксів, грідів, уникання складних таблиць.</p>
                    </li>
                    <li>
                        <strong>Відображення (Paint):</strong>
                        <p>Браузер займається фактичним відображенням сторінки на екрані користувача.</p>
                        <p>Використання анімацій GPU, оптимізація зображень.</p>
                    </li>
                    <li>
                        <strong>Оновлення (Composite): </strong>
                        <p>Браузер обновлює екран згідно з внесеними змінами.</p>
                        <p>Використання апаратного прискорення, уникання зайвих перемальовувань.</p>
                    </li>
                </ol>
                <p>Оптимізація критичних шляхів є ключовою для досягнення високої швидкодії завантаження сторінок та відповіді на запити
                    користувачів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                BOM (Browser Object Model) vs DOM (Document Object Model)
            </div>
            <div class="collapsible-body">
                <p>BOM (Browser Object Model) та DOM (Document Object Model) - це дві різні моделі об'єктів, які використовуються
                    веб-браузерами для представлення вмісту та взаємодії з ним на сторінках в Інтернеті. Нижче подано їхні основні
                    різниці:</p>
                <h6>DOM (Document Object Model):</h6>
                <ol>
                    <li>
                        <strong>Опис</strong>
                        <ul>
                            <li>DOM представляє структуру документа веб-сторінки, яка може бути HTML, XML або XHTML.</li>
                            <li>Кожен елемент, атрибут, текстовий вузол тощо має свій відповідний об'єкт в DOM.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Призначення</strong>
                        <ul>
                            <li>Використовується для доступу, маніпуляції та зміни структури та вмісту веб-документа.</li>
                            <li>Дозволяє скриптам змінювати вигляд та поведінку сторінки.</li>
                        </ul>
                    <li>
                        <strong>Орієнтований на документ</strong>
                        <ul>
                            <li>DOM визначає структуру документа та забезпечує можливість програмного доступу до елементів документа.</li>
                        </ul>
                </ol>

                <h6>BOM (Browser Object Model):</h6>
                <ol>
                    <li>
                        <strong>Опис</strong>
                        <ul>
                            <li>BOM представляє об'єкти браузера, такі як вікна та фрейми, а також деякі додаткові об'єкти, такі як
                                navigator, history, location тощо.
                            </li>
                            <li>Включає об'єкти, які не пов'язані з структурою документа.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Призначення</strong>
                        <ul>
                            <li>Використовується для контролю та взаємодії з самим браузером, а не конкретним документом.</li>
                            <li>Надає доступ до функцій, таких як керування вікнами, робота з історією перегляду, визначення
                                місцезнаходження тощо.
                            </li>
                        </ul>
                    <li>
                        <strong>Орієнтований на браузер</strong>
                        <ul>
                            <li>BOM визначає об'єкти, які представляють браузер і дозволяють контролювати його функціонал.</li>
                        </ul>
                </ol>

                <h6>Загальна Ідея:</h6>
                <ul>
                    <li>DOM відповідає за структуру та вміст веб-сторінки.</li>
                    <li>BOM відповідає за взаємодію з самим браузером та його функціоналом.</li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Доступність веб-сайту (Web Accessibility)
            </div>
            <div class="collapsible-body">
                <p>Доступність веб-сайту (Web Accessibility) — це забезпечення можливості використання та сприйняття веб-ресурсу всіма
                    користувачами, включаючи тих, які мають обмеження чи інвалідність. Ось деякі ключові аспекти доступності веб-сайтів:</p>
                <p>Дотримання принципів доступності дозволяє забезпечити комфортне та рівноправне використання веб-сайту всіма його
                    відвідувачами.</p>

                <ol>
                    <li>
                        <strong>Семантична Розмітка</strong>
                        <ul>
                            <li>Використання правильних HTML-тегів для опису структури сторінки.</li>
                            <li>Забезпечення логічного розташування та взаємодії елементів.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Адаптивний Дизайн:</strong>
                        <ul>
                            <li>Забезпечення читабельності та зручності використання на різних пристроях.</li>
                            <li>Створення веб-сайту, який підлаштовується під різні розміри екранів та пристрої.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Контрастність Кольорів</strong>
                        <ul>
                            <li>Використання достатнього контрасту між текстом та тлом для зручності читання користувачами з обмеженим
                                зором.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Альтернативні Тексти</strong>
                        <ul>
                            <li>Надання текстових описів (альтернативних текстів) для графічних елементів, щоб люди з вадами зору або
                                вимкненим зображенням могли зрозуміти зміст.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Клавішні Спуски</strong>
                        <ul>
                            <li>Забезпечення можливості навігації та використання всіх інтерактивних елементів за допомогою клавіатури, а не
                                лише миші.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Відмова від Миготіння</strong>
                        <ul>
                            <li>Уникання використання миготливих або блимучих елементів, які можуть викликати дискомфорт чи епілептичні
                                напади.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Легенди та Підказки Форм</strong>
                        <ul>
                            <li>Додавання чітких заголовків, підказок та легенд до форм для полегшення їх використання.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мовні Атрибути</strong>
                        <ul>
                            <li>Використання атрибутів мови для правильного визначення та читання текстів на різних мовах.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Навігація та Заголовки</strong>
                        <ul>
                            <li>Додавання структурованої навігації та заголовків для полегшення розуміння контенту та навігації.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Тестування з Користувачами</strong>
                        <ul>
                            <li>Проведення тестів доступності з реальними користувачами з різними потребами та обмеженнями.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How do you serve a page with content in multiple languages?
            </div>
            <div class="collapsible-body">
                <p>Для обслуговування сторінки з контентом у кількох мовах, ви можете використовувати підходи, такі як:</p>

                <ol>
                    <li>
                        <strong>Мульти-мовні файли перекладу:</strong>
                        <ul>
                            <li>Створіть окремі файли для кожної мови, які містять переклади контенту.</li>
                            <li>Використовуйте ідентифікатори для тексту, які потрібно перекласти.</li>
                            <li>Під час завантаження сторінки, визначайте мову користувача і завантажуйте відповідний файл перекладу.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>URL-параметри або піддомени:</strong>
                        <ul>
                            <li>Додається мовний ідентифікатор до URL-адреси (наприклад, /en/about для англійської мови, /es/about для
                                іспанської).
                            </li>
                            <li>Використовуйте цей ідентифікатор для визначення потрібної мови та завантаження відповідного контенту.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>HTTP заголовки:</strong>
                        <ul>
                            <li>Використовуйте HTTP заголовок Accept-Language для отримання від браузера інформації про мову користувача.
                            </li>
                            <li>На сервері визначайте мову і відповідно обслуговуйте сторінку.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>JavaScript-бібліотеки перекладу:</strong>
                        <ul>
                            <li>Використовуйте JavaScript-бібліотеки, такі як i18n.js або react-intl для управління перекладами у
                                фронтенді.
                            </li>
                            <li>Дозволяє вам динамічно змінювати мову і оновлювати контент без повного перезавантаження сторінки.</li>
                        </ul>
                    </li>
                </ol>

                <p>При виборі методу важливо враховувати SEO-дружність та зручність для користувачів. Зазвичай, краще обслуговувати сторінки
                    у різних мовах так, щоб вони були добре індексовані пошуковими системами та зручні для навігації користувачів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What kind of things must you be wary of when designing or developing for multilingual sites?
            </div>
            <div class="collapsible-body">
                <p>При проектуванні або розробці мульти-мовних сайтів важливо враховувати кілька аспектів, щоб забезпечити ефективність,
                    коректність та зручність для користувачів. Ось деякі речі, на які варто звертати увагу:</p>

                <ol>
                    <li>
                        <strong>Культурні відмінності:</strong>
                        <ul>
                            <li>Враховуйте різницю в культурних відмінностях при виборі зображень, кольорів та загального дизайну.</li>
                            <li>Пам'ятайте, що певний контент або вирази можуть мати різний сенс у різних культурах. (Mitsubishi Pajero)
                            </li>
                        </ul>
                    </li>
                    <li><strong>Доступність текстового контенту:</strong>
                        <ul>
                            <li>Переконайтеся, що дизайн передбачає різні довжини текстового контенту в різних мовах, щоб уникнути обрізання
                                або переповнення блоків.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Підтримка мовних правил:</strong>
                        <ul>
                            <li>Враховуйте різні правила сортування, числові та календарні формати, які можуть відрізнятися в різних
                                мовах.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Менеджмент контенту:</strong>
                        <ul>
                            <li>Використовуйте системи управління контентом (CMS), які підтримують легке додавання та оновлення мов.</li>
                            <li>Забезпечте можливість редагування та попереднього перегляду контенту для перекладачів.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Describe the difference between a cookie, sessionStorage and localStorage.
            </div>
            <div class="collapsible-body">
                <p>Різниця між кукі (cookie), sessionStorage та localStorage полягає в їхньому зберіганні даних, тривалості життя, розмірі
                    та доступі:</p>
                <ol>
                    <li>
                        <strong>Кукі (cookie):</strong>
                        <ul>
                            <li>
                                <strong>Зберігання:</strong>
                                <p>Кукі - це невеликий обсяг даних, який зберігається на боці клієнта та відправляється разом із кожним
                                    запитом на сервер.</p>
                            </li>
                            <li>
                                <strong>Тривалість життя:</strong>
                                <p> Може мати обмежену тривалість, встановлену вами, або доки не закінчиться сеанс браузера (залежно від
                                    параметрів).</p>
                            </li>
                            <li>
                                <strong>Доступ: </strong>
                                <p>Має обмежений доступ через JavaScript через обмежені методи API і визначені правила Same-Origin
                                    <Policy class=""></Policy>
                                </p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>sessionStorage:</strong>
                        <ul>
                            <li>
                                <strong>Зберігання:</strong>
                                <p>sessionStorage зберігає дані в області пам'яті сесії тільки на час життя сесії браузера.</p>
                            </li>
                            <li>
                                <strong>Тривалість життя:</strong>
                                <p>Дані в sessionStorage будуть видалені при закритті вкладки або вікна браузера.</p>
                            </li>
                            <li>
                                <strong>Доступ: </strong>
                                <p>Доступно тільки на стороні клієнта, і дані не надсилаються на сервер під час запитів.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>localStorage:</strong>
                        <ul>
                            <li>
                                <strong>Зберігання:</strong>
                                <p>localStorage подібно до sessionStorage, але дані в ньому зберігаються на більший термін, навіть після
                                    закриття вкладки чи перезавантаження браузера.</p>
                            </li>
                            <li>
                                <strong>Тривалість життя:</strong>
                                <p>Дані в localStorage залишаються, поки їх не видалено вручну або не скинуто з програми.</p>
                            </li>
                            <li>
                                <strong>Доступ: </strong>
                                <p>Також доступно тільки на стороні клієнта, і дані не надсилаються на сервер під час запитів.</p>
                            </li>
                        </ul>
                    </li>
                    <p>
                        Обираючи між цими варіантами збереження даних, важливо враховувати потреби вашого додатка щодо тривалості життя
                        даних та безпеки, а також вимоги до зберігання даних на сервері чи локально на клієнтському пристрої.
                    </p>
                    <p>Розмір даних, який може бути збережений в куках (cookie), sessionStorage та localStorage, може варіюватися в
                        залежності від браузера та його обмежень. Тут є загальні вказівки:</p>
                    <ol>
                        <li>
                            <strong>Cookie:</strong>
                            <ul>
                                <li>Загальний розмір куки для одного домену обмежений приблизно 4096 байтами (4 КБ).</li>
                                <li>Браузер обмежує кількість куків, які можуть бути збережені для одного домену (зазвичай близько 50).</li>
                            </ul>
                        </li>
                        <li>
                            <strong>sessionStorage та localStorage:</strong>
                            <ul>
                                <li>Зазвичай більші обсяги даних порівняно з кукі.</li>
                                <li>Розмір localStorage обмежений приблизно 5 МБ на домен.</li>
                                <li>Розмір sessionStorage зазвичай теж довший (~ 5 MB), але при закритті вкладки або вікна браузера дані
                                    видаляються.
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p>Важливо враховувати, що це загальні вказівки, і реальні обмеження можуть варіюватися в залежності від конкретного
                        браузера та його налаштувань. Також слід пам'ятати, що великі об'єми даних можуть впливати на продуктивність та
                        швидкодію веб-сторінок.</p>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Describe the difference between < script>, < script async> and < script defer>.
            </div>
            <div class="collapsible-body">
                <p>
                    Теги < script>, < script async>, та < script defer> в HTML використовуються для включення та виконання JavaScript коду
                    на веб-сторінці, проте вони відрізняються за тим, як вони впливають на завантаження та виконання скрипта. Ось короткий
                    опис кожного:
                </p>
                <ol>
                    <li>
                        <strong>< script></strong>
                        <ul>
                            <li>
                                <strong>Завантаження:</strong>
                                <p>Скрипт завантажується та виконується синхронно, що означає, що він блокує парсинг HTML-документу до тих
                                    пір, поки скрипт повністю не завантажиться та не виконається.</p>
                            </li>
                            <li>
                                <strong>Використання:</strong>
                                <p>Це стандартна поведінка за замовчуванням. Використовується, коли скрипт повинен виконатися негайно та є
                                    необхідним для подальшого відображення чи функціональності сторінки.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>< script async></strong>
                        <ul>
                            <li>
                                <strong>Завантаження:</strong>
                                <p>Скрипт завантажується асинхронно, дозволяючи парсингу HTML продовжуватися, навіть якщо скрипт ще не
                                    завантажений. Однак виконання скрипта трапляється, як тільки він завантажується, незалежно від того, чи
                                    завершено парсинг HTML чи ні.</p>
                            </li>
                            <li>
                                <strong>Використання:</strong>
                                <p>Використовується, коли скрипт не залежить від інших скриптів та може виконуватися в будь-який момент.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>< script defer></strong>
                        <ul>
                            <li>
                                <strong>Завантаження:</strong>
                                <p>Скрипт також завантажується асинхронно, але виконання відбувається тільки після завершення парсингу
                                    HTML-документу.</p>
                            </li>
                            <li>
                                <strong>Використання:</strong>
                                <p>Використовується, коли порядок виконання скриптів важливий та ви хочете, щоб скрипт виконувався після
                                    повного завантаження та парсингу HTML.</p>
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Why is it generally a good idea to position CSS < link>s between < head>< /head> and JS < script>s just before
                < /body>? Do you know any exceptions?
            </div>
            <div class="collapsible-body">
                <p>Зазвичай рекомендується розміщувати елементи CSS < link> між тегами < head> і JS < script> безпосередньо перед
                    закриваючим тегом < /body> з кількох причин:</p>
                <ol>
                    <li>
                        <strong>Забезпечення швидшого відображення контенту:</strong>
                        <ul>
                            <li>озміщення CSS у < head> дозволяє браузеру завантажувати та обробляти стилі перед відображенням вмісту. Це
                                сприяє швидшому відображенню сторінки користувачеві, оскільки стилі вже доступні для використання.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Запобігання блокуванню рендерингу:</strong>
                        <ul>
                            <li>JS-скрипти можуть блокувати процес рендерингу, тому важливо розміщувати < script> перед закриваючим тегом
                                < /body>. Це дозволяє браузеру завантажувати і відображати контент, тоді як скрипти обробляються після того,
                                як сторінка вже відобразилася.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Покращення взаємодії з кешуванням:</strong>
                        <ul>
                            <li>Розміщення JS в кінці дозволяє використовувати кешування стилів під час повторних відвідувань сторінки,
                                оскільки вони не змінюються часто.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Винятки можуть існувати залежно від конкретних потреб проекту або випадків використання. Наприклад, для невеликих
                    сторінок чи проектів може бути прийнятно розмістити CSS та JS в одному файлі чи включати стилі безпосередньо в HTML
                    документ, але це залежить від конкретних обставин.</p>
            </div>
        </li>


        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What is progressive rendering?
            </div>
            <div class="collapsible-body">
                <p>Прогресивний рендеринг (Progressive Rendering) - це підхід до відображення веб-сторінок, за яким контент поступово
                    виводиться на екран для користувача, по мірі його завантаження та обробки. Це поліпшує враження від швидкості
                    завантаження сторінки, особливо на повільних інтернет-з'єднаннях або на пристроях з обмеженими ресурсами.</p>
                <p>Прогресивний рендеринг може включати в себе кілька аспектів:</p>
                <ol>
                    <li>
                        <strong>Поступове завантаження контенту:</strong>
                        <p>Спочатку на екран виводяться основні елементи сторінки, такі як текст та зображення низької роздільної здатності.
                            Потім, по мірі завантаження більше ресурсів, контент оновлюється та відображається у вищій якості.</p>
                    </li>
                    <li>
                        <strong>Ліниве завантаження зображень (Lazy Loading):</strong>
                        <p>Зображення завантажуються тільки тоді, коли вони з'являються в області видимості користувача. Це допомагає
                            зменшити час завантаження сторінки, оскільки не всі зображення обробляються одночасно.</p>
                    </li>
                    <li>
                        <strong>Поступова підгрузка контенту:</strong>
                        <p>Контент, який знаходиться внизу сторінки, може завантажуватися та виводитися поетапно, навіть якщо верхня частина
                            сторінки вже відобразилася.</p>
                    </li>
                </ol>
                <p>Прогресивний рендеринг дозволяє користувачам швидше отримати доступ до основного контенту сторінки, забезпечуючи краще
                    враження від її продуктивності, навіть під час нестабільного або повільного з'єднання з Інтернетом.</p>

                <h6>Для реалізації прогресивного рендерингу та поліпшення швидкості завантаження веб-сторінок можна використовувати різні
                    способи та інструменти:</h6>
                <ol>
                    <li>
                        <strong>Ліниве завантаження зображень (Lazy Loading):</strong>
                        <ul>
                            <li>Використовуйте атрибут loading для тегів < img>, наприклад: < img src="image.jpg" loading="lazy">.</li>
                            <li>Використовуйте JavaScript для лінивого завантаження зображень, наприклад, бібліотеку LazyLoad.js.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Асинхронне завантаження ресурсів:</strong>
                        <ul>
                            <li>Використовуйте атрибут async для тегів < script> для асинхронного завантаження скриптів.</li>
                            <li>Розміщуйте скрипти, які не блокують відображення контенту, перед закриваючим тегом < /body>.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Поступове завантаження контенту:</strong>
                        <ul>
                            <li>Виводьте основний текст та блоки контенту першими, навіть якщо інші ресурси ще не завантажені.</li>
                            <li>Використовуйте анімації або переходи для зменшення відчуття затримки при поступовому завантаженні.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Збереження та використання кешу:</strong>
                        <ul>
                            <li>Використовуйте HTTP-кешування для збереження ресурсів на стороні клієнта.</li>
                            <li>Використовуйте сервісні роботи (Service Workers) для створення власного кешу та управління ресурсами в
                                офлайн-режимі.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Інструменти для аналізу та оптимізації:</strong>
                        <ul>
                            <li>Використовуйте інструменти для аналізу завантаження сторінки, такі як Lighthouse, PageSpeed Insights або
                                WebPageTest.
                            </li>
                            <li>Використовуйте інструменти для оптимізації зображень, наприклад, ImageOptim або TinyPNG.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Why you would use a srcset attribute in an image tag? Explain the process the browser uses when evaluating the content of
                this attribute.
            </div>
            <div class="collapsible-body">
                <p>Атрибут srcset в тегу < img> використовується для вказання різних версій зображення з різною роздільною здатністю чи
                    розміром. Це дозволяє браузерам вибирати оптимальну версію зображення, враховуючи характеристики пристрою та екрана
                    користувача, що покращує продуктивність та ефективність завантаження сторінок.</p>
                <p>Процес оцінки вмісту атрибута srcset браузером виглядає наступним чином:</p>
                <ol>
                    <li>
                        <strong>Браузер отримує список доступних ресурсів:</strong>
                        <p>Атрибут srcset містить список URL зображень та відповідних розмірів чи роздільних здатностей.
                            <br>
                            < img srcset="image-320w.jpg 320w, image-480w.jpg 480w, image-800w.jpg 800w" src="default.jpg"
                            alt="Description">
                        </p>
                    </li>
                    <li>
                        <strong>Браузер оцінює умови відображення:</strong>
                        <p>Браузер аналізує характеристики пристрою та екрана, такі як розмір екрана, роздільна здатність, піксельна
                            щільність тощо.</p>
                    </li>
                    <li>
                        <strong>Браузер вибирає оптимальне зображення:</strong>
                        <p>На основі аналізу, браузер вибирає найбільш підходяще зображення зі списку, яке відповідає умовам відображення.
                            Це може бути зображення з найбільшою роздільною здатністю або оптимальним розміром для пристрою.</p>
                    </li>
                    <li>
                        <strong>Браузер завантажує вибране зображення:</strong>
                        <p>Обране зображення завантажується та відображається на сторінці.</p>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке спрайт в html?
            </div>
            <div class="collapsible-body">
                <p>У HTML термін "спрайт" може вказувати на дві різні речі: CSS-спрайти та SVG-спрайти.</p>
                <ol>
                    <li>
                        <strong>CSS-спрайт (CSS Sprites):</strong>
                        <p>CSS-спрайт є методом оптимізації завантаження сторінки, коли кілька малих зображень об'єднуються в одне велике
                            зображення (спрайт). Замість того, щоб завантажувати кожне зображення окремо, браузер лише завантажує одне
                            зображення, і CSS використовується для відображення потрібної частини спрайту на сторінці.</p>

                        <strong>Спосіб імплементації: </strong>
                        <ul>
                            <li>
                                <strong>Підготовка зображень:</strong>
                                <p>Збережіть всі малі зображення, які ви хочете об'єднати в спрайт, в одній текі. Зазвичай, це іконки,
                                    кнопки або інші графічні елементи.</p>
                            </li>
                            <li>
                                <strong>Створення спрайта:</strong>
                                <p>Використайте інструмент для створення спрайтів, такий як SpritePad, SpriteMe, або TexturePacker, або
                                    створіть його самостійно за допомогою графічного редактора.</p>
                                <p>Розташуйте всі малі зображення на одному великому листі, за можливість використовуйте прогалини між
                                    ними.</p>
                            </li>
                            <li>
                                <strong>Збереження спрайта:</strong>
                                <p>Збережіть створений спрайт у форматі зображення (зазвичай PNG або JPEG).</p>
                            </li>
                            <li>
                                <strong>Використання CSS:</strong>
                                <p>Визначте клас для елементу, який ви хочете оформити за допомогою CSS-спрайта.
                                    <br>
                                <pre>
                                        .icon {
                                           width: 30px;
                                           height: 30px;
                                           background-image: url('sprites.png');
                                        }
                                    </pre>
                                </p>
                                <p>Визначте позицію конкретного зображення на спрайті за допомогою background-position. Це вказує, яка
                                    частина спрайта повинна бути відображена.</p>
                                <pre>
                                    .icon-home {
                                       background-position: 0 0;
                                    }

                                    .icon-email {
                                       background-position: 0 -40px;
                                    }
                                </pre>
                            </li>
                            <li>
                                <strong>Використання в HTML:</strong>
                                <p>Додайте HTML-елемент із вказаним класом та визначте, яке зображення має бути відображене.</p>
                                <p>< div class="icon icon-home">< /div> < div class="icon icon-email">< /div>
                                </p>
                            </li>
                        </ul>
                        <p>Це дозволить вам зменшити кількість HTTP-запитів, які потрібно робити для завантаження різних зображень, і
                            покращити швидкість завантаження сторінки.</p>
                    </li>
                    <li>
                        <strong>SVG-спрайт (SVG Sprites):</strong>
                        <p>SVG-спрайт об'єднує кілька SVG-зображень в один файл. Це полегшує керування та завантаженням багатьох SVG-ікон на
                            сторінку.</p>
                    </li>
                </ol>
                <p>Обидва ці методи дозволяють оптимізувати завантаження зображень та покращувати продуктивність сторінки. Однак вони
                    використовуються для різних типів зображень та мають свої відмінності у використанні.</p>
                <p>
                <pre>
                        < svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                           < symbol id="icon-home" viewBox="0 0 24 24">
                    <!-- SVG код для іконки дому -->
                           < /symbol>
                           < symbol id="icon-email" viewBox="0 0 24 24">
                    <!-- SVG код для іконки електронної пошти -->
                           < /symbol>
                        < /svg>

                        < svg class="icon">
                           < use xlink:href="#icon-home">< /use>
                        < /svg>

                        < svg class="icon">
                           < use xlink:href="#icon-email">< /use>
                        < /svg>

                    </pre>
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are empty elements in HTML ?
            </div>
            <div class="collapsible-body">
                <p>Empty elements в HTML — це теги, які не мають контенту або вмісту і закриваються самими собою. У таких тегів немає
                    парного тегу закриття, і вони мають спеціальний синтаксис для короткого запису.</p>
                <p>Наприклад, тег < br> (ламання рядка) або < img> (зображення) є прикладами empty elements:</p>
                <p>Інші приклади empty elements включають теги, такі як < input>, < meta>, < link>, і < hr>. Вони використовуються для
                    вставки елементів, які не мають контенту або потребують мінімального оформлення.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are HTML Attributes?
            </div>
            <div class="collapsible-body">
                <p>
                    Атрибути - це властивості, які можна додавати до тегу HTML. Ці атрибути змінюють спосіб, яким тег веде себе або
                    відображається. Наприклад, у тега < img> є атрибут src, який використовується для вказівки джерела, з якого слід
                    відображати зображення.</p>
                <p>Ми додаємо атрибути одразу після імені тегу HTML, всередині дужок. Ми можемо додавати атрибути тільки до відкриваючих або
                    самозакриваючих тегів, але ніколи не до закриваючих тегів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Explain the difference between layout, painting and compositing.
            </div>
            <div class="collapsible-body">
                <p>Концепції компонування (layout), фарбування (painting) і композиції (compositing) є важливими для розуміння того, як
                    браузери відображають веб-сторінки.</p>
                <ol>
                    <li>
                        <strong>Компонування (Layout):</strong>
                        <p>Компонування — це процес визначення розташування та розмірів всіх елементів на сторінці відповідно до
                            CSS-властивостей та макету. Це включає визначення положення та розмірів блоків, тексту, відступів і так
                            далі.</p>
                    </li>
                    <li>
                        <strong>Фарбування (Painting):</strong>
                        <p>Фарбування — це процес, коли браузер заповнює контент сторінки кольорами та текстурами відповідно до властивостей
                            стилів. Відбувається визначення кінцевого вигляду кожного елемента на основі його стилів.</p>
                    </li>
                    <li>
                        <strong>Композиція (Compositing):</strong>
                        <p>Композиція — це процес, коли браузер об'єднує вже нарисовані та відфарбовані елементи на екрані, створюючи
                            кінцевий вигляд сторінки. Це включає в себе управління прозорістю, насиченістю, зміщенням та іншими
                            ефектами.</p>
                    </li>
                </ol>
                <p>Взаємодія цих процесів є неперервним і складається з декількох етапів, що дозволяють браузерам ефективно та швидко
                    рендерити складні веб-сторінки.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Коменти в CSS, HTML & JS
            </div>
            <div class="collapsible-body">
                <p>
                    Коментарі в CSS, HTML і JavaScript використовуються для надання пояснень коду і не впливають на виконання програми чи
                    рендеринг вмісту веб-сторінки. Ось як вони виглядають у кожній з цих мов:</p>
                <p>/* Це коментар в CSS */</p>
                <p><!-- Це коментар в HTML --></p>
                <p>// Це однорядковий коментар в JavaScript</p>
                <p>
                <pre>
                        /*
                           Це багаторядковий
                           коментар в JavaScript
                        */
                    </pre>
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Семантика HTML
            </div>
            <div class="collapsible-body">
                <p>Семантика в HTML відноситься до практики використання елементів мови розмітки HTML таким чином, щоб вони передавали
                    значення щодо структури та змісту веб-сторінки. Семантичне HTML допомагає як браузерам, так і розробникам розуміти
                    призначення та роль різних частин вмісту. Це покращує доступність, оптимізацію для пошукових систем та загальну
                    структуру документа.</p>

                <ol>
                    <li>
                        <strong>header</strong>
                        <p>Визначає верхню частину сторінки або розділ заголовків.</p>
                    </li>
                    <li>
                        <strong>nav</strong>
                        <p>Вказує на навігаційний блок сторінки.</p>
                    </li>
                    <li>
                        <strong>main</strong>
                        <p>Визначає основний контент сторінки, який не є частиною заголовка, навігації, або підвалу.</p>
                    </li>
                    <li>
                        <strong>article</strong>
                        <p>Визначає незалежний контент, такий як новина або стаття.</p>
                    </li>
                    <li>
                        <strong>section</strong>
                        <p>Визначає розділ документа, наприклад, групу пов'язаних статей або блоків контенту.</p>
                    </li>
                    <li>
                        <strong>aside</strong>
                        <p>Вказує на контент, який стоїть окремо від основного контенту, наприклад, бічні бокові панелі.</p>
                    </li>
                    <li>
                        <strong>footer</strong>
                        <p>Визначає нижню частину сторінки або розділ підвалу.</p>
                    </li>
                    <li>
                        <strong>figure | figcaption</strong>
                        <p> визначає автономний контент, такий як зображення, відео або графіка | визначає підпис до контенту відповідно</p>
                    </li>
                    <li>
                        <strong>time</strong>
                        <p>Вказує на час або дату, наприклад, використовується для позначення публікацій або подій.</p>
                    </li>
                    <li>
                        <strong>mark</strong>
                        <p>Визначає текст, який виділяється або підсвічується для наголошення важливості.</p>
                    </li>
                </ol>

                <p>Ці семантичні елементи допомагають чітко визначити роль кожного блоку вмісту на сторінці та полегшують розуміння
                    структури документа.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Shadow DOM
            </div>
            <div class="collapsible-body">
                <p>Shadow DOM (об'єктна модель відображення) - це технологія веб-розробки, яка дозволяє ізолювати і вкладати веб-компоненти
                    (елементи) так, щоб їх стилі та логіка не впливали на стилі та логіку інших елементів на сторінці.</p>
                <p>Shadow DOM дозволяє створювати веб-компоненти з покращеною ізоляцією, зменшує вплив стилів та логіки компонентів на решту
                    сторінки та дозволяє підтримувати більшу структуру та порядок в коді.</p>

                <p>Shadow DOM має кілька важливих використань (use cases) у веб-розробці. Ось декілька сценаріїв, де використання Shadow DOM
                    є корисним:</p>
                <ol>
                    <li>
                        <strong>Ізоляція Стилів і Логіки:</strong>
                        <p>Shadow DOM дозволяє ізолювати стилі та логіку веб-компонентів від стилів інших частин сторінки. Це дозволяє
                            розробникам створювати компоненти, які не будуть конфліктувати зі стилями інших елементів.</p>
                    </li>
                    <li>
                        <strong>Створення Компонентів:</strong>
                        <p>Shadow DOM є ідеальним інструментом для створення власних кастомних веб-компонентів. Ви можете використовувати
                            Shadow DOM для створення ізольованого середовища для власного компонента, що дозволяє використовувати його
                            безпосередньо в HTML-документах, забезпечуючи при цьому його ізоляцію від зовнішніх стилів і скриптів.</p>
                    </li>
                    <li>
                        <strong>Розширення Функціональності</strong>
                        <p>Shadow DOM дозволяє розробникам розширювати стандартні HTML елементи та створювати елементи з новою
                            функціональністю. Наприклад, ви можете створити кнопку з власними стилями та подіями, які не впливатимуть на
                            інші кнопки на сторінці.</p>
                    </li>
                    <li>
                        <strong>Покращення Структури Коду</strong>
                        <p>Використання Shadow DOM сприяє покращенню структури коду, оскільки ви можете розділити логіку та стилі вашого
                            компонента від іншого коду сторінки. Це допомагає підтримувати чистоту коду та полегшує розуміння та модифікацію
                            компонентів.</p>
                    </li>
                    <li>
                        <strong>Зменшення Впливу</strong>
                        <p>Shadow DOM дозволяє вам створювати компоненти, які мають мінімальний вплив на інші частини сторінки. Це особливо
                            важливо в ситуаціях, коли ви використовуєте сторонні бібліотеки або компоненти, і хочете уникнути конфліктів
                            імен та стилів.</p>
                    </li>
                </ol>
                <p>Ці використання демонструють, як Shadow DOM може бути корисним для покращення ізоляції та підтримки компонентного підходу
                    у веб-розробці.</p>

                <p><strong>Як створити такий елемент?</strong></p>
                <ol>
                    <li>
                        Створюємо < div id="shadow-host">Host Element< /div> - базовий стардартний елемент, з якого робитимемо тіневий DOM
                    </li>
                    <li>
                        За допомогою JavaScript створюється тіневий DOM для shadow-host за допомогою attachShadow.
                    </li>
                    <li>В Shadow DOM додається < p> елемент з текстом "This is a Shadow DOM element."</li>
                    <li>Також додається стиль для < p> елемента в межах Shadow DOM.</li>
                    <li>Основний DOM і тіневий DOM ізольовані, і стилі з Shadow DOM не впливають на елементи за межами Shadow DOM.</li>
                    <li>
                        <pre>
                            // Отримуємо елемент, який буде господарем тіневого DOM
                            const shadowHost = document.getElementById('shadow-host');

                            // Створюємо Shadow DOM
                            const shadowRoot = shadowHost.attachShadow({ mode: 'open' });

                            // Створюємо елемент в Shadow DOM
                            const shadowElement = document.createElement('p');
                            shadowElement.textContent = 'This is a Shadow DOM element.';

                            // Додаємо стилі для Shadow DOM елемента
                            const style = document.createElement('style');
                            style.textContent = `
                              p {
                                color: blue;
                                font-style: italic;
                              }
                            `;
                            shadowRoot.appendChild(style);

                            // Додаємо Shadow DOM елемент до Shadow DOM
                            shadowRoot.appendChild(shadowElement);
                        </pre>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Яка роль тегу < meta> в HTML?
            </div>
            <div class="collapsible-body">
                Тег < meta> надає додаткову інформацію про веб-сторінку, таку як автор, опис і ключові слова. Він розташований в межах
                секції < head> HTML-документа.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Яка роль атрибуту method в формах HTML?
            </div>
            <div class="collapsible-body">
                <p>Атрибут method використовується для вказівки HTTP-методу, який буде використовуватися для відправки даних форми. Два
                    найбільш поширені методи - GET і POST.
                </p>
                <ul>
                    <li>GET - Використовується для отримання даних з сервера. Дані відправляються через URL, видимі в адресному рядку
                        браузера.
                    </li>
                    <li>POST - Використовується для відправлення даних на сервер для обробки. Дані відправляються через тіло HTTP-запиту, що
                        робить їх прихованими.
                    </li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке Гідратація?
            </div>
            <div class="collapsible-body">
                <p>Гідратація - це просто процес приєднання поведінки JavaScript до HTML-елементів, які були згенеровані на сервері. Це
                    необхідно для створення інтерактивної веб-сторінки, що дозволяє користувачам натискати кнопки, заповнювати форми та
                    виконувати інші дії. Без гідратації веб-сторінки були б статичними та неспроможними реагувати.</p>
                <p>У випадку Server-side Rendering (SSR), HTML та JavaScript генеруються на сервері і відсилаються на клієнт у вигляді
                    повноцінного документа. Однак цей HTML лише статично представляє сторінку. Гідратація в таких випадках є необхідною для
                    приєднання обробників подій до сторінки, роблячи її інтерактивною. Після завантаження HTML та JavaScript бандлів браузер
                    виконує JavaScript, який приєднує обробники подій до HTML, забезпечуючи повноцінний інтерактивний досвід
                    користувача.</p>
                <p>У випадку Client-side Rendering (CSR), весь JavaScript бандл завантажується та виконується на стороні клієнта, і
                    гідратація не потрібна. JavaScript може безпосередньо маніпулювати HTML-елементами, які він створив, без додаткового
                    етапу гідратації.</p>
                <p>Отже, гідратація є ключовим елементом для створення динамічних та інтерактивних веб-додатків, особливо в контексті
                    рендерингу на стороні сервера.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>


    </ul>


    <h5 id="css">CSS</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Анімації
            </div>
            <div class="collapsible-body">
                <p>Анімація у CSS дозволяє створювати рухливі та привабливі ефекти на веб-сайтах. Ось основні аспекти використання CSS
                    анімації:</p>
                <ol>
                    <li>
                        <strong>Ключові Кадри (Keyframes)</strong>
                        <ul>
                            <li>Ключові кадри визначають стани елемента на різних етапах анімації.</li>
                            <li>Використовуються ключові слова @keyframes для створення набору кадрів.</li>
                            <li>
                                <pre>
                                    @keyframes example {
                                      0% { opacity: 0; }
                                      50% { opacity: 0.5; }
                                      100% { opacity: 1; }
                                    }
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивість animation</strong>
                        <ul>
                            <li>Властивість animation використовується для визначення анімації для елемента.</li>
                            <li>Зазвичай вказується ім'я ключових кадрів та тривалість анімації.</li>
                            <li>.element { animation: example 3s ease-in-out; }</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Опції Таймінгу:</strong>
                        <ul>
                            <li><strong>ease</strong>: починається повільно, прискорюється, а потім знову сповільнюється.</li>
                            <li><strong>linear</strong>: рухається з однаковою швидкістю протягом всієї тривалості.</li>
                            <li><strong>ease-in</strong>: починається повільно, потім прискорюється.</li>
                            <li><strong>ease-out</strong>: починається швидко, потім сповільнюється.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивості animation-delay та animation-iteration-count</strong>
                        <ul>
                            <li><strong>animation-delay</strong> вказує затримку перед початком анімації.</li>
                            <li><strong>animation-iteration-count</strong> визначає кількість повторень анімації.</li>
                            <li>.element { animation-delay: 2s; animation-iteration-count: infinite; }</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Зміна Властивостей:</strong>
                        <ul>
                            <li>Анімація може змінювати різні властивості, такі як розмір, колір, положення тощо.</li>
                            <li><pre>
                                @keyframes example {
                                    0% { transform: scale(1); }
                                    50% { transform: scale(1.5); }
                                    100% { transform: scale(1); }
                                }
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Властивість animation-fill-mode:</strong>
                        <ul>
                            <li>Вказує, яким чином стилі мають застосовуватися до елемента поза межами визначеної анімації.</li>
                            <li>.element { animation: example 3s ease-in-out; animation-fill-mode: forwards; }
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Різниця між Grid & Flexbox
            </div>
            <div class="collapsible-body">
                <p>Розуміння різниці між CSS Grid та Flexbox є ключовим для ефективного проектування макету. Особа, яка проходить інтерв'ю,
                    повинна вміти висловлювати ці різниці та їхні випадки використання.</p>

                <p>CSS Grid - це двовимірна система, яка обробляє як рядки, так і стовпці, ідеальна для масштабних макетів. Flexbox - це
                    одновимірна система, яка обробляє один рядок АБО один стовпець одночасно, найбільш підходить для менших макетів, де
                    елементи
                    повинні вирівнюватися або розподілятися відносно один одного. Подавшись для розташування загальної структури, Grid, як
                    правило, використовується для розташування елементів всередині тих самих комірок Grid.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Методології CSS (BEM, OOCSS, SMACSS)
            </div>
            <div class="collapsible-body">
                <p>Методології CSS — це підходи до написання та організації коду на Cascading Style Sheets (CSS). Кілька популярних
                    методологій включають BEM (Block, Element, Modifier), OOCSS (Object-Oriented CSS) та SMACSS (Scalable and Modular
                    Architecture for CSS).</p>
                <ol>
                    <li>
                        <strong>BEM (Block, Element, Modifier):</strong>
                        <ul>
                            <li>
                                <strong>Блок (Block): </strong>
                                <p>Основний компонент, незалежний від контексту.</p>
                            </li>
                            <li>
                                <strong>Елемент (Element): </strong>
                                <p>Частина блока, яка не має сенсу самостійно, але має сенс в контексті блока.</p>
                            </li>
                            <li>
                                <strong>Модифікатор (Modifier): </strong>
                                <p>Зміна вигляду або стану блока чи елемента.</p>
                            </li>
                        </ul>
                        <strong>Переваги BEM:</strong>
                        <ul>
                            <li>Чітка структура і неймінг, що полегшує розробку та підтримку.</li>
                            <li>Універсальність і висока переносимість компонентів.</li>
                        </ul>
                        <strong>Недоліки BEM:</strong>
                        <ul>
                            <li>Збільшує об'єм HTML-коду через використання багато класів.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>OOCSS (Object-Oriented CSS):</strong>
                        <ul>
                            <li>
                                <strong>Об'єкт (Object):</strong>
                                <p>Відокремлений, повторно використовуваний компонент, який має стилі та властивості.</p>
                            </li>
                            <li>
                                <strong>Зовнішній вигляд (Separation of Concerns):</strong>
                                <p>Розділення структури та оформлення елементів.</p>
                            </li>
                        </ul>
                        <strong>Переваги OOCSS:</strong>
                        <ul>
                            <li>Збільшує повторне використання коду та спрощує його обслуговування.</li>
                            <li>Забезпечує швидше завантаження сторінок через оптимізацію CSS.</li>
                        </ul>
                        <strong>Недоліки OOCSS:</strong>
                        <ul>
                            <li>Може призвести до менш чіткої структури та менш простого коду.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>SMACSS (Scalable and Modular Architecture for CSS):</strong>
                        <ul>
                            <li>
                                <strong>Масштабована (Scalable): </strong>
                                <p>Спроект може зростати без значного збільшення складності CSS.</p>
                            </li>
                            <li>
                                <strong>Модульна (Modular): </strong>
                                <p>Складові частини дизайну повинні бути незалежними та переносимими.</p>
                            </li>
                        </ul>
                        <strong>Переваги SMACSS:</strong>
                        <ul>
                            <li>Сприяє простоті та чіткості в організації коду.</li>
                            <li>Простота управління та вдосконалення проектів через модульний підхід.</li>
                        </ul>
                        <strong>Недоліки SMACSS:</strong>
                        <ul>
                            <li>Може вимагати більше часу та зусиль для вивчення та впровадження.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Переваги використання препроцесорів в проекті
            </div>
            <div class="collapsible-body">
                <p>
                    Процесори CSS, такі як SASS та LESS, розширюють базові можливості CSS. Вони вводять функції, такі як змінні,
                    вкладеність, міксини та успадкування, що робить CSS більш підтримуваним та організованим. Однак вони вимагають процесу
                    збірки, і створений CSS не завжди може бути оптимізованим. Також відладка може бути складнішою через різницю між
                    написаним кодом та компільованим CSS.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Різниця між position: relative & position: absolute
            </div>
            <div class="collapsible-body">
                <p>
                    Відносне та абсолютне позиціонування - це два різних способи розміщення елементів на сторінці веб-сайту.</p>
                <ol>
                    <li>
                        <strong>Відносне позиціонування:</strong>
                        <p>При відносному позиціонуванні елемент зсувається відносно його звичайного положення в документі, при цьому
                            зберігаючи його в поточному потоці документа. Це означає, що інші елементи на сторінці не впливають на цей рух.
                            Наприклад, якщо ми переміщуємо блок на 20px вправо, простір, який він почав займати, залишається незмінним.</p>
                    </li>
                    <li>
                        <strong>Абсолютне позиціонування:</strong>
                        <p>При абсолютному позиціонуванні елемент вилучається з потоку документа, і для нього не створюється простір в
                            макеті сторінки. Елемент позиціонується відносно його найближчого позиціонованого предка (якщо такий є), або, в
                            іншому випадку, відносно тіла документа. Інші елементи на сторінці можуть займати простір, який раніше належав
                            абсолютно позиціонованому елементу.</p>
                    </li>
                </ol>
                <p>Отже, відносне позиціонування зміщує елемент відносно його звичайного положення, залишаючи його в потоці документа, тоді
                    як абсолютне позиціонування вилучає елемент з потоку і позиціонує його відносно певного контейнера.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що необхідно врахувати (CSS) при розробці мультимовного сайту?
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>Розширення тексту:</strong>
                        <p>Різні мови можуть вимагати різної кількості місця для тексту. Переконайтеся, що ваш дизайн може вміщати текстовий
                            контент, щоб уникнути проблем з макетом. Це особливо важливо для мов, які можуть мати значно більше словесного
                            обсягу.</p>
                    </li>
                    <li>
                        <strong>Напрямок читання:</strong>
                        <p>Мови, такі як арабська та іврит, читаються справа наліво. Це може вплинути на макет та навігацію. Переконайтеся,
                            що ваш дизайн правильно відображає напрямок читання для кожної мови.</p>
                    </li>
                    <li>
                        <strong>Кодування символів:</strong>
                        <p>Використовуйте UTF-8 для кодування символів, щоб підтримувати всі можливі символи та мови. Це дозволить коректно
                            відображати текст у всіх мовах.</p>
                    </li>
                    <li>
                        <strong>Кольори та зображення:</strong>
                        <p>Кольори та зображення можуть мати різні культурні конотації. Вибирайте універсально прийняті кольори та
                            зображення, щоб уникнути можливих непорозумінь або несприятливих асоціацій в різних культурах.</p>
                    </li>
                    <li>
                        <strong>Перемикач мови:</strong>
                        <p>Забезпечте видимість та легкість використання перемикача мов. Користувачі повинні легко змінювати мову на сайті,
                            якщо це необхідно. Це може бути особливо важливо для користувачів, які використовують більше однієї мови.</p>
                    </li>
                </ol>
                <p>Ураховуючи ці аспекти, ви забезпечите, що ваш веб-сайт буде ефективним і коректно працюватиме для користувачів різних мов
                    та культур.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Псевдо-елементи та псевдо-класи
            </div>
            <div class="collapsible-body">
                <p>Псевдокласи і псевдоелементи - це обидві концепції в CSS, але вони використовуються для визначення різних частин
                    елементів або стану елемента. Ось їхні основні відмінності:</p>
                <ol>
                    <li>
                        <strong>Псевдокласи:</strong>
                        <ul>
                            <li>Визначають стан або контекст елемента.</li>
                            <li>Позначаються однією двокрапкою (:) перед ім'ям.</li>
                            <li>Приклади псевдокласів: :hover (для стилізації при наведенні), :active (для стилізації активного стану),
                                :nth-child(n) (для вибору елементів за порядковим номером) і т.д.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Псевдоелементи:</strong>
                        <ul>
                            <li>Визначають конкретні частини елемента.</li>
                            <li>Позначаються двома двокрапками (::) перед ім'ям.</li>
                            <li>Приклади псевдоелементів: ::before (додає контент перед елементом), ::after (додає контент після елемента),
                                ::first-line (стилізація першого рядка тексту в елементі) і т.д.
                            </li>
                        </ul>
                    </li>
                </ol>

                <h6>Приклади елементів: </h6>
                <strong>Псевдокласи:</strong>
                <ol>
                    <li>
                        <strong>:hover</strong>
                        <p>Стилізація, яка застосовується, коли користувач наводить курсор на елемент.</p>
                    </li>
                    <li>
                        <strong>:active</strong>
                        <p>Стилізація для активного стану елемента, тобто коли користувач утримує кнопку миші на елементі.</p>
                    </li>
                    <li>
                        <strong>:focus</strong>
                        <p>Стилізація для стану фокусу, що виникає, коли елемент отримує фокус (наприклад, поле вводу).</p>
                    </li>
                    <li>
                        <strong>:nth-child(n)</strong>
                        <p>Вибір елементів за їхнім порядковим номером в батьківському контейнері.</p>
                    </li>
                    <li>
                        <strong>:not(selector)</strong>
                        <p> Вибір всіх елементів, які не відповідають вказаному селектору.</p>
                    </li>
                    <li>
                        <strong>:first-child</strong>
                        <p>Вибір першого елемента в рядку його батьківського контейнера.</p>
                    </li>
                    <li>
                        <strong>:last-child</strong>
                        <p>Вибір останнього елемента в рядку його батьківського контейнера.</p>
                    </li>
                </ol>
                <strong>Псевдоелементи:</strong>
                <ol>
                    <li>
                        <strong>::before</strong>
                        <p> Додає контент до початку вмісту елемента.</p>
                    </li>
                    <li>
                        <strong>::after</strong>
                        <p>Додає контент в кінець вмісту елемента.</p>
                    </li>
                    <li>
                        <strong>::first-line</strong>
                        <p>Стилізація першого рядка тексту в елементі.</p>
                    </li>
                    <li>
                        <strong>::first-letter</strong>
                        <p>Стилізація першої літери тексту в елементі.</p>
                    </li>
                    <li>
                        <strong>::selection</strong>
                        <p>Стилізація виділеного тексту користувачем.</p>
                    </li>
                </ol>

                <p>Загалом, псевдокласи використовуються для визначення стану елемента в різних ситуаціях, тоді як псевдоелементи
                    використовуються для стилізації конкретних частин цього елемента. Обидва підходи дозволяють розширити можливості
                    стилізації веб-сторінок та забезпечити більше гнучкості в роботі з різними частинами контенту.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Вага селекторів (специфічність)
            </div>
            <div class="collapsible-body">
                <p>Специфічність – це алгоритм, що використовується браузерами для визначення того оголошення CSS, яке найбільше відповідає
                    елементові. </p>
                <p>Вага визначається числом селекторів кожної вагової категорії у селекторі, що дає збіг з елементом (чи псевдоелементом).
                    Якщо є два чи більше оголошень, що надають різні значення властивостей для одного елемента, то застосовується значення
                    оголошення із блоку стилів, що має селектор зі збігом з найбільшою алгоритмічною вагою.</p>
                <p>Алгоритм специфічності по суті є триколонковим порівнянням значень трьох категорій чи ваг – ID, CLASS та TYPE – що
                    відповідають трьом типам селекторів. Це значення представляє кількість компонентів селектора з кожної вагової категорії
                    та записується як ID - CLASS - TYPE. Три колонки утворюються шляхом підрахунку кількості компонентів з кожної вагової
                    категорії у селекторах, що відповідають елементові. (Умовно 1-0-0 - кейс для ID)</p>
                <p>
                    Вага селекторів в CSS визначає, який стилізаційний правило має вищий пріоритет у випадку конфлікту між різними
                    правилами. Вага визначається на основі типу селекторів та їхнього порядку в CSS-правилі.</p>
                <p>
                    Каскад CSS визначає, які стилі застосовуються до елемента на основі трьох основних чинників: важливості, специфічності
                    та порядку джерела. Важливість вказує на вагу, яку має правило стилів. Наприклад, вбудовані стилі мають важливість вище,
                    ніж зовнішні таблиці стилів. Специфічність визначається типом селектора, використовуваного в правилі. Селектори ID мають
                    високу специфічність, тоді як селектори класів мають меншу специфічність. Порядок джерела важливий, коли два правила
                    мають рівну важливість і специфічність; застосовуватиметься останнє правило.</p>
                <p><strong>Важливо!</strong> Якщо одинакова вага селекторів, до прикладу, 1-1-1 і 1-1-1 - застосується те правило, яке
                    умовно "нижче" в файлі, скажімо так - перетирає суперника, який "вище".</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Змінні в CSS
            </div>
            <div class="collapsible-body">
                <p>CSS власні властивості, також відомі як змінні, декларуються двоступінчастим процесом. По-перше, їх визначають всередині
                    селектора, префіксуючи назву властивості двома тире (–). Наприклад: –main-color: black;. Це створює змінну з назвою
                    "main-color" і значенням "black".</p>
                <p>По-друге, для використання цих змінних ми використовуємо функцію var(). Синтаксис виглядає так: color: var(–main-color);.
                    Тут движок CSS під час виконання буде замінювати var(–main-color) відповідним значенням ("black").</p>
                <p>Змінні можуть мати глобальний або локальний обсяг. Якщо вони визначені всередині селектора :root, вони стають глобальними
                    і доступними з будь-якої частини документа. Локальні змінні обмежені селектором, в якому вони визначені.</p>
                <p>Вони надають переваги, такі як можливість повторного використання, зменшення зайвості та полегшення створення тем. Проте
                    перед використанням їх слід перевірити сумісність з браузерами, оскільки не всі браузери підтримують цю
                    функціональність.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як можна оптимізувати CSS для кращого перформансу?
            </div>
            <div class="collapsible-body">
                <p>Оптимізація CSS для поліпшення продуктивності включає кілька стратегій. Мініфікація, яка видаляє непотрібні символи з
                    коду без зміни функціональності, може зменшити розмір файлу та поліпшити час завантаження. Стиснення Gzip додатково
                    зменшує розмір файлу, знаходячи схожі рядки в текстовому файлі і тимчасово їх замінюючи, щоб узагальнений розмір файлу
                    став меншим.</p>
                <p>Ще одна стратегія - використання скорочених властивостей в CSS, що дозволяє встановлювати значення кількох пов'язаних
                    властивостей одночасно. Це не тільки робить ваш код більш зрозумілим, але й зменшує його розмір.</p>
                <p>Ще одна стратегія - використання скорочених властивостей в CSS, що дозволяє встановлювати значення кількох пов'язаних
                    властивостей одночасно. Це не тільки робить ваш код більш зрозумілим, але й зменшує його розмір.</p>
                <p>Селектори CSS також слід оптимізувати. Уникайте складних або зайвих селекторів нащадків, що може допомогти браузерам
                    швидше визначати селектори. Також розміщення таблиць стилів у верхній частині вашого HTML-документа забезпечує
                    прогресивний рендеринг, дозволяючи користувачам бачити стилі раніше.</p>
                <p>Нарешті, використання зовнішніх таблиць стилів замість вбудованих допомагає із кешуванням, зменшуючи кількість даних, які
                    потрібно завантажити при повторному відвідуванні сторінки.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Селектори атрибутів
            </div>
            <div class="collapsible-body">
                <p>Селектори атрибутів в CSS визначають елементи HTML на основі їх атрибутів та значень атрибутів. Вони використовуються для
                    стилізації елементів з конкретними атрибутами чи значеннями атрибутів.</p>
                <p>Існує чотири типи селекторів атрибутів:</p>
                <ol>
                    <li>
                        <strong>[attribute]</strong>
                        <p> Вибирає елементи з вказаним атрибутом, незалежно від його значення.</p>
                    </li>
                    <li>
                        <strong>[attribute=value]</strong>
                        <p>Відповідає елементам з конкретним значенням атрибуту1</p>
                    </li>
                    <li>
                        <strong>[attribute~=value]</strong>
                        <p>Спрямовується на елементи, значення атрибуту яких є списком значень, розділених пробілами, одне з яких відповідає
                            'value'.</p>
                    </li>
                    <li>
                        <strong>[attribute|=value]</strong>
                        <p>Застосовує стилі до елементів зі значенням атрибуту, яке точно дорівнює 'value' або починається з 'value-'.</p>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Позиціонування елементів - "relative", "absolute", "fixed" та "sticky"
            </div>
            <div class="collapsible-body">
                <p>У CSS позиціонування "relative", "absolute", "fixed" та "sticky" мають свої відмінності:</p>
                <ol>
                    <li>
                        <strong>Relative (відносне) позиціонування:</strong>
                        <p>Переміщує елемент відносно його звичайного положення, не впливаючи на оточуючі елементи. Зсув визначається
                            відносно початкового положення.</p>
                    </li>
                    <li>
                        <strong>Absolute (абсолютне) позиціонування:</strong>
                        <p>Забирає елемент з потоку документа. Його положення встановлюється відносно його найближчого позиціонованого
                            предка або контейнера, якщо такого немає.</p>
                    </li>
                    <li>
                        <strong>Fixed (фіксоване) позиціонування:</strong>
                        <p>Теж забирає елемент з потоку документа, але розташовує його відносно видимої області. Він залишається на місці,
                            навіть коли сторінка прокручується.</p>
                    </li>
                    <li>
                        <strong>Sticky (приліплене) позиціонування:</strong>
                        <p>Це гібридний тип, який веде себе як "relative" до певного моменту прокрутки, а потім діє як "fixed". Це дозволяє
                            елементу "прилипати" до верхньої частини екрану під час прокрутки.</p>
                    </li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Препроцесори
            </div>
            <div class="collapsible-body">
                <p>
                    CSS-препроцесори, такі як SASS, розширюють функціональність базового CSS, вводячи такі можливості, як змінні,
                    вкладеність, міксіни та успадкування. Ці можливості роблять код більш обслуговуваним, переадресованим та
                    масштабованим.</p>
                <p>Використовується SASS для створення адаптивного веб-дизайну в т.ч. Наприклад, змінні для
                    кольорових схем та розмірів шрифтів, що дозволило легко змінювати ці елементи на всьому веб-сайті за допомогою лише
                    однієї зміни значення змінної.</p>
                <p>Міксіни для повторного використання блоків стилів, які часто застосовувалися до різних компонентів. Це зменшило зайвість
                    і покращило читабельність. Вкладеність була ще однією корисною можливістю; вона допомагала тримати пов'язані стилі
                    разом, роблячи таблицю стилів легшею для навігації.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Одиниці вимірювання CSS
            </div>
            <div class="collapsible-body">
                <p>
                    В CSS існує кілька одиниць вимірювання, і кожна з них має свої особливості та використання. Ось кілька основних
                    одиниць:</p>
                <ol>
                    <li>
                        <strong>px (пікселі):</strong>
                        <p>Це абсолютна одиниця вимірювання. Значення вказується в пікселях, які є найменшими екранними елементами. px
                            зручно використовувати для фіксованих розмірів та положень.</p>
                    </li>
                    <li>
                        <strong>em:</strong>
                        <p>Вказує розмір відносно розміру шрифта батьківського елемента. Якщо розмір шрифта батька рівний 16px, 1em буде
                            такий самий, як 16px.</p>
                    </li>
                    <li>
                        <strong>rem (кореневий em):</strong>
                        <p>Подібний до em, але відноситься до розміру шрифта кореневого елемента (зазвичай до елемента < html>). rem
                            зручно використовувати для забезпечення консистентного масштабування шрифтів усієї сторінки.</p>
                    </li>
                    <li>
                        <strong>% (відсотки):</strong>
                        <p>Вказує розмір відносно розміру батьківського елемента. Наприклад, якщо ширина батьківського елемента - 200px, 50%
                            буде рівно 100px.</p>
                    </li>
                    <li>
                        <strong>vw та vh (ширина та висота видимого вікна):</strong>
                        <p>Вказують розмір відносно ширини та висоти видимого вікна відповідно. Наприклад, 1vw представляє 1% ширини
                            видимого вікна.</p>
                    </li>
                    <li>
                        <strong>ch (ширина символу "0"):</strong>
                        <p>Вказує розмір відносно ширини символу "0" у поточному шрифті.</p>
                    </li>
                </ol>
                <p>Коли краще використовувати кожну з цих одиниць залежить від конкретного контексту та потреб вашого проекту. Зазвичай,
                    використання відносних одиниць (em, rem, %, vw, vh) дозволяє створювати більш гнучкий та адаптивний дизайн.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                What steps do you take to ensure your websites are accessible to all users, including those with visual impairments?
            </div>
            <div class="collapsible-body">
                <p>Забезпечення доступності веб-сайтів для користувачів з візуальними порушеннями передбачає використання ряду
                    стратегій.</p>
                <ol>
                    <li>
                        <strong>Використовуйте семантичний HTML</strong>
                        <p>Використання тегів з їх призначенням допомагає створити змістовною структуру, яка легше інтерпретується читачами
                            екрану.</p>
                    </li>
                    <li>
                        <strong>Впроваджуйте ролі та властивості ARIA:</strong>
                        <p>Застосовуйте ARIA для покращення семантики елементів, особливо коли семантичний HTML недостатній.</p>
                        <hr>
                        <strong>ARIA</strong>
                        <p>ARIA (Accessible Rich Internet Applications) — це набір стандартів, які допомагають поліпшити доступність
                            веб-сайтів та веб-додатків для осіб із обмеженими можливостями, зокрема для користувачів з вадами зору або
                            моторики. ARIA додає додаткову інформацію та позначення до елементів HTML, щоб допомогти технологіям допомоги,
                            таким як читачі екрану, краще інтерпретувати та взаємодіяти з контентом.</p>
                        <p>Деякі основні ролі та властивості ARIA включають:</p>
                        <ol>
                            <li>
                                <strong>Ролі:</strong>
                                <ul>
                                    <li>role="navigation": Вказує, що елемент є навігаційним блоком.</li>
                                    <li>role="button": Вказує, що елемент є кнопкою.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Властивості:</strong>
                                <ul>
                                    <li>aria-labelledby: Вказує ідентифікатор елемента, який слід використовувати для надання опису.</li>
                                    <li>aria-hidden="true": Приховує елемент від технологій допомоги.</li>
                                </ul>
                            </li>
                        </ol>
                        <p>Приклад використання ARIA може виглядати так: < button aria-label="Close" onclick="closePopup()">X< /button></p>
                        <p>У цьому прикладі, aria-label вказує на альтернативний текст для кнопки, який буде використовуватися технологіями
                            допомоги. ARIA може бути особливо корисним, коли семантичний HTML не надає достатньої інформації для
                            користувачів з вадами.</p>
                    </li>
                    <li>
                        <strong>Дбайте про контраст кольорів:</strong>
                        <p>Забезпечте достатній контраст між текстом та фоном для полегшення читання особам з кольоровим сліпим або низьким
                            зіром.</p>
                    </li>
                    <li>
                        <strong>Забезпечуйте доступність клавіатури:</strong>
                        <p>Переконайтеся, що всі функції можна використовувати за допомогою клавіатури, особливо корисно для тих, хто не
                            може використовувати мишу.</p>
                    </li>
                    <li>
                        <strong>Включайте альтернативний текст для зображень:</strong>
                        <p>Додавання опису для зображень допомагає людям, які використовують читачі екрану, зрозуміти їхній зміст.</p>
                    </li>
                    <li>
                        <strong>Розробляйте адаптивні макети:</strong>
                        <p>Використовуйте властивості позиції CSS для створення адаптивних макетів, які легко пристосовуються до різних
                            розмірів екрану.</p>
                    </li>
                    <li>
                        <strong>Регулярно тестуйте з технологіями допомоги:</strong>
                        <p>Використовуйте різноманітні технології допомоги для тестування доступності та виявлення можливих проблем.</p>
                    </li>
                </ol>
                <p>Ці поради спрямовані на створення веб-сайтів, які будуть доступними для всіх користувачів, включаючи тих, у кого є
                    візуальні порушення.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="security">Security</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Кращі практики безпеки веб-додатків
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>Валідація вхідних даних</strong>
                        <p>Однією з основних атак, на які піддаються веб-програми, є атака на вхідні дані. Розробники
                            повинні завжди перевіряти та валідувати дані, які отримують від користувачів, щоб запобігти
                            SQL-ін'єкції, крос-сайтовий скриптинг (XSS) та інші атаки.</p>
                    </li>
                    <li>
                        <strong>Захист від автентифікації та керування сеансами</strong>
                        <p>Керування сеансами та автентифікація користувачів - це ключові аспекти безпеки веб-додатків.
                            Надійна автентифікація з використанням сильних паролів та двофакторної автентифікації є
                            обов'язковою. Крім того, сесії користувачів мають бути захищені від перехоплення та
                            підробки.</p>
                    </li>
                    <li>
                        <strong>Оновлення та патчі</strong>
                        <p>Регулярне оновлення та встановлення патчів для веб-додатків, бібліотек та фреймворків, що
                            використовуються, - це обов'язкова умова для забезпечення безпеки. Уразливості, виявлені у
                            сторонніх компонентах, можуть стати легкою здобиччю для зловмисників.</p>
                    </li>
                    <li>
                        <strong>Обмеження прав доступу</strong>
                        <p>Застосування принципу найменших привілеїв (Least Privilege) є важливим для зменшення ризиків.
                            Користувачі та компоненти програми повинні мати лише права доступу, які необхідні для
                            виконання своїх завдань.</p>
                    </li>
                    <li>
                        <strong>Моніторинг та журналювання</strong>
                        <p>Ведення журналів дій користувачів та системних подій дозволяє виявляти аномалії та атаки у
                            реальному часі. Моніторинг дозволяє оперативно реагувати на загрози та запобігати витоку
                            даних.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Основні види вразливостей веб-застосунків
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>SQL-ін'єкції</strong>
                        <p>SQL-ін'єкції виникають, коли зловмисник впроваджує шкідливий SQL-код у запити до бази даних.
                            Це може призвести до незаконного доступу до даних або їх зміни. Правильна валідація та
                            використання параметризованих запитів допомагають запобігти SQL-ін'єкції.</p>
                        <p>SQL ін’єкція (SQLi) — це тип ін’єкційної атаки, яка дозволяє модифікувати SQL команди для
                            отримання даних або виведення з ладу програми. Зловмисники можуть модифікувати команди SQL,
                            які впливають на ваш застосунок, через деякі вхідні дані на вашому сайті, наприклад, поле
                            пошуку.</p>
                        <p>Успішне виконання SQL ін’єкції може призвести до неавторизованого доступу до конфіденційних
                            даних (це може бути дуже «чутлива» інформація — наприклад, паролі, адреси, дані кредитних
                            карток і так далі). За останні кілька років багато випадків витоку інформації стали
                            результатом саме SQL ін’єкцій.</p>
                    </li>
                    <li>
                        <strong>Крос-сайтовий скриптинг (XSS - Cross-Site Scripting)</strong>
                        <p>XSS - це атака, за якої зловмисник впроваджує шкідливий JavaScript-код у веб-сторінку, який
                            виконується у браузері користувача. Захист від XSS включає екранування даних і використання
                            Content Security Policy (CSP).</p>
                        <p>Головна ідея XSS в тому, що зловмиснику вдається додати на сторінку JavaScript-код, якого до
                            цього не було. Цей код буде виконуватися щоразу, коли жертви (тобто користувачі)
                            заходитимуть на сторінку застосунку, де цей код додав зловмисник.</p>
                        <p>XSS вразливість виникає при генерації HTML-сторінки, коли розробнику потрібно помістити туди
                            дані, вказані користувачем. Якщо хакер зможе розмістити довільний HTML-код, то отримає
                            доступ до змін та керування відображенням вебсторінки з правами самого сайту.</p>
                        <p>Наслідки від XSS ін’єкції можуть бути критичними. Так, дана ін’єкція не впливає безпосередньо
                            на застосунок, вона спрямована на користувача. Проте зловмисник може вкрасти авторизаційні
                            cookie користувача застосунку і тим самим його сесію. Також може перенаправити користувача
                            на власний сайт, де розмістить форми вводу, схожі на оригінальні. І якщо користувач введе
                            свої дані, то вони опиняться у зловмисника. Можливість для безперешкодного експлуатування
                            XSS ін’єкції у застосунку може призвести до витоку даних та суттєвих репутаційних втрат для
                            компанії.</p>
                    </li>
                    <li>
                        <strong>Крос-сайтова підробка запиту (CSRF - Cross-Site Request Forgery)</strong>
                        <p>CSRF - це атака, коли зловмисник змушує користувача виконувати небажані дії без його згоди.
                            Захист від CSRF включає використання токенів запитів (CSRF-токени) і перевірку
                            Referer-заголовка.</p>
                    </li>
                    <li>
                        <strong>Недоліки автентифікації та керування сеансами</strong>
                        <p>Слабка автентифікація та керування сеансами можуть призвести до компрометації облікових
                            записів користувачів. Для захисту слід використовувати сильні паролі, двофакторну
                            автентифікацію та надійне керування сеансами.</p>
                        <p><strong>Автентифікація</strong> — це дії, вжиті для встановлення або перевірки чогось або когось. Це процедура
                            встановлення належності користувачеві
                            інформації в системі пред’явленого ним ідентифікатора. В інформаційній безпеці автентифікація є частиною
                            процедури надання доступу користувачу для
                            роботи в застосунку, наступною після ідентифікації та передує авторизації.</p>
                        <p>Автентифікація дуже важливий функціонал застосунку, оскільки дозволяє реалізувати безпечний доступ до даних.
                            Кожен користувач хоче бути впевнений у тому, що його дані неможливо забрутфорсити й вони зберігаються безпечно.
                            В результаті шлях користувача в системі виглядає приблизно так: спочатку користувача ідентифікується з
                            ідентифікатором користувача, а після цього виконується автентифікація на основі наданого користувачем пароля,
                            який відповідає цьому ідентифікатору.</p>
                        <p>Вразливості автентифікації можуть виникати з різних причин, тому немає єдиного алгоритму їх пошуку. Серед
                            найбільш поширених вразливостей можна перерахувати наступні:</p>
                        <ul>
                            <li>атака перебору імені користувача та пароля</li>
                            <li>відсутність перевірки складності пароля</li>
                            <li>некоректний менеджмент сесії</li>
                            <li>неправильна реалізація функціонала зміни та відновлення пароля</li>
                            <li>атаки на JWT токени тощо.</li>
                        </ul>
                        <p>Проблема вразливості автентифікації є однією з найпростіших проблем для розуміння ризиків. І водночас вони можуть
                            бути одними з найбільш критичних через очевидний зв’язок між автентифікацією та безпекою. Крім того, що проблеми
                            автентифікації потенційно дозволяють зловмисникам отримати прямий доступ до конфіденційних даних і функцій, вони
                            також створюють додатковий простір для атаки та інтеграції нових експлойтів. Тому навчитися виявляти та
                            використовувати вразливі місця автентифікації, включаючи те, як обійти загальні заходи захисту, є однією з
                            фундаментальних навичок не тільки кіберфахівців, а й розробників та всіх хто працює з даними користувачів в
                            продукті.</p>
                    </li>
                </ol>
            </div>
        </li>
    </ul>

    <h5 id="network">Network</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are HTTP methods?
            </div>
            <div class="collapsible-body">
                <p>HTTP-методи визначають, яку операцію необхідно виконати для заданого ресурсу. Ось список HTTP-методів та їх
                    пояснення:</p>
                <ol>
                    <li>
                        <strong>GET</strong>
                        <p>Використовується для отримання даних зазначеного ресурсу. Параметри передаються у URL.</p>
                    </li>
                    <li>
                        <strong>POST</strong>
                        <p>Використовується для відправлення даних на сервер для обробки. Зазвичай використовується для відправки даних
                            форм.</p>
                    </li>
                    <li>
                        <strong>PUT</strong>
                        <p>Використовується для оновлення або створення ресурсу на сервері. Весь ресурс замінюється вказаним в запиті.</p>
                    </li>
                    <li>
                        <strong>DELETE</strong>
                        <p>Використовується для видалення зазначеного ресурсу на сервері.</p>
                    </li>
                    <li>
                        <strong>PATCH</strong>
                        <p>Використовується для часткового оновлення ресурсу. Відправляє тільки ті дані, які слід змінити.</p>
                    </li>
                    <li>
                        <strong>HEAD</strong>
                        <p>Аналогічний методу GET, але повертає тільки заголовки відповіді, без самого тіла.</p>
                    </li>
                    <li>
                        <strong>OPTIONS</strong>
                        <p>Використовується для отримання інформації про можливі HTTP-методи для ресурсу, або отримання інформації про
                            конфігурацію сервера.</p>
                    </li>
                    <li>
                        <strong>TRACE</strong>
                        <p>Використовується для тестування шляху до ресурсу, аналізуючи зміни, які вносять проміжні сервери.</p>
                    </li>
                    <li>
                        <strong>CONNECT</strong>
                        <p>Використовується для встановлення тунелю до сервера, який визначений URI, зазвичай для забезпечення безпеки через
                            проксі.</p>
                    </li>
                </ol>
                <p>Ці HTTP-методи визначають різні дії, які клієнт чи сервер можуть виконати з ресурсом, що ідентифікується URI.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Why has it been better to serve site assets from multiple domains?
            </div>
            <div class="collapsible-body">
                <p>Сервіс ресурсів сайту з декількох доменів є практикою, відомою як доменне розділення, і історично це робилося для
                    подолання обмежень, накладених браузерами. Основна причина використання доменного розділення полягала в збільшенні
                    кількості одночасних з'єднань, які браузер може встановити з веб-сервером, тим самим покращуючи загальну продуктивність
                    веб-сайту. Ось ключові причини:</p>
                <ol>
                    <li>
                        <strong>Паралельні з'єднання:</strong>
                        <p>Браузери обмежують кількість одночасних з'єднань, які вони можуть встановити з одним доменом. Використання
                            декількох доменів дозволяє одночасно завантажувати ресурси з різних доменів, що підвищує паралельність і
                            прискорює завантаження сторінки.</p>
                    </li>
                    <li>
                        <strong>Покращення продуктивності:</strong>
                        <p>Коли різні ресурси (зображення, стилі, скрипти) розміщені на різних доменах, браузери можуть завантажувати їх
                            паралельно, що покращує час завантаження сторінки для користувача.
                        </p>
                    </li>
                    <li>
                        <strong>Оминання обмежень браузера:</strong>
                        <p>Декілька доменів дозволяє обійти обмеження браузера на одночасні з'єднання, що дозволяє сторінці ефективніше
                            завантажувати велику кількість ресурсів.</p>
                    </li>
                </ol>
                <p>Однак важливо відзначити, що з покращенням браузерів та їх здатністю ефективно керувати паралельним завантаженням, а
                    також з впровадженням HTTP/2, яке дозволяє одному з'єднанню ефективно передавати багато ресурсів, потреба в доменному
                    розділенні стала менш актуальною. В деяких випадках може бути корисніше концентруватися на оптимізації ресурсів та
                    використанні сучасних підходів до збільшення продуктивності веб-сайту.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Do your best to describe the process from the time you type in a website's URL to it finishing loading on your screen.
            </div>
            <div class="collapsible-body">
                <p>Процес включає в себе декілька етапів:</p>
                <ol>
                    <li>
                        <strong>Користувач вводить URL:</strong>
                        <p>Ви вводите URL веб-сайту (Uniform Resource Locator) у адресний рядок вашого браузера (наприклад,
                            https://www.example.com).</p>
                    </li>
                    <li>
                        <strong>DNS Запит до Сервера:</strong>
                        <p>Браузер відправляє запит до DNS-сервера для отримання IP-адреси введеного домену.</p>
                    </li>
                    <li>
                        <strong>DNS Розгортання:</strong>
                        <p>DNS-сервер повертає браузеру IP-адресу веб-сайту.</p>
                    </li>
                    <li>
                        <strong>Встановлення З'єднання:</strong>
                        <p>Браузер встановлює TCP/IP з'єднання з сервером, використовуючи отриману IP-адресу та порт (зазвичай порт 80 для
                            HTTP або 443 для HTTPS).</p>
                    </li>
                    <li>
                        <strong>HTTP Запит:</strong>
                        <p>Браузер відправляє HTTP (або HTTPS) запит на сервер, запитуючи ресурси сайту.</p>
                    </li>
                    <li>
                        <strong>Сервер Обробляє Запит:</strong>
                        <p>Веб-сервер обробляє отриманий запит, взягаючи ресурси (HTML, CSS, JavaScript та інші).</p>
                    </li>
                    <li>
                        <strong>Відправлення Response:</strong>
                        <p>Сервер відправляє браузеру Response, яка містить HTML-код, зазвичай відповідь містить також посилання на інші
                            ресурси (зображення, стилі, скрипти).</p>
                    </li>
                    <li>
                        <strong>Завантаження Ресурсів:</strong>
                        <p>Браузер починає завантажувати ресурси, зазначені в HTML-коді. Це можуть бути зображення, таблиці стилів, скрипти
                            та інші.</p>
                    </li>
                    <li>
                        <strong>Складання та Відображення:</strong>
                        <p>Браузер компілює отримані дані, обробляє їх та відображає на екрані, показуючи вам веб-сторінку.</p>
                    </li>
                </ol>
                <p>Цей процес дозволяє браузеру відобразити веб-сторінку на вашому екрані після того, як ви ввели URL.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке DNS?
            </div>
            <div class="collapsible-body">
                <p>DNS (Domain Name System або Система доменних імен) - це система, що перетворює зрозумілі для людини доменні імена
                    (наприклад, www.example.com) в IP-адреси, які використовуються комп'ютерами для знаходження один одного в мережі
                    Інтернет.</p>
                <p>Основні функції DNS включають:</p>
                <ol>
                    <li>
                        <strong>Розгортання Доменних Імен:</strong>
                        <p>DNS переводить зрозумілі для користувача доменні імена в IP-адреси, що вказують на конкретні сервери в
                            мережі.</p>
                    </li>
                    <li>
                        <strong>Розподіл Запитів:</strong>
                        <p>DNS розподіляє запити на розгорнуті доменні імена між різними серверами для зменшення навантаження та
                            забезпечення більшої швидкості відповідей.</p>
                    </li>
                    <li>
                        <strong>Система Кешування:</strong>
                        <p>DNS може кешувати раніше отримані відповіді. Це дозволяє уникнути повторного розгортання для одних і тих самих
                            доменних імен та прискорює процес визначення IP-адрес.</p>
                    </li>
                    <li>
                        <strong>Розподілення Доменних Зон:</strong>
                        <p>DNS розділяє Інтернет на доменні зони (наприклад, .com, .org, .gov), керуючи розподілом доменних імен між різними
                            реєстраторами.</p>
                    </li>
                    <li>
                        <strong>Робота в Різних Рівнях:</strong>
                        <p>DNS працює на різних рівнях, від розгортання конкретного домену до визначення IP-адреси конкретного
                            комп'ютера.</p>
                    </li>
                </ol>
                <p>Ця система є ключовою для правильної ідентифікації та знаходження ресурсів в Інтернеті та інших комп'ютерних мережах.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                HTTP/2 vs HTTP 1 - що таке і в чому різниця?
            </div>
            <div class="collapsible-body">
                <p>HTTP/2 і HTTP/1 - це версії протоколу передачі гіпертексту, які використовуються для обміну даними між браузером і
                    веб-сервером. Ось основні різниці між ними:</p>
                <ol>
                    <li>
                        <strong>Множинні З'єднання:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Використовує одночасно тільки одне з'єднання для кожного запиту.</li>
                            <li><strong>HTTP/2:</strong> Дозволяє множинні з'єднання в одному фізичному з'єднанні, зменшуючи затримку
                                завантаження сторінок.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мультиплексування:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Запити та відповіді передаються послідовно, що може спричинити блокування
                                (blocking).
                            </li>
                            <li><strong>HTTP/2:</strong> Використовує мультиплексування, що дозволяє одночасну передачу багатьох запитів та
                                відповідей на одному з'єднанні.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Компресія Заголовків:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Заголовки не компресуються, що призводить до зайвого обсягу даних.</li>
                            <li><strong>HTTP/2:</strong> Використовує компресію заголовків, що зменшує обсяг передачі даних.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Пріоритети та Ваги:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Немає вбудованої підтримки для визначення приоритетів.</li>
                            <li><strong>HTTP/2:</strong> Дозволяє встановлювати приоритети для різних ресурсів, що допомагає браузерам
                                ефективніше вивантажувати сторінки.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Бінарний Протокол:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Використовує текстовий формат, що може бути важким для обробки та розуміння.</li>
                            <li><strong>HTTP/2:</strong> Використовує бінарний протокол, що полегшує обробку та зменшує помилки.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Підтримка TLS:</strong>
                        <ul>
                            <li><strong>HTTP/1:</strong> Підтримує TLS, але часто використовується без шифрування.</li>
                            <li><strong>HTTP/2:</strong> Вимагає використання TLS (HTTPS), забезпечуючи безпеку.</li>
                        </ul>
                    </li>
                </ol>
                <p>Загалом, HTTP/2 має багато покращень у порівнянні з HTTP/1, забезпечуючи швидше завантаження сторінок та ефективнішу
                    взаємодію між браузером та сервером.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                HTTP vs HTTPS - що таке і їх різниця
            </div>
            <div class="collapsible-body">
                <p>
                    HTTP і HTTPS - це протоколи передачі гіпертексту, які використовуються для обміну даними між браузером користувача і
                    веб-сервером. Ось їхні основні характеристики та різниця:
                </p>
                <ol>
                    <li>
                        <strong>HTTP (Hypertext Transfer Protocol):</strong>
                        <ul>
                            <li>Це стандартний протокол передачі даних в Інтернеті.</li>
                            <li>Дані передаються у відкритому тексті, тобто без шифрування.</li>
                            <li>Використовується для передачі неважливих даних, таких як статичні веб-сайти без обробки конфіденційної
                                інформації.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>HTTPS (Hypertext Transfer Protocol Secure):</strong>
                        <ul>
                            <li>Це розширення протоколу HTTP з доданою безпекою шляхом шифрування.</li>
                            <li>Дані передаються зашифровано, що робить їх менш доступними для несанкціонованого перегляду.</li>
                            <li>Використовується для передачі конфіденційних даних, таких як особисті дані, паролі, інформація про платежі
                                тощо.
                            </li>
                        </ul>
                    </li>
                </ol>
                <strong>Основні різниці:</strong>
                <ol>
                    <li>
                        <strong>Шифрування:</strong>
                        <ul>
                            <li>HTTP передає дані у відкритому тексті, тоді як HTTPS використовує шифрування для захисту конфіденційної
                                інформації від проміжних атак і несанкціонованого доступу.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Безпека:</strong>
                        <ul>
                            <li>HTTP не забезпечує безпеку, що робить його непридатним для передачі конфіденційних даних.</li>
                            <li>HTTPS забезпечує безпеку, що робить його відмінним вибором для обробки чутливої інформації.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Порт:</strong>
                        <ul>
                            <li>HTTP використовує порт 80 для передачі даних.</li>
                            <li>HTTPS використовує порт 443 для шифрованого з'єднання.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Сертифікати:</strong>
                        <ul>
                            <li>HTTPS вимагає встановлення SSL/TLS-сертифікату для шифрування даних.</li>
                            <li>HTTP не вимагає встановлення сертифікату.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Довіреність:</strong>
                        <ul>
                            <li>HTTPS вказує на те, що веб-сайт дійсно той, за який він видає себе, завдяки використанню сертифіката від
                                інституцій, які йому довіряють.
                            </li>
                            <li>HTTP не надає такого підтвердження, і дані можуть бути менш безпечними.</li>
                        </ul>
                    </li>
                </ol>
                <p>В сучасному Інтернеті рекомендується використовувати HTTPS, особливо для сайтів, які обробляють конфіденційну
                    інформацію.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are the differences between Long-Polling, Websockets and Server-Sent Events?
            </div>
            <div class="collapsible-body">
                <p>Лонг-полінг (Long-Polling), WebSockets та Server-Sent Events (SSE) - це техніки взаємодії між клієнтом та сервером для
                    обміну даними в реальному часі. Ось їхні основні відмінності:</p>
                <ol>
                    <li>
                        <strong>Лонг-полінг (Long-Polling):</strong>
                        <ul>
                            <li>Опис: Клієнт відправляє запит на сервер, і сервер утримує відповідь до тих пір, поки не буде доступна нова
                                інформація або не вийде таймаут.
                            </li>
                            <li>
                                <strong>Переваги:</strong>
                                <ul>
                                    <li>Простий у використанні, особливо з стандартними HTTP-серверами.</li>
                                    <li>Достатньо ефективний для обміну рідкісними оновленнями.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Недоліки:</strong>
                                <ul>
                                    <li>Збільшена затримка через очікування на оновлення.</li>
                                    <li>Висока кількість запитів та відповідей.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>WebSockets:</strong>
                        <ul>
                            <li>Опис: Встановлює постійне двостороннє з'єднання між клієнтом та сервером, яке дозволяє обидві сторони
                                надсилати дані в будь-який момент.
                            </li>
                            <li>
                                <strong>Переваги:</strong>
                                <ul>
                                    <li>Низька затримка завдяки постійному з'єднанню.</li>
                                    <li>Дозволяє передавати дані як від сервера до клієнта, так і в зворотному напрямку.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Недоліки:</strong>
                                <ul>
                                    <li>Деякі проблеми з проксі та брандмауерами.</li>
                                    <li>Потрібно підтримувати обидві сторони.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Server-Sent Events (SSE):</strong>
                        <ul>
                            <li>Опис: Встановлює одностороннє з'єднання, де сервер може асинхронно надсилати дані клієнту, але клієнт може
                                лише отримувати дані, а не надсилати їх назад.
                            </li>
                            <li>
                                <strong>Переваги:</strong>
                                <ul>
                                    <li>Простий у використанні, легко реалізувати звичайними HTTP-серверами.</li>
                                    <li>Дозволяє серверу асинхронно повідомляти клієнта про оновлення.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Недоліки:</strong>
                                <ul>
                                    <li>Обмежений одностороннім способом спілкування.</li>
                                    <li>Затримка при великій кількості одночасних підключень.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Кожен з цих підходів має свої використання в залежності від конкретного випадку та вимог проекту.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What is domain pre-fetching and how does it help with performance?
            </div>
            <div class="collapsible-body">
                <p>Попереднє завантаження домену - це техніка, яку веб-браузери використовують для покращення продуктивності, передбачально
                    завантажуючи та кешуючи ресурси з зовнішніх доменів перед тим, як вони дійсно будуть потрібні. Цей процес спрямований на
                    зменшення затримок і покращення загальної швидкості завантаження веб-сторінки. Ось як працює попереднє завантаження
                    домену та його переваги:</p>
                <ol>
                    <li>
                        <strong>Попереднє Завантаження Ресурсів:</strong>
                        <p>Браузер передбачає, які ресурси (такі як файли CSS, JavaScript, зображення тощо) буде потрібно завантажити для
                            конкретної сторінки.</p>
                    </li>
                    <li>
                        <strong>Асинхронне Завантаження:</strong>
                        <p>Замість чекання, коли сторінка дійсно потребує цих ресурсів, браузер асинхронно завантажує їх заздалегідь,
                            використовуючи вільні ресурси мережі.</p>
                    </li>
                    <li>
                        <strong>Зменшення Затримок:</strong>
                        <p>Передбаченням та завантаженням ресурсів заздалегідь браузер робить їх доступними майже миттєво, коли вони дійсно
                            знадобляться на сторінці.</p>
                    </li>
                    <li>
                        <strong>Покращення Швидкодії:</strong>
                        <p>Зменшення часу очікування на завантаження ресурсів може суттєво покращити загальну швидкодію завантаження
                            сторінки.</p>
                    </li>
                    <li>
                        <strong>Оптимізація Використання Мережі:</strong>
                        <p>Завантаження ресурсів перед фактичним їхнім запитом дозволяє ефективніше використовувати мережу та зменшує
                            загальний час завантаження.</p>
                    </li>
                    <li>
                        <strong>Покращення Відчуття Швидкості:</strong>
                        <p>Коли ресурси готові без затримок, відчуття швидкості для користувача збільшується, оскільки сторінка відгукується
                            швидше.</p>
                    </li>
                </ol>
                <p>Попереднє завантаження домену можна виконати за допомогою HTML-атрибута rel і значення dns-prefetch. Додайте такий код до
                    ваших HTML-сторінок в розділ
                    < head>: < link rel="dns-prefetch" href="//example.com">
                </p>
                <p>В цьому прикладі href="//example.com" вказує на домен, з якого будуть завантажуватися ресурси. Ви можете додавати
                    кілька таких тегів < link> для різних доменів.</p>
                <p>Також важливо відзначити, що це дозволяє браузеру попередньо вирішити DNS-запити для вказаних доменів, що може зменшити
                    затримку при завантаженні ресурсів з цих доменів у майбутньому.</p>
                <p>Однак важливо враховувати, що неконтрольоване попереднє завантаження може займати додатковий мережевий трафік і споживати
                    ресурси. Тому використовуйте цю техніку обережно та розсудливо, оптимізуючи завантаження лише тих ресурсів, які дійсно
                    необхідні для покращення продуктивності сторінки.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Content Delivery Network (CDN) - що таке і як працює?
            </div>
            <div class="collapsible-body">
                <p>Мережа поставки контенту (Content Delivery Network, CDN) - це розподілена система серверів, розташованих у різних
                    географічних областях, з метою ефективного та швидкого доставлення веб-контенту користувачам. Основна мета CDN -
                    зменшити затримку завантаження ресурсів на веб-сторінці, покращити швидкість відгуку та зменшити навантаження на
                    сервери.</p>

                <p>Основні принципи роботи CDN включають наступні кроки:</p>

                <ol>
                    <li>
                        <strong>Розподілення Серверів:</strong>
                        <p>CDN використовує мережу серверів, розташованих у різних регіонах та країнах. Ці сервери називаються
                            "кеш-серверами" або "крайовими серверами".</p>
                    </li>
                    <li>
                        <strong>Запити до Найближчого Сервера:</strong>
                        <p>Коли користувач робить запит до ресурсу (наприклад, зображення чи стилізований файл), CDN автоматично визначає,
                            який крайовий сервер є найближчим до користувача.</p>
                    </li>
                    <li>
                        <strong>Кешування та Поставка:</strong>
                        <p>Якщо ресурс вже був запитаний раніше, CDN може мати його копію в кеші на крайовому сервері. Це дозволяє швидше
                            відправляти ресурс користувачеві без звертання до основного сервера. Якщо ресурс не знаходиться в кеші або
                            старий, CDN може запитати основний сервер.</p>
                    </li>
                    <li>
                        <strong>Динамічне Оновлення Кешу:</strong>
                        <p>CDN може автоматично оновлювати свій кеш, якщо ресурс на основному сервері змінився. Це гарантує, що користувачі
                            завжди отримують актуальні версії ресурсів.</p>
                    </li>
                    <li>
                        <strong>Навантаження Балансу:</strong>
                        <p>CDN дозволяє розподілити навантаження між різними серверами, зменшуючи тиск на основний сервер та покращуючи
                            масштабованість.</p>
                    </li>
                    <li>
                        <strong>Захист від Атак:</strong>
                        <p>Багато CDN включають інструменти безпеки, такі як захист від DDoS-атак або WAF (Web Application Firewall), що
                            поліпшує захист веб-сайту.</p>
                    </li>
                    <li>
                        <strong>Швидкість завантаження:</strong>
                        <p>Завдяки використанню близьких крайових серверів та оптимізації передачі даних, CDN допомагає покращити швидкість
                            завантаження контенту для користувачів з різних регіонів світу.</p>
                    </li>
                </ol>

                <p>Використання CDN дозволяє покращити продуктивність веб-сайту, забезпечуючи ефективне та швидке доставлення контенту для
                    користувачів незалежно від їхнього місця розташування.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                TCP/IP - що таке і для чого потрібно?
            </div>
            <div class="collapsible-body">
                <p>TCP/IP (Transmission Control Protocol/Internet Protocol) - це набір протоколів, які визначають та регулюють передачу
                    даних в комп'ютерних мережах, зокрема в Інтернеті. Ці протоколи встановлюють стандарти для обміну даними між
                    комп'ютерами і забезпечують надійність та ефективність цього обміну. Основні причини використання TCP/IP включають:</p>
                <ol>
                    <li>
                        <strong>Забезпечення З'єднання:</strong>
                        <p>TCP (Transmission Control Protocol) відповідає за створення та управління з'єднанням між двома пристроями. Воно
                            гарантує, що дані будуть надсилатися та прийматися в правильному порядку.</p>
                    </li>
                    <li>
                        <strong>Розподілення Даних на Пакети:</strong>
                        <p>TCP розбиває дані на пакети перед їх відправленням по мережі. Це полегшує ефективний обмін великими обсягами
                            даних.</p>
                    </li>
                    <li>
                        <strong>Надійність та Відновлення Помилок:</strong>
                        <p>TCP включає механізми перевірки доставки та відновлення помилок. Це дозволяє виявляти та виправляти помилки в
                            передачі даних.</p>
                    </li>
                    <li>
                        <strong>Маршрутизація та Ідентифікація:</strong>
                        <p>IP (Internet Protocol) відповідає за адресацію та маршрутизацію пакетів даних у мережі. Кожен пристрій в мережі
                            має свою унікальну IP-адресу для ідентифікації.</p>
                    </li>
                    <li>
                        <strong>Стандартизація:</strong>
                        <p>TCP/IP є стандартом для інтернет-протоколів, що дозволяє різним пристроям та платформам взаємодіяти між собою в
                            єдиному середовищі.</p>
                    </li>
                    <li>
                        <strong>Підтримка Різних Послуг:</strong>
                        <p>TCP/IP підтримує різні послуги, такі як електронна пошта (SMTP), передача файлів (FTP), веб-перегляд (HTTP) та
                            багато інших.</p>
                    </li>
                    <li>
                        <strong>Глобальна Взаємодія:</strong>
                        <p>TCP/IP є основним протокольним стеком для глобального Інтернету, забезпечуючи взаємодію різних мереж та пристроїв
                            у всьому світі.</p>
                    </li>
                </ol>
                <p>Узагальнено, TCP/IP є фундаментальним для забезпечення сполучення та обміну даними в мережах, зокрема для побудови та
                    функціонування Інтернету.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Авторизація vs аутентифікація
            </div>
            <div class="collapsible-body">
                <p>Аутентифікація та авторизація - це два різних аспекти управління доступом, і вони використовуються для різних цілей:</p>
                <ol>
                    <li>
                        <strong>Аутентифікація:</strong>
                        <ul>
                            <li>
                                <p>Визначення: Аутентифікація - це процес перевірки того, чи користувач є тим, за кого він видає себе.</p>
                            </li>
                            <li>
                                <p>Мета: Головною метою аутентифікації є перевірка ідентичності користувача.</p>
                            </li>
                            <li>
                                <p>Приклад: Введення логіну та пароля, використання біометричних даних, таких як відбитки пальців чи
                                    розпізнавання обличчя.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Авторизація</strong>
                        <ul>
                            <li>
                                <p>Визначення: Авторизація - це процес визначення, які ресурси або дії користувач має право виконувати в
                                    системі.</p>
                            </li>
                            <li>
                                <p>Мета: Головною метою авторизації є контроль доступу та призначення дозволів на використання ресурсів.</p>
                            </li>
                            <li>
                                <p>Приклад: Надання користувачеві прав доступу на читання, запис чи видалення файлів, визначення рівня
                                    доступу веб-сторінок, тощо.</p>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Щоб краще розуміти відмінності:</p>
                <ul>
                    <li>Сценарій: Аутентифікація визначає, "Чи ти той, за кого видаєш себе?", тоді як авторизація визначає, "Чи маєш ти
                        право це робити?".
                    </li>
                    <li>Порядок виконання: Зазвичай аутентифікація відбувається перед авторизацією. Спочатку користувач повинен підтвердити
                        свою ідентичність, і тільки потім визначається, які дії він може виконати.
                    </li>
                    <li>Приклад: Якщо уявити веб-сайт, аутентифікація - це процес введення логіну та пароля, щоб підтвердити, що ви той, за
                        кого ви видаєте себе. Після успішної аутентифікації визначається, які частини сайту (розділи, функції) ви можете
                        використовувати, що є частиною авторизації.
                    </li>
                </ul>
                <p>Узагальнюючи, аутентифікація та авторизація спільно використовуються для забезпечення безпеки та контролю доступу до
                    інформації та ресурсів в системах.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                З чого складається request і response до сервера?
            </div>
            <div class="collapsible-body">
                <strong>Request (запит до сервера):</strong>
                <ol>
                    <li>
                        <strong>Метод (Method):</strong>
                        <p>Вказує на тип запиту. Наприклад, GET, POST, PUT, DELETE.</p>
                    </li>
                    <li>
                        <strong>URL (Uniform Resource Locator): </strong>
                        <p> Адреса ресурсу, який користувач хоче отримати або модифікувати.</p>
                    </li>
                    <li>
                        <strong>Headers (Заголовки):</strong>
                        <p>Мета-інформація про запит, така як тип вмісту (Content-Type), довжина вмісту (Content-Length), використання кешу,
                            мова браузера та інші.</p>
                    </li>
                    <li>
                        <strong>Body (Тіло):</strong>
                        <p>Дані, які відправляються разом із запитом. Це може бути пустий рядок для GET-запитів або містити дані форми,
                            JSON-об'єкт, файл і т.д. для POST-запитів.</p>
                    </li>
                    <li>
                        <strong>Параметри URL (Query Parameters): </strong>
                        <p>Додаткові дані, які можуть передаватися через URL, зазвичай для GET-запитів. Наприклад,
                            ?key1=value1&key2=value2.</p>
                    </li>
                </ol>
                <strong>Response (відповідь від сервера):</strong>
                <ol>
                    <li>
                        <strong>Status Code (Код стану):</strong>
                        <p>Цифровий код, що вказує на результат обробки запиту. Наприклад, 200 (ОК), 404 (Не знайдено), 500 (Внутрішня
                            помилка сервера).</p>
                    </li>
                    <li>
                        <strong>Headers (Заголовки):</strong>
                        <p>Інформація від сервера, така як тип вмісту (Content-Type), розмір вмісту (Content-Length), дата відправки та
                            інші.</p>
                    </li>
                    <li>
                        <strong>Body (Тіло):</strong>
                        <p>Вміст відповіді, який може бути HTML-кодом, JSON-об'єктом, текстом, зображенням чи іншими дані, залежно від
                            природи запиту.</p>
                    </li>
                    <li>
                        <strong>Cookies (Куки):</strong>
                        <p>Інформація, яку сервер може відправити браузеру для збереження та використання при подальших запитах.</p>
                    </li>
                </ol>
                <p>Ці компоненти разом створюють обмін даними між клієнтом та сервером, де клієнт відправляє запит, а сервер повертає
                    відповідь.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <!--    <h5 id="js">JS</h5>-->
    <!--    <ul class="collapsible">-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">filter_drama</i>First</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">place</i>Second</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--        <li>-->
    <!--            <div class="collapsible-header"><i class="material-icons">whatshot</i>Third</div>-->
    <!--            <div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>-->
    <!--        </li>-->
    <!--    </ul>-->

    <h5 id="typescript">Typescript</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Can you discuss the key differences between TypeScript and JavaScript?
            </div>
            <div class="collapsible-body">
                <ol>
                    <li>
                        <strong>Статичне надання типів:</strong>
                        <ul>
                            <li>TypeScript вводить статичне надання типів, що дозволяє перевірці типів під час компіляції, що підвищує
                                надійність коду та полегшує відлагодження.
                            </li>
                            <li>JavaScript є динамічно типізованою мовою, яка виконує перевірку типів під час виконання.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Анотації типів:</strong>
                        <ul>
                            <li>TypeScript підтримує анотації типів, що дозволяє розробникам визначати та нав'язувати типи змінних,
                                параметрів та значень повернення.
                            </li>
                            <li>JavaScript не має вбудованої підтримки анотацій типів.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Інтерфейси та дженеріки:</strong>
                        <ul>
                            <li>TypeScript підтримує інтерфейси та дженеріки, що надає більше можливостей для структуризації надійного
                                коду.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Для узагальнення: </p>
                <p>
                    TypeScript, як надмножина JavaScript, вводить статичне надання типів, що дозволяє перевірці типів на етапі компіляції, а
                    не під час виконання. Ця функція підвищує надійність коду та полегшує відлагодження. TypeScript також підтримує
                    інтерфейси та дженеріки для більш надійної структуризації коду. На відміну від JavaScript, він надає можливість
                    використання необов'язкових параметрів у декларації функцій, що підвищує гнучкість. TypeScript включає декоратори,
                    подібні анотаціям в інших мовах програмування, таких як Java чи Python, які відсутні в JavaScript. Також він пропонує
                    тип даних "enum", який відсутній у JavaScript. Нарешті, TypeScript має простори імен, які допомагають організовувати код
                    у модулі, у той час як JavaScript не має цієї функціональності.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Різниця між Interface та Type
            </div>
            <div class="collapsible-body">
                <h6>Коротке пояснення</h6>
                <p>За замовчуванням слід використовувати типи, доки вам не знадобиться специфічна особливість інтерфейсів, наприклад,
                    extends.</p>

                <ul>
                    <li>Інтерфейси не можуть виражати об'єднання, маповані або умовні типи. Псевдоніми типів можуть виражати будь-який
                        тип.
                    </li>
                    <li>Інтерфейси можуть використовувати розширення, типи - ні.</li>
                    <li>Коли ви працюєте з об'єктами, які успадковують один від одного, використовуйте інтерфейси. extends робить перевірку
                        типу TypeScript трохи швидшою, ніж використання &.
                    </li>
                    <li>Інтерфейси з однаковими іменами в одній області видимості об'єднують свої оголошення, що призводить до неочікуваних
                        помилок.
                    </li>
                    <li>Псевдоніми типів мають неявну індексну сигнатуру Record, яка іноді зустрічається.</li>
                </ul>

                <h6><b>Interface.</b></h6>
                <p>Інтерфейси є основною концепцією TypeScript і широко використовуються для визначення форм об’єктів.
                    Вони в основному використовуються для оголошення контрактів, надаючи спосіб визначення форми об’єкта, якого має
                    дотримуватися клас або інші об’єкти.</p>
                <pre>
                    // Interface usage
                    interface Person {
                      name: string;
                      age: number;
                    }
                    const person: Person = {
                      name: "John",
                      age: 30,
                    };
                </pre>
                <p>Інтерфейси були присутні з найпершої версії TypeScript. Вони базуються на об'єктно-орієнтованому програмуванні та
                    дозволяють використовувати успадкування для створення типів:</p>

                <pre>
                    interface WithId {
                      id: string;
                    }

                    interface User extends WithId {
                      name: string;
                    }

                    const user: User = {
                      id: "123",
                      name: "Karl",
                      wrongProperty: 123,
                    }
                </pre>


                <h6><b>Type Alias (Type).</b></h6>
                <p>Аліаси типів дозволяють створити нове ім’я для певного типу. Вони використовуються для надання описової назви складним
                    типам або для створення об’єднань, перетинів та інших складних типів.
                    Аліаси типів можна використовувати з об’єктами, але вони більш універсальні й можуть використовуватися з іншими типами,
                    такими як об’єднання (union), перетини (interception), тапли (typle) та примітивні типи.</p>
                <p><b>На відміну від інтерфейсів, типи не можна розширити (extends)!</b></p>
                <pre>
                    // Type Alias usage

                    type Person = {
                      name: string;
                      age: number;
                    };

                    const person: Person = {
                      name: "John",
                      age: 30,
                    };


                    // Union of Type
                    type Status = "pending" | "in_progress" | "completed";
                </pre>
                <p>Загалом, якщо вам потрібно створити контракт для форми об’єкта або якщо ви плануєте розширити або об’єднати визначення,
                    інтерфейси зазвичай є кращим вибором. З іншого боку, якщо вам потрібно створити нову назву для певного типу або
                    працювати з об’єднаннями (union) та перетинаннями (intersection), аліаси типів забезпечують більшу гнучкість.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How does type inference work in TypeScript? Can you provide an example?
            </div>
            <div class="collapsible-body">
                <p>В TypeScript інференція типів дозволяє компілятору автоматично призначати типи, коли відсутня явна інформація. Це
                    відбувається під час декларації змінних та функцій. Наприклад, якщо ви декларуєте змінну та одразу ж призначаєте їй
                    значення строку, TypeScript автоматично визначить тип цієї змінної як 'string'.</p>
                <p>Розгляньте цей приклад: <br><code>let message = "Hello World";</code></p>
                <p>Тут TypeScript інферує, що 'message' має тип 'string'.</p>
                <p>Інференція також застосовується до значень, що повертаються з функцій. Якщо функція повертає число, TypeScript інферує
                    тип повернення функції як 'number':</p>
                <pre>
                    function add(a: number, b: number): number {
                      return a + b;
                    }
                </pre>
                <p>У цьому випадку TypeScript інферує тип повернення функції 'add' як 'number'.</p>
                <h6>Основні риси інтерфейсів в TypeScript:</h6>
                <ol>
                    <li>
                        <strong>Визначення структури:</strong>
                        <p>Інтерфейс визначає структуру об'єкта, вказуючи, які властивості та їх типи має містити об'єкт.</p>
                    </li>
                    <li>
                        <strong>Можливість опціональних властивостей:</strong>
                        <p>Властивості в інтерфейсі можуть бути опціональними, що дозволяє об'єктам мати частково визначену структуру.</p>
                    </li>
                    <li>
                        <strong>Розширення:</strong>
                        <p>Інтерфейс може розширювати інші інтерфейси, дозволяючи створювати складніші визначення.</p>
                    </li>
                    <li>
                        <strong>Імплементація класів:</strong>
                        <p>Інтерфейси можуть бути використані для визначення контрактів, які клас повинен реалізовувати.</p>
                    </li>
                </ol>
                <p>Ось приклад простого інтерфейсу в TypeScript:</p>
                <pre>
                    interface Person {
                        firstName: string;
                        lastName: string;
                        age?: number; // Опціональна властивість
                    }

                    function greet(person: Person): void {
                        console.log(`Hello, ${person.firstName} ${person.lastName}!`);
                    }

                    // Об'єкт, який відповідає інтерфейсу Person
                    let myFriend: Person = {
                        firstName: "John",
                        lastName: "Doe",
                        age: 30,
                    };

                    greet(myFriend);
                </pre>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Could you explain how TypeScript interfaces are different from classes and when you’d use each?
            </div>
            <div class="collapsible-body">
                <p>Інтерфейси та класи в TypeScript мають різні призначення. Інтерфейси використовуються для перевірки типів структурних
                    контрактів об'єктів, забезпечуючи наявність необхідних властивостей з правильними типами. Вони не можуть бути
                    інстанційовані та не включають жодних деталей реалізації.</p>
                <p>Класи в TypeScript, з іншого боку, надають як шаблон, так і реалізацію. Вони визначають структуру, схожу до інтерфейсів,
                    але також включають методи та конструктори для створення екземплярів. Класи підтримують успадкування, що дозволяє
                    створювати підкласи, які успадковують властивості та поведінку від батьківського класу.</p>
                <p>Ви використовували б інтерфейси, коли вам потрібно забезпечити певні структури для об'єктів, особливо при роботі з
                    складними структурами даних, де важливо забезпечити, що кожен об'єкт відповідає певній формі. Це зазвичай відбувається в
                    сценаріях, пов'язаних із конфігураційними об'єктами чи параметрами функцій.</p>
                <p>Класи будуть вашим вибором, коли вам потрібно інкапсулювати функціональність та стан всередині об'єкта, а також можливо
                    використовувати успадкування. Зазвичай їх використовують при створенні нових об'єктів, які потребують конкретних методів
                    чи внутрішнього стану.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How would you use a TypeScript enum? Can you give an example?
            </div>
            <div class="collapsible-body">
                <p>Enums в TypeScript - це спосіб привести більш зрозумілі назви для наборів числових значень. Вони використовуються, коли
                    нам потрібно створити колекцію пов'язаних констант, що робить наш код зрозумілішим та менше вразливим до помилок.</p>
                <p>Приклад:</p>
                <pre>
                    enum Direction {
                      Up = 1,
                      Down,
                      Left,
                      Right,
                    }

                    function move(direction: Direction) { ... }
                </pre>
                <p>У даному випадку "Direction" - це enum, а "Up", "Down", "Left", "Right" - його члени. Ми можемо використовувати їх у
                    нашому коді замість простих числових значень або рядків, що робить очевидним, що представляє кожне значення. Функція
                    "move" приймає параметр типу "Direction", що гарантує, що можна передати лише дійсні напрямки.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Can you describe the benefits and drawbacks of using TypeScript over plain JavaScript for a large-scale application?
            </div>
            <div class="collapsible-body">
                <p>
                    TypeScript, статично типізований надмножина JavaScript, має кілька переваг для великомасштабних застосувань. Він надає
                    статичне типізування, яке може виявляти помилки на етапі компіляції, а не під час виконання, підвищуючи якість та
                    зручність обслуговування коду. TypeScript також підтримує сучасні функції JavaScript, такі як класи і модулі, і має
                    потужний інструментарій, який поліпшує продуктивність розробника завдяки можливостям, таким як автодоповнення, перевірка
                    типів і підтримка карт джерел.</p>
                <p>Однак у TypeScript є свої недоліки. Є початкова крива навчання та накладні витрати на налаштування порівняно з простим
                    JavaScript. Система статичного типізування, хоча і корисна, може вважатися обмежувальною та розгорнутою. Крім того, не
                    всі бібліотеки мають високоякісні означення типів для TypeScript, що може призвести до проблем інтеграції.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are Generics in TypeScript and how can they be beneficial in writing robust code????? (!! - FIND OUT MORE)
            </div>
            <div class="collapsible-body">
                <p>Generics в TypeScript є інструментом для створення повторно використовуваних компонентів. Вони дозволяють тому самому
                    компоненту обробляти різні типи даних, підвищуючи гнучкість коду і зменшуючи його надмірність. Generics працюють,
                    використовуючи змінну типу — своєрідний заповнювач, який вказується при використанні компонента.</p>
                <p>Наприклад, розгляньте масив. Без використання generics нам довелося б визначати масиви для кожного типу даних
                    (numberArray, stringArray). З використанням generics ми можемо створити один універсальний масив, який працює з
                    будь-яким типом даних.</p>
                <p>З точки зору надійності, generics покращують безпеку типів. Вказуючи тип при використанні, ми забезпечуємо послідовну
                    взаємодію між компонентами. Це зменшує помилки часу виконання, оскільки компілятор TypeScript перевіряє правильне
                    використання цих типів.</p>
                <p>Крім того, generics сприяють зручності обслуговування коду. Якщо потрібно внести зміни, їх роблять в одному місці — в
                    універсальному компоненті — замість кількох конкретних реалізацій.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How can you implement object-oriented programming concepts like inheritance and polymorphism in TypeScript?
            </div>
            <div class="collapsible-body">
                <p>У TypeScript успадкування та поліморфізм реалізуються за допомогою класів та інтерфейсів.</p>
                <p>Щодо успадкування, ви створюєте базовий клас з властивостями та методами, які можуть бути успадковані похідними класами.
                    Ключове слово "extends" використовується для успадкування від базового класу.</p>
                <pre>
                    class BaseClass {
                      baseMethod() {}
                    }

                    class DerivedClass extends BaseClass {
                      derivedMethod() {
                        super.baseMethod();
                      }
                    }
                </pre>
                <p>Поліморфізм в TypeScript досягається за допомогою реалізації інтерфейсу. Інтерфейс визначає контракт для класів
                    наслідувати. Класи, які реалізують інтерфейс, повинні визначити всі його члени. Це дозволяє об'єктам різних типів бути
                    обробленими як їх тип інтерфейсу під час виконання.</p>
                <pre>
                    interface IShape {
                      draw(): void;
                    }

                    class Circle implements IShape {
                      draw() { /* Draw circle */ }
                    }

                    class Square implements IShape {
                      draw() { /* Draw square */ }
                    }

                    let shapes: IShape[] = [new Circle(), new Square()];
                    shapes.forEach(shape => shape.draw());
                </pre>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How would you use the “never” type in TypeScript?
            </div>
            <div class="collapsible-body">
                <p>Тип "never" у TypeScript використовується, коли функція ніколи не повертає значення. Він часто використовується в двох
                    основних сценаріях: для функцій, які завжди генерують помилку, та для нескінчених циклів.</p>
                <p>Наприклад, розглянемо функцію, яка генерує помилку:</p>
                <pre>
                    function throwError(message: string): never {
                      throw new Error(message);
                    }
                </pre>
                <p>У цьому випадку функція не поверне значення, оскільки завжди генерує помилку, отже, тип повернення - "never".</p>
                <p>Інший приклад - функція з нескінченим циклом:</p>
                <pre>
                    function infiniteLoop(): never {
                      while (true) {}
                    }
                </pre>
                <p>Тут функція не має кінцевої точки; вона працює нескінченно, тому не повертає значення, зробивши її тип повернення
                    "never".</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How do TypeScript and ES6 relate to one another?
            </div>
            <div class="collapsible-body">
                <p>TypeScript є надмножиною ES6, що означає, що він включає всі можливості ES6 і додає додаткові. TypeScript розширює
                    можливості JavaScript (ES6), введенням статичного типу, інтерфейсів, класів, модулів, декораторів та інших функцій. Це
                    дозволяє отримати кращі інструменти, такі як автодоповнення, перевірка типів та транспіляція до різних версій
                    ECMAScript. Важливо зазначити, що будь-який дійсний код ES6 також є дійсним кодом TypeScript. Однак TypeScript має
                    необов'язкові статичні типи, які можуть використовуватися для перевірки типів на етапі проектування та
                    об'єктно-орієнтованих шаблонів програмування.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Can you explain how the TypeScript compiler works and the role of the tsconfig.json file?
            </div>
            <div class="collapsible-body">
                <p>
                    Компілятор TypeScript, tsc, перетворює код TypeScript на JavaScript. Він використовує процес лексичного аналізу,
                    синтаксичного аналізу, семантичного аналізу та генерації коду. Лексичний аналіз розбиває код на токени, синтаксичний
                    аналіз організує їх у дерево синтаксичного аналізу (AST), семантичний аналіз перевіряє наявність помилок та додає
                    додаткову інформацію до AST, а нарешті, генерація коду перетворює збагачене AST у JavaScript.</p>
                <p>Файл tsconfig.json є ключовим у цьому процесі, оскільки він надає налаштування для компілятора. Це включає опції, такі як
                    "target", яка визначає версію цільового стандарту ECMAScript, "module", що визначає систему модулів, та "strict", яка
                    увімкнює всі строгі опції перевірки типів. Властивості "include" та "exclude" вказують файли або каталоги для включення
                    або виключення з компіляції.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                How do you annotate functions in TypeScript? Can you provide an example?
            </div>
            <div class="collapsible-body">
                <p>У TypeScript анотація функцій включає вказівку типів параметрів та значень, що повертаються. Це робиться за допомогою
                    двокрапки після імені параметра, щоб позначити його тип, та після дужок, щоб вказати тип, який повертається.</p>
                <p>Приклад: </p>
                <pre>
                    function greet(name: string): string {
                      return `Hello, ${name}`;
                    }
                </pre>
                <p>У цьому фрагменті коду «greet» - це функція, яка приймає один аргумент, «name», який має тип «string». Функція повертає
                    значення також типу «string».</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="npm">NPM</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке NPM і для чого його
                використовувати?
            </div>
            <div class="collapsible-body">
                NPM (Node Package Manager) є системою управління пакетами для JavaScript, яка дозволяє розробникам легко
                встановлювати, оновлювати та використовувати залежності у своїх проектах. В основному, використовується
                для управління бібліотеками та іншими залежностями, які використовуються в проектах на базі Node.js.
                Декілька ключових причин для використання NPM:

                <ol>
                    <li><strong>Установка пакетів:</strong> NPM дозволяє легко встановлювати пакети (бібліотеки,
                        фреймворки, інструменти) для використання в проекті.
                    </li>
                    <li><strong>Управління версіями:</strong> NPM дозволяє вказувати версії пакетів, щоб гарантувати
                        сумісність та уникнути проблем залежностей.
                    </li>
                    <li><strong>Сценарії:</strong> Ви можете визначити різні сценарії (scripts) для автоматизації
                        завдань, таких як запуск сервера, збірка проекту чи тестування.
                    </li>
                    <li><strong>Пакетні файли та конфігурації:</strong> NPM дозволяє визначити пакетні файли та
                        конфігурації, які допомагають у встановленні та налаштуванні проекту.
                    </li>
                    <li><strong>Глобальні та локальні пакети:</strong> NPM дозволяє встановлювати пакети глобально для
                        доступу з будь-якого місця, або локально для конкретного проекту.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Глобальна та локальна установка
                пакетів за допомогою NPM
            </div>
            <div class="collapsible-body">
                Глобальна установка пакетів NPM означає, що пакет встановлюється на рівні системи та може бути
                використаний в будь-якому проекті. Це зазвичай використовується для інструментів командного рядка.
                Локальна установка, навпаки, встановлює пакет лише в межах поточного каталогу проекту. Це гарантує, що
                різні проекти не взаємодіють між собою через різні версії пакетів.
                Для глобальної установки використовується команда npm install -g, а для локальної - npm install.
                Наприклад, глобальна установка може бути корисною для інсталяції інструментів командного рядка, таких як
                create-react-app, які використовуються на рівні системи. Локальна установка, навпаки, дозволяє
                встановлювати бібліотеки, які використовуються тільки в межах конкретного проекту, такі як бібліотеки
                для розробки на React.js.
                Локальні пакети використовуються для забезпечення залежностей конкретного проекту. Це дозволяє уникнути
                конфліктів версій між різними проектами.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Файл Package.json, його функції</div>
            <div class="collapsible-body">

                <p>Package.json - це ключовий файл у проектах Node.js, який виступає як файл маніфесту. Він містить
                    метадані, що стосуються проекту, і включає в себе властивості, такі як ім'я, версія, опис, автор та
                    ліцензія.</p>

                <p>Також він перераховує залежності, необхідні для роботи додатка. Вони вказуються разом зі своїми
                    відповідними версіями у розділах "dependencies" чи "devDependencies". Перший містить пакети,
                    необхідні для продакшн, тоді як другий для розробки.</p>

                <p>Розділ "scripts" визначає скорочення команд, які можна виконати за допомогою npm. Наприклад, скрипт
                    "start" зазвичай запускає додаток.</p>

                <p>Додатково, файл може містити конфігураційні дані для інструментів, що використовуються у вашому
                    проекті у розділі "config", власні поля даних у "private" та вказати основну точку входу вашого
                    додатка у "main".</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як оновити пакет за допомогою NPM?
            </div>
            <div class="collapsible-body">
                Щоб оновити пакет за допомогою NPM, спочатку потрібно перевірити застарілі пакети. Використовуйте
                команду "npm outdated" у терміналі. Це виведе список всіх пакетів, для яких доступні нові версії. Щоб
                оновити конкретний пакет, використовуйте команду "npm update [ім'я-пакету]". Якщо ви хочете оновити всі
                пакети, просто використовуйте "npm update" без вказання імені пакету. Важливо враховувати, що це оновить
                лише мінорні та патч-релізи відповідно до правил семантичної версії. Для оновлення мажорних версій вам
                потрібно використовувати команду "npm install [ім'я-пакету]@latest". Завжди пам'ятайте перевіряти
                оновлення, переглядаючи файл package.json або використовуючи "npm outdated" знову.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як керувати версіями пакетів в NPM?
            </div>
            <div class="collapsible-body">NPM дозволяє управляти версіями пакетів за допомогою семантичного
                версіонування (semver). У вашому файлі package.json залежності перераховуються з їх версіями. Символ
                каретки (^) чи тильда (~) перед номером версії вказує на гнучкість у використанні новіших мінорних чи
                патч-версій відповідно. Щоб встановити конкретну версію, ви можете використовувати "npm install
                [пакет]@[версія]". Для оновлення до останньої мажорної версії команда "npm outdated" показує пакети, які
                потребують оновлення, і "npm update [пакет]" оновлює їх. Якщо декілька проектів вимагають різних версій,
                розгляньте використання nvm від npm чи Docker для ізольованих середовищ.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як використовується Семантичне
                версіонування у проекті?
            </div>
            <div class="collapsible-body">Семантичне версіонування, або SemVer, є системою версіонування для програмного
                забезпечення, яка має на меті передавати значення щодо основних змін у випуску. Вона використовує формат
                MAJOR.MINOR.PATCH, де кожне збільшення представляє різні типи модифікацій. Збільшення мажорної версії
                вказує на несумісні зміни у API, мінорної - на додання функціоналу сумісним способом, а патчу - на
                виправлення помилок, сумісних назад.

                У NPM семантичне версіонування використовується для управління залежностями. Під час встановлення
                пакетів ви можете вказати версію за допомогою нотації SemVer. Наприклад, "^1.0.0" встановить останню
                мінорну або патч-версію вище 1.0.0, але нижче 2.0.0. Це дозволяє розробникам контролювати версії їх
                залежностей, забезпечуючи сумісність та стабільність у їх проектах.>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як видалити пакет?</div>
            <div class="collapsible-body">

                Щоб видалити пакет за допомогою NPM, використовуйте команду "npm uninstall", за якою слідує ім'я пакету.
                Це видаляє його з каталогу node_modules та оновлює ваш файл package.json, відображаючи зміну. Якщо ви
                хочете видалити його глобально, додайте "-g". Щоб зберегти зміни в файлі package-lock.json, включіть
                "--save". Наприклад:
                <strong>npm uninstall < ім'я-пакету></strong><br/>. Це видаляє локально. Для глобального видалення:
                <strong>npm uninstall -g < ім'я-пакету></strong>. <br/>А для оновлення package-lock.json: <strong>npm
                uninstall --save < ім'я-пакету></strong>


            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Для чого використовуємо .npmignore
                файл?
            </div>
            <div class="collapsible-body">
                Файл .npmignore використовується у проектах Node.js для вказівки файлів чи каталогів, які не повинні
                бути включені до пакету, який надсилається до реєстру npm. Він функціонує подібно до файлу .gitignore,
                але спеціально для npm-пакетів. Якщо в каталозі не існує файлу .npmignore, npm використовує файл
                .gitignore замість нього. Однак у разі наявності обох файлів .npmignore має перевагу.

                Це дозволяє розробникам зберігати певні файли у своєму локальному репозиторії, не включаючи їх у
                опублікований пакет, такі як тести, README-файли чи інші необов'язкові файли.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Що як пакет, який використовується в
                проекті, застарів чи перестав підтримуватись?
            </div>
            <div class="collapsible-body">
                У ситуації, коли NPM-пакет, від якого залежить проект, є застарілим або більше не підтримується, я б
                спочатку оцінив вплив цього застаріння. Якщо це критично для проекту, я шукав би альтернативи. Зазвичай
                в обширному репозитарії NPM можна знайти схожі пакети.

                Якщо підходящу заміну знайти не вдається, і пакет є важливим, іншою опцією може бути створення форку
                оригінального пакету і його підтримка. Це передбачає розуміння кодової бази та виправлення будь-яких
                проблем чи вразливостей, що виникають. Однак це слід розглядати як останній захід через час та ресурси,
                які він вимагає.

                Ще одним підходом може бути повне вилучення залежності, якщо вона не приносить значущої користі. Це може
                потребувати рефакторингу деяких частин проекту, але може призвести до більш оптимізованої та ефективної
                кодової бази.

                Незалежно від обраного шляху важливо тщательно тестувати всі зміни, щоб вони не вводили нових помилок чи
                вразливостей у проект.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між npm та yarn</div>
            <div class="collapsible-body">
                NPM і Yarn - обидва менеджери пакетів для JavaScript, але вони відрізняються декількома способами. NPM
                автоматично встановлює пакет, коли ви його додаєте, тоді як Yarn додає пакет лише до списку, поки ви не
                виконаєте 'yarn install'. Це робить Yarn швидшим, оскільки уникнуто непотрібних встановлень. Крім того,
                Yarn вводить офлайн-режим, який кешує кожен завантажений пакет, дозволяючи встановлення без підключення
                до Інтернету. Також він перевіряє контрольні суми перед встановленням пакетів для забезпечення їх
                цілісності. Однак NPM має широку підтримку спільноти завдяки своєму тривалішому існуванню, що робить
                його більш надійним для старіших проектів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Різниця між “dependencies” and
                “devDependencies” in package.json?
            </div>
            <div class="collapsible-body">
                У файлі package.json "dependencies" та "devDependencies" мають різні цілі. "Dependencies" включають
                модулі, які необхідні для роботи вашого проекту в продакшн-середовищі. Вони встановлюються, коли ви або
                інший користувач виконує команду "npm install" без будь-яких аргументів.

                З іншого боку, "devDependencies" включають модулі, які потрібні лише під час розробки, а не в
                продакшн-середовищі. Сюди входять фреймворки для тестування, засоби збірки тощо. Вони встановлюються
                лише тоді, коли ви виконуєте "npm install" у своєму локальному середовищі розробки, а не коли
                користувачі встановлюють ваш пакет. Якщо ви використовуєте команду "npm install --production", це
                ігнорує devDependencies.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
            <div class="collapsible-body">
                Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він
                фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені
                залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл
                package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на
                будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію
                вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you handle security
                vulnerabilities in your NPM packages?
            </div>
            <div class="collapsible-body">
                Для роботи з вразливостями безпеки у пакетах NPM я використовую кілька стратегій. По-перше, я
                переконуюся, що всі мої пакети оновлені за допомогою команди 'npm update'. Це тому, що оновлення часто
                містять патчі для відомих вразливостей. По-друге, я використовую npm audit, вбудований інструмент, який
                сканує вразливості і надає детальні звіти. Він також пропонує виправлення, якщо такі є. Для
                автоматизованого сканування вразливостей я інтегрую інструменти, такі як Snyk чи Dependabot, у мій CI/CD
                конвеєр. Ці інструменти надають миттєві сповіщення про нові вразливості і автоматизують процес оновлення
                небезпечних залежностей. Нарешті, я дотримуюся кращих практик, таких як не запускання npm з правами root
                та уникання використання застарілих чи необслуговуваних пакетів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>How do you manually change the version
                of a package using NPM?
            </div>
            <div class="collapsible-body">
                Щоб вручну змінити версію пакету за допомогою NPM, потрібно внести зміни у файл package.json. Цей файл
                містить метадані про ваш проект, включаючи залежності та їх версії. Для зміни версії пакету знайдіть
                його запис у розділі "dependencies" або "devDependencies" та відповідно змініть номер версії.

                Наприклад, якщо ви хочете змінити версію Express з 4.16.3 на 4.17.0, знайдіть рядок "express": "^4.16.3"
                і змініть його на "express": "^4.17.0".

                Після внесення змін у файл package.json виконайте команду `npm install` у вашому терміналі. Ця команда
                оновить ваш каталог node_modules на основі змін, внесених у файл package.json. Якщо виникнуть конфлікти
                між версіями, npm генерує повідомлення про помилку. Розберіть їх перед продовженням.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Як вберегти певний файл від того, що
                його апдейтнуть?
            </div>
            <div class="collapsible-body">
                Щоб уникнути оновлення конкретних пакетів у NPM, ви можете скористатися командою "npm shrinkwrap". Це
                створить файл 'npm-shrinkwrap.json', який фіксує версії кожного пакету та його залежностей у вашому
                проекті. Коли цей файл присутній, команда 'npm install' встановлюватиме точні версії з
                'npm-shrinkwrap.json', ігноруючи будь-які новіші версії, вказані у 'package.json'. Замість цього ви
                також можете вказати точний номер версії пакету у файлі 'package.json'. Якщо ви видалите символи каретки
                (^) чи тильда (~) перед номером версії, npm буде використовувати саме вказану версію під час оновлень.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>Роль package-lock.json?</div>
            <div class="collapsible-body">
                Файл package-lock.json в NPM відіграє важливу роль у забезпеченні послідовності та надійності. Він
                фіксує точну версію кожної встановленої залежності пакету у вашому проекті, включаючи вкладені
                залежності. Це дозволяє проводити детерміновані встановлення, що означає, що будь-який данний файл
                package-lock.json завжди призведе до однакової структури дерева node_modules під час встановлення на
                будь-яких системах чи серверах. Файл генерується автоматично і повинен бути включений до репозиторію
                вихідних кодів для того, щоб надавати цей стабільний стан серед членів команди та процесів розгортання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>В чому різниця команд npm і npx?
            </div>
            <div class="collapsible-body">
                npm та npx - це обидві інструменти, пов'язані з Node.js та управлінням пакетами, але вони мають різні
                призначення.
                npm (Node Package Manager):

                npm - це менеджер пакетів, який використовується для встановлення, оновлення та керування пакетами
                Node.js.
                Використовується для встановлення пакетів глобально або локально в вашому проекті.

                Приклад встановлення пакета глобально: npm install -g example-package
                Приклад встановлення пакетів локально в проекті: npm install package-name


                npx:

                npx - це інструмент, який дозволяє виконувати команди, які містяться в пакетах, не встановлюючи ці
                пакети глобально.
                Зазвичай використовується для виконання одноразових або експериментальних команд.
                Приклад використання npx для виконання команди з пакета, що не встановлено глобально: npx package-name
                command

                Отже, основна різниця полягає в тому, що npm використовується для встановлення та керування пакетами,
                тоді як npx дозволяє виконувати команди з пакетів, не встановлюючи їх глобально.
            </div>
        </li>


    </ul>


    <h5 id="git">GIT</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>Git Reset –soft, –mixed, and –hard
            </div>
            <div class="collapsible-body">
                <strong>git reset --soft < commit ></strong>

                Команда git reset відміняє зміни, зроблені в процесі. Дозволяє перемістити HEAD (поточну версію) до
                визначеного коміту.<br/>
                <strong>Git Reset --soft</strong> - переносить HEAD до вибраного комміту, але залишає стейдж незмінним.
                Це означає, що
                всі зміни після вказаного комміта будуть в стейджі, і ми зможемо їх закомітити знову.
                Виглядає це так: A -- B -- C (HEAD -> main), тоді команда <strong>git reset --soft B</strong> переносить
                нас у: A -- B (HEAD -> main), зміни, які ми зробили
                в коміті С - опиняться в стейджі. <br/>

                <strong>Git Reset --hard</strong> - потенційно найбільш небезпечна команда, оскільки переносить HEAD в
                обраний коміт, при цьому видаляє усі наступні.
                `git reset --hard B` - тепер перемістить нас в коміт B, при цьому вибаливши всі зміни з коміту С.
                Зазвичай використовується, щоб повнісю стерти зміни.

                <strong>Git Reset --mixed</strong> - дефолтна опція, переміщує HEAD до вказаного коміту, як в --soft.
                Якщо максимально просто - то `git reset --mixed B'
                команда перемістить нас на версію коміт В, але зміни з С будуть як untracked changes, а не в стейджі, як
                ми маємо це в --soft.

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>git cherry-pick</div>
            <div class="collapsible-body">

                Команда git cherry-pick в Git використовується для застосування конкретного зобов'язання (commit) з
                однієї гілки до іншої. Це дозволяє перенести вибрані
                зміни з одного коміту на інший, незалежно від того, на якій гілці вони були внесені.

                Синтаксис команди виглядає наступним чином: <strong>git cherry-pick < commit_hash ></strong><br/>
                Основні розділи використання git cherry-pick:
                <ol>
                    <li>Копіювання коміту на поточну гілку - git cherry-pick < commit_hash ></li>
                    <li>Копіювання кількох комітів - git cherry-pick < commit_hash1 > < commit_hash2 > ...</li>
                    <li>Автоматичне вирішення конфліктів - У разі, якщо виникнуть конфлікти при застосуванні коміту, Git
                        повідомить про це, і вам слід вирішити конфлікти вручну.
                    </li>
                </ol>
                !!! Ця команда корисна в ситуаціях, коли ви хочете <strong>перенести конкретні зміни з однієї гілки на
                іншу без копіювання всієї історії гілки</strong>. Важливо враховувати, що при
                використанні git cherry-pick важливо уникати переносу змін, які вже існують на цільовій гілці, оскільки
                це може призвести до конфліктів.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>git fetch</div>
            <div class="collapsible-body">
                Команда git fetch використовується для завантаження змін іншого репозиторію, але не об'єднання їх з
                вашим робочим каталогом або поточною гілкою.
                Це оновлює інформацію про віддалені гілки та зобов'язання, але не змінює ваш робочий каталог.

                Синтаксис команди виглядає так: <strong>git fetch [remote_name]</strong>, де [remote_name] - це ім'я
                віддаленого репозиторію. Якщо ім'я віддаленого репозиторію не вказано, Git використовує за замовчуванням
                origin.

                Основні варіанти використання git fetch:
                <ol>
                    <li>Завантаження змін з віддаленого репозиторію: git fetch</li>
                    <li>Завантаження змін з конкретного віддаленого репозиторію: git fetch [remote_name]</li>
                </ol>
                Після використання git fetch, ви можете переглянути зміни, що були завантажені, і при необхідності
                об'єднати їх з вашим робочим каталогом за допомогою команди git merge або git rebase.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>
                Git merge vs git rebase vs git squash
            </div>
            <div class="collapsible-body">
                В git є 2 принципи переміщення змін з однієї бренчі в іншу - merge and the rebase. Обидві команди
                служать одній і ті ж меті. Проте є принципова різниця в тому, як вони працюють.
                <strong>Git merge</strong><br/>
                Git merge створює новий коміт об'єднання, git rebase переміщує або об'єднує зміни, змінюючи історію
                комітів.
                <p>Важливо використовувати <strong>git rebase</strong> лише для локальних гілок, оскільки вона може
                    переписати історію, що може створити конфлікти у віддалених гілках.</p>
                git rebase використовується для інтеграції змін з однієї гілки в іншу, переміщаючи або об'єднуючи
                коміти. Він допомагає підтримувати лінійну історію проекту, зробивши її більш чистою, ніж традиційне
                злиття. Зазвичай використовується для оновлення гілки функцій із змінами з основної гілки.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як створити та застосувати теги в Git і
                для чого вони використовуються?
            </div>
            <div class="collapsible-body">
                Теги в Git - це вказівники на конкретні коміти, які дозволяють легко ідентифікувати конкретні версії
                вашого коду. Вони корисні для позначення важливих точок в історії вашого проекту, таких як випуски
                програми або стабільні версії.

                Команда:
                git tag < ім'я тегу>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке .gitignore файл і як його
                налаштувати для виключення файлів та каталогів з репозиторію?
            </div>
            <div class="collapsible-body">Файл .gitignore використовується для вказівки Git на те, які файли та каталоги
                повинні бути ігноровані при відстеженні та коміту в репозиторій. Це особливо корисно, коли ви маєте
                файли або каталоги, які ви не хочете включати в контроль версій, наприклад, файли конфігурації, файли
                локальних налаштувань або кешовані файли.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як організувати безпеку Git-репозиторію?
                Як би ви відреагували на можливі загрози?
            </div>
            <div class="collapsible-body">
                <ul>
                    <li>Регулярно робіть резервні копії</li>
                    <li>Стежіть за безпековими оновленнями</li>
                    <li>Використовуйте правила доступу:
                        Налаштуйте правила доступу до репозиторію, визначаючи, хто і як може змінювати код.
                        Використовуйте рівні доступу (read, write, admin) залежно від ролей учасників.
                    </li>
                </ul>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як ви вирішуєте конфлікти під час злиття
                гілок в Git і які інструменти Git ви використовуєте для цього?
            </div>
            <div class="collapsible-body">
                Злиття гілок в Git із конфліктами вимагає ручного вирішення. Для вирішення конфліктів:
                <ol>
                    <li>Після злиття гілок і виникнення конфліктів, Git вказує вам на ці файли та вказує конфліктуючі
                        ділянки коду,
                        які вам потрібно вирішити. Ви редагуєте ці файли, видаляючи мітки конфлікту та виправляючи код
                        так, як вам потрібно;
                    </li>
                    <li>Після вирішення конфліктів відзначте файли як вирішені за допомогою команди git add;</li>
                    <li>Продовжте злиття за допомогою git merge --continue.</li>
                </ol>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Чим відрізняється git pull від git fetch?
            </div>
            <div class="collapsible-body">git pull завантажує зміни з віддаленого репозиторію та об'єднує їх у поточну
                гілку. git fetch лише завантажує зміни, але не автоматично їх об'єднує, залишаючи можливість перегляду
                та ручного об'єднання.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Як ви відміняєте коміт, який вже був
                відправлений в віддалений репозиторій?
            </div>
            <div class="collapsible-body">Відміна коміту включає створення нового коміту, який відміняє зміни. Щоб
                відмінити відправлений коміт, використовуйте <strong>git revert < ідентифікатор-коміту ></strong> і
                потім відправте новий коміт.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Розкажіть про різницю між Git та GitHub
                (або GitLab)
            </div>
            <div class="collapsible-body">Git - це система контролю версій, тоді як GitHub та GitLab - це платформи, що
                надають хостинг для Git-репозиторіїв і додаткові можливості співпраці, такі як відстеження проблем,
                pull-реквести та інше.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Що таке Git hook і як він може бути
                корисним у розробці?
            </div>
            <div class="collapsible-body">Git hook - це скрипт, який автоматично запускається на певних етапах життєвого
                циклу Git. Його можна використовувати для завдань, таких як попередні перевірки перед комітом,
                лінтування чи автоматичного запуску тестування, поліпшуючи розробницький процес.
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>git squash command</div>
            <div class="collapsible-body">
                git squash - це команда, яка дозволяє об'єднати кілька послідовних комітів в один. Це корисно, коли ви
                хочете зберегти лише один об'єднаний коміт замість кількох малих комітів.

                Основна ідея у тому, щоб зменшити кількість комітів у історії репозиторію, роблячи її більш зрозумілою
                та легкою для розуміння.

                Щоб скористатися командою git squash, ви можете використовувати інтерактивний режим перебазування. Ось
                приклад:

                <ol>
                    <li>Виберіть команду перебазування для останніх, наприклад, 3-х комітів: <strong>git rebase -i
                        HEAD~3</strong></li>
                    <li>З'явиться текстовий редактор із списком останніх 3 комітів. Замість слова pick для всіх комітів,
                        які ви хочете об'єднати, змініть його на squash або просто s для скорочення.
                        pick abc123 Some commit message <br/>
                        squash def456 Another commit message <br/>
                        squash xyz789 Yet another commit message
                    </li>
                    <li>Збережіть зміни і закрийте редактор. Відкриється новий редактор для об'єднання повідомлень
                        комітів. Залиште той, який вам потрібен, або об'єднайте їх в одне нове повідомлення.
                    </li>
                    <li>Збережіть зміни, закрийте редактор, і Git об'єднає обрані коміти в один, залишаючи новий коміт
                        зі зміненим повідомленням.
                    </li>
                </ol>
                Зауважте, що використання git squash може вплинути на історію комітів, тому важливо враховувати це при
                використанні в спільної роботи з іншими розробниками або при роботі з гілками, які вже були
                опубліковані.
            </div>
        </li>

    </ul>

    <h5 id="principles">Principles & Stuff</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>ООП</div>
            <div class="collapsible-body">
                Пропонуємо ознайомитися з основними принципами об'єктно-орієнтованого програмування – однієї з найбільш
                важливих методологій розробки, яка ґрунтується на уявленні про програму як про сукупність об'єктів,
                кожен з яких є екземпляром певного класу, а класи утворюють ієрархію наслідування.
                Об'єктно-орієнтоване програмування (ООП) включає в себе низку принципів, які допомагають створювати
                гнучкі, розширювані та підтримувані програми. Основні принципи ООП включають такі:
                <ol>
                    <li><strong>Інкапсуляція (Encapsulation)</strong>: Інкапсуляція вказує на об'єднання даних та
                        методів, які працюють з цими даними, в один об'єкт або клас. Змінні часто називаються "полями",
                        а методи - "методами". Забезпечує обмежений доступ до внутрішніх деталей об'єкта та захищає дані
                        від прямого доступу та неправильного використання.
                        Одним з визначальних факторів при проектуванні компонентів програми є приховування внутрішніх
                        даних компоненту і деталей його реалізації від інших компонентів програми та надання набору
                        методів для взаємодії з ним (API). Цей принцип є одним з чотирьох фундаментальних принципів ООП
                        і називається інкапсуляцією.
                        <br/>
                        <strong>Правильна інкапсуляція має велике значення з багатьох причин:</strong>
                        <ol>
                            <li>Вона сприяє повторному використанню компонентів: оскільки в цьому випадку компоненти
                                взаємодіють між собою лише через їх API і нечутливі до змін внутрішньої структури, вони
                                можуть використовуватись в більш широкому контексті.
                            </li>
                            <li>Інкапсуляція пришвидшує процес розробки: слабко пов'язані один з одним компоненти (тобто
                                компоненти, чий код якомога менше звертається або використовує код інших компонентів)
                                можуть розроблятися, тестуватися та доповнюватися незалежно.
                            </li>
                            <li>Правильно інкапсульовані компоненти більш зрозумілі та легше налагоджуються, що спрощує
                                підтримку програми.
                            </li>
                        </ol>
                        інкапсуляція реалізована за допомогою системи класів, які дозволяють зібрати інформацію про
                        об'єкт в одному місці; пакетів, які групують класи по певному критерію, і модифікаторів доступу,
                        якими можна позначити весь клас або його поле чи метод.

                        Всього існує чотири модифікатори доступу:
                        <ul>
                            <li><strong>public</strong> – повний доступ до сутності (полю або методу класу) з будь-якого
                                пакету;
                            </li>
                            <li><strong>protected</strong> – доступ до сутності лише для класів свого пакету і нащадків
                                класу;
                            </li>
                            <li><strong>private</strong> – доступ тільки всередині класу, в якому оголошена сутність;
                            </li>
                            <li><strong>неявний модифікатор за замовчуванням</strong> (за відсутності трьох явних) –
                                доступ до сутності лише для класів свого пакету.
                            </li>
                        </ul>
                        Для досягнення правильної інкапсуляції також необхідно надати коректний API для роботи з
                        компонентом. Наприклад, в сеттер для змінної можна включити логіку перевірки значень, які
                        передаються, або не надавати сеттери в класі взагалі, якщо клас повинен бути доступним лише для
                        читання.
                    </li>
                    <li><strong>Наслідування (Inheritance)</strong>: Спадкування дозволяє створювати новий клас на
                        основі існуючого, успадковуючи його властивості та методи. Новий клас називається "підкласом"
                        або "потомком", а клас, від якого успадковується, - "базовим класом" або "батьківським класом".
                        Дозволяє повторно використовувати код, створювати ієрархії та розширювати функціональність.
                        Наслідування є одним з найвагоміших принципів об'єктно-орієнтованого програмування, оскільки
                        воно дозволяє створювати ієрархічні структури об'єктів. Використовуючи наслідування можна
                        створити загальний клас, який буде визначати характеристики і поведінку, властиві певному набору
                        пов'язаних об'єктів. В подальшому цей клас може наслідуватися іншими, другорядними класами,
                        кожен з яких додаватиме унікальні, властиві лише йому характеристики і доповнюватиме або
                        змінюватиме поведінку базового класу.

                    </li>
                    <li><strong>Поліморфізм (Polymorphism)</strong>:
                        Поліморфізм вказує на можливість об'єктів реагувати на спільні методи, але робити це відповідно
                        до свого власного типу. Може бути реалізований через перевантаження методів та використання
                        інтерфейсів. Забезпечує заміну об'єктів їхніми схожими з точки зору використання, незалежно від
                        конкретного типу.
                        Розглядаючи поліморфізм необхідно пам'ятати, що цей принцип нерозривно пов'язаний з іншим
                        принципом ООП – наслідуванням, яке допомагає реалізувати поліморфізм. Візьмемо для прикладу
                        абстрактний клас «Автомобіль», який наслідують два конкретних класи – «Спортивний автомобіль» та
                        «Вантажний автомобіль».

                        І спортивні, і вантажні автомобілі володітимуть спільними характеристиками і матимуть можливість
                        виконувати загальні для всіх автомобілів дії, вказані в абстрактному батьківському класі, але
                        конкретна реалізація цих дій може бути різною.

                        Наприклад, загальна для всіх автомобілів дія «завестись» у спортивному автомобілі може бути
                        реалізована шляхом натискання кнопки, а у вантажного - за допомогою ключа. Один результат –
                        різні рішення. В цьому і полягає поліморфізм.

                        Більш точно, поліморфізм - один з принципів ООП, який дозволяє викликом перевизначеного методу
                        через змінну батьківського класу отримати поведінку, яка буде відповідати реальному похідному
                        класу, на який посилається ця змінна.
                    </li>
                    <li><strong>Абстракція (Abstraction)</strong>: (від лат. abstractio — виокремлення, відсторонення
                        або відділення) - Абстракція полягає в визначенні загального та необхідного набору властивостей
                        чи методів для класу, приховуючи деталі його реалізації. Спрощує складність, забезпечує
                        спрощення взаємодії та створення високорівневих концепцій.
                        В цьому і полягає абстракція: фокусування розробника на конкретних властивостях об'єкта залежить
                        від тих задач, які повинен вирішувати об'єкт. Наслідком такого підходу є те, що, якщо в
                        імперативних мовах програмісту необхідно думати в термінах комп'ютерної логіки, то в
                        об'єктно-орієнтованих мовах розробник думає в термінах проблемної сфери, в якій він розробляє
                        програму.
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>Основні принципи та патерни
                проектування - SOLID
            </div>
            <div class="collapsible-body">
                <ul>
                    <li><strong>Single Responsibility Principle (Принцип єдиної відповідальності)</strong>: Кожен клас
                        повинен мати лише одну причину для зміни. Він повинен виконувати лише одну конкретну роботу.
                    </li>
                    <li>Open/Closed Principle (Принцип відкритості/закритості): Сутності (класи, модулі та ін.) повинні
                        бути відкритими для розширення, але закритими для модифікації. Додавання нового функціоналу
                        повинно бути можливим без зміни існуючого коду.
                    </li>
                    <li>Liskov Substitution Principle (Принцип підстановки Барбари Лісков): Об'єкти базового класу
                        повинні можливо без проблем підставлятися своїми похідними класами без зміни правильності
                        програми.
                    </li>
                    <li>Interface Segregation Principle (Принцип розділення інтерфейсу): Клієнти не повинні залежати від
                        інтерфейсів, які вони не використовують. Маленькі та специфічні інтерфейси краще, ніж великі
                        загальні.
                    </li>
                    <li>Dependency Inversion Principle (DIP) - це один із п'яти принципів SOLID. Він заявляє, що
                        високорівневі модулі не повинні залежати від низькорівневих модулів. Обидва типи модулів повинні
                        залежати від абстракцій, а не деталей.
                    </li>
                </ul>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">place</i>Основні принципи та патерни проектування
                - KISS (Keep It Simple, Stupid)
            </div>
            <div class="collapsible-body">

            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVC Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>Концепція Модель-Вид-Контролер (MVC)</strong> є парадигмою архітектури програмного забезпечення, яка спрощує
                    розробку та підтримку додатків шляхом розділення їхніх відповідальностей на три основних компоненти.</p>
                <ol>
                    <li>
                        <strong>Модель (Model): </strong>
                        <p>Цей компонент відповідає за представлення та обробку даних додатку. Модель має уявлення про структуру та типи
                            даних, які використовуються в додатку, і відповідає за доступ до цих даних, виконання операцій над ними та
                            повідомлення про будь-які зміни. Це може бути база даних, файлова система або будь-яке інше сховище даних.</p>
                    </li>
                    <li>
                        <strong>Вид (View):</strong>
                        <p>Компонент Виду відповідає за відображення інформації користувачу та взаємодію з користувачем. Він приймає дані
                            від моделі та представляє їх у вигляді, зрозумілому користувачеві. Вид також реагує на введення користувача та
                            надсилає відповідні сигнали Контролеру.</p>
                    </li>
                    <li>
                        <strong>Контролер (Controller): </strong>
                        <p>Цей компонент обробляє введення від користувача та взаємодіє як з Видом, так і з Моделлю для реалізації потрібної
                            функціональності. Контролер взаємодіє з Видом для отримання введення та визначення, які дії слід виконати. Після
                            цього він здійснює відповідні дії з Моделлю для оновлення стану додатку.</p>
                    </li>
                </ol>
                <p>Однією з ключових переваг використання MVC є зменшення взаємозалежності між компонентами, що полегшує модифікацію та
                    розширення коду. Це також дозволяє різним командам або розробникам працювати над окремими компонентами, не впливаючи
                    одне на одне. Розділення відповідальностей робить програму більш читабельною та підтримуваною в майбутньому.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVVM Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>MVVM (Model-View-ViewModel)</strong> - це архітектурний патерн, який використовується для розробки програмних
                    додатків і особливо популярний в розробці веб-додатків та мобільних додатків. Цей патерн виник в межах платформи
                    Microsoft WPF (Windows Presentation Foundation) і став популярним завдяки введенню технології біндингу даних, яка
                    дозволяє легко зв'язувати дані моделі з представленням.</p>
                <p>Основні компоненти MVVM:</p>
                <ol>
                    <li>
                        <strong>Модель (Model):</strong>
                        <p>Модель представляє дані та логіку додатку. Це може бути об'єкт або набір об'єктів, які представляють дані, з
                            якими взаємодіє користувач та додаток.</p>
                    </li>
                    <li>
                        <strong>Вид (View): </strong>
                        <p>Вид відповідає за відображення інтерфейсу користувача (UI). Він отримує дані від ViewModel та відображає їх на
                            екрані.</p>
                    </li>
                    <li>
                        <strong>ViewModel: </strong>
                        <p>ViewModel виконує роль посередника між Моделлю та Видом. Він обробляє логіку, пов'язану з відображенням та
                            взаємодією з користувачем. ViewModel також забезпечує ізоляцію відповідальностей, забезпечуючи, що Модель та Вид
                            не взаємодіють безпосередньо один з одним.</p>
                    </li>
                </ol>
                <p>Основні концепції MVVM:</p>
                <ul>
                    <li>
                        <strong>Двосторонній біндінг (Two-way Data Binding):</strong>
                        <p>Це забезпечує автоматичну синхронізацію між ViewModel і Видом. Якщо дані змінюються в одному компоненті
                            (наприклад, в Виді), вони автоматично оновлюються в іншому (наприклад, у ViewModel) і навпаки.</p>
                    </li>
                    <li>
                        <strong>Команди (Commands):</strong>
                        <p>ViewModel може містити команди, які дозволяють взаємодіяти з користувачем або обробляти події.</p>
                    </li>
                    <li>
                        <strong>Інверсія управління (Inversion of Control): </strong>
                        <p>ViewModel може взаємодіяти з сервісами та іншими компонентами завдяки принципам інверсії управління, забезпечуючи
                            більшу гнучкість та тестованість.</p>
                    </li>
                    <li>
                        <strong>Тестування (Testing): </strong>
                        <p>Розділення логіки додатку між Моделлю і ViewModel полегшує тестування кожного компонента окремо.</p>
                    </li>
                </ul>
                <p>
                    MVVM дозволяє розділити відповідальності між різними компонентами, забезпечуючи більшу гнучкість, підтримку тестування
                    та ефективну розробку користувацьких інтерфейсів.
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVP Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>MVP (Model-View-Presenter)</strong> - це архітектурний патерн, який використовується для розробки програмного
                    забезпечення, особливо в інтерфейсах користувача. Цей патерн розширює базову концепцію Model-View-Controller (MVC) та
                    робить акцент на відокремленні бізнес-логіки від представлення даних та їх обробки.</p>
                <p>Основні компоненти MVP:</p>
                <ol>
                    <li>
                        <strong>Модель (Model):</strong>
                        <p>Модель відповідає за представлення даних та бізнес-логіки додатку. Це може бути об'єкт або група об'єктів, які
                            відображають стан та логіку додатку.</p>
                    </li>
                    <li>
                        <strong>Вид (View): </strong>
                        <p>Вид відповідає за відображення інтерфейсу користувача (UI). Він не має власної бізнес-логіки і взаємодії з
                            даними. Замість цього, він реагує на події та передає їх до Презентера для обробки.</p>
                    </li>
                    <li>
                        <strong>Презентер (Presenter): </strong>
                        <p>Презентер виступає як посередник між Моделлю та Видом. Він обробляє всю бізнес-логіку та логіку взаємодії з
                            даними. Презентер отримує дані від Моделі, обробляє їх та оновлює Вид.</p>
                    </li>
                </ol>
                <p>Основні концепції MVP:</p>
                <ul>
                    <li>
                        <strong>Відокремлення відповідальностей: </strong>
                        <p>MVP відокремлює бізнес-логіку від інтерфейсу користувача, роблячи код більш чистим та підтримуваним.</p>
                    </li>
                    <li>
                        <strong>Тестування: </strong>
                        <p>Розділення логіки між Моделлю, Видом та Презентером полегшує тестування кожного компонента окремо. Презентер може
                            тестуватися без інтерфейсу, що спрощує процес.</p>
                    </li>
                    <li>
                        <strong>Гнучкість та розширюваність: </strong>
                        <p>Оскільки кожен компонент виконує конкретну функцію, система стає більш гнучкою та легко розширюваною.</p>
                    </li>
                </ul>
                <p>
                    Основна ідея MVP - надавати чіткий розділ відповідальностей між компонентами, що полегшує розробку та тестування
                    програмного забезпечення. Проте, важливо враховувати, що реалізація MVP може відрізнятися в різних платформах та
                    технологіях.
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                MVI Design Pattern
            </div>
            <div class="collapsible-body">
                <p><strong>MVI (Model-View-Intent)</strong> - це архітектурний патерн, який широко використовується в розробці програмного
                    забезпечення, особливо в мобільних додатках. Цей патерн є еволюцією ідей, що виникали з архітектурних патернів, таких як
                    MVP (Model-View-Presenter) та MVVM (Model-View-ViewModel).</p>
                <p>Основні компоненти MVI:</p>
                <ol>
                    <li>
                        <strong>Модель (Model):</strong>
                        <p>Модель відповідає за представлення даних та бізнес-логіки додатку. Це може бути клас або група класів, що
                            відображають стан та операції, які можна виконати над даними.</p>
                    </li>
                    <li>
                        <strong>Вид (View): </strong>
                        <p>Вид відповідає за відображення інтерфейсу користувача (UI). У випадку MVI, він також відповідає за відображення
                            стану додатку.</p>
                    </li>
                    <li>
                        <strong>Інтент (Intent): </strong>
                        <p>Інтент представляє користувацьке намірення або дію, яку користувач хоче виконати. Він передається від Виду до
                            Процесора (Processor).</p>
                    </li>
                    <li>
                        <strong>Процесор (Processor): </strong>
                        <p>Процесор обробляє інтент, взаємодіє з Моделлю та визначає новий стан додатку. Це може включати в себе виклик
                            методів Моделі, перевірку умов та взаємодію з різними джерелами даних.</p>
                    </li>
                </ol>
                <p>Основні концепції MVI:</p>
                <ul>
                    <li>
                        <strong>Неімутабельність (Immutability): </strong>
                        <p>Стан додатку та об'єкти повинні бути неімутабельними, що означає, що їхні значення не можна змінювати після
                            створення.</p>
                    </li>
                    <li>
                        <strong>Однозначність стану (State Unidirectionality):</strong>
                        <p>Дані та стан додатку повинні рухатися в одному напрямку, що полегшує відслідковуваність та розуміння стану.</p>
                    </li>
                    <li>
                        <strong>Реактивність (Reactivity): </strong>
                        <p>MVI сприяє реактивному підходу, де зміни в додатку відбуваються відповідно до подій та змін стану.</p>
                    </li>
                    <li>
                        <strong>Тестовість (Testability): </strong>
                        <p>Патерн робить код більш тестовим, оскільки стан та логіка відокремлені, а обробка інтентів відбувається
                            визначеною логікою Процесора.</p>
                    </li>
                </ul>
                <p>
                    MVI дозволяє створювати додатки, які є більш декларативними та зменшують побічні ефекти. Він особливо популярний в
                    сучасному розвитку мобільних додатків, де реактивні та функціональні підходи стають стандартом.
                </p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Підходи mvc vs mvp vs mvvm vs mvi - в яких випадках краще використовувати?
            </div>
            <div class="collapsible-body">
                <p>
                    Вибір між архітектурними патернами, такими як MVC, MVP, MVVM чи MVI, може залежати від конкретних вимог та контексту
                    вашого проекту. Ось загальні рекомендації:</p>
                <ol>
                    <li>
                        <strong>MVC (Model-View-Controller):</strong>
                        <ul>
                            <li>Використовуйте, якщо ваша система має простий та невеликий інтерфейс.</li>
                            <li>Підходить для традиційних веб-застосунків.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>MVP (Model-View-Presenter):</strong>
                        <ul>
                            <li>Корисно, коли важлива тестованість і розширюваність коду.</li>
                            <li>Підходить для великих та складних проектів, де важлива чистота коду та його тестування.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>MVVM (Model-View-ViewModel):</strong>
                        <ul>
                            <li>Використовуйте, якщо вам важлива розділеність логіки інтерфейсу користувача від бізнес-логіки.</li>
                            <li>Ідеально підходить для розробки застосунків з великою кількістю динамічного вмісту та даних.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>MVI (Model-View-Intent):</strong>
                        <ul>
                            <li>Корисно, коли пріоритети - це однозначність та сталість стану.</li>
                            <li>Добре підходить для застосунків, де стан дуже важливий, і важлива реакція на введення користувача.</li>
                            <li><strong>Додатки з великим обсягом даних:</strong> MVI може бути корисним для розробки додатків, які
                                взаємодіють з великим
                                обсягом даних, оскільки він дозволяє ефективно керувати потоком даних та оновленнями.
                            </li>
                            <li><strong>Додатки зі складною логікою інтерфейсу: </strong> Для додатків, де інтерфейс користувача має складну
                                логіку та залежить від багатьох факторів, MVI може допомогти структурувати та робити код більш придатним для
                                тестування.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Важливо також враховувати досвід команди розробників, їхні вподобання та специфіку проекту. У деяких випадках
                    комбінування різних патернів може бути найбільш ефективним рішенням.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Порівнюємо способи генерації сторінок: CSR, SSR, SSG, ISR.
            </div>
            <div class="collapsible-body">
                <p>В древні часи, не було ніяких Реактів чи Ангулярів і всі сайти були «багатосторінкові» додатки. Ми відкривали адресу
                    сайту в браузері, йшов запит на сервер, де якийсь умовний PHP генерував нам цілу сторінку (весь HTML, CSS та трішки
                    JS) і повертав клієнту. Коли ми натискали на посилання на іншу сторінку, знову слали такий же запит, сервер генерував
                    нову сторінку і повертав її. Браузер видаляв стару та рендерив нову, при цьому відбувався такий собі «блік» при
                    переходах між сторінками. Даний підхід називається Multi page application (MPA).</p>
                <p>З точки зору SEO — це ідеальний підхід. Ми маємо повну сторінку з усією необхідною інформацією і будь-який пошуковий бот
                    відразу її зчитував, наші сайти в топі пошукової видачі, клієнти (власники цих сайтів) — щасливі.</p>
                <p>З точки зору користувачів сайтів — не все так ідеально. При відкритті кожної наступної сторінки ми чекаємо, доки
                    завантажаться всі ресурси заново та відрендериться сторінка. Звісно, більшість ресурсів уже закешовані, але все одно
                    очікуємо повного відмалювання сторінки. Ну, і бліки при переходах ніхто не скасовував.</p>
                <p>Революцією в цьому підході стала поява фреймворків, які дозволяли реалізовувати так звані односторінкові сайти — Single
                    Page Application (SPA). Суть в тому, що ми один раз завантажуємо CSS, JS та практично порожню HTML-сторінку, і потім JS
                    уже будує все в клієнтському браузері. При переході між сторінками JS перебудовує лише ту частину, яка змінилась, і при
                    цьому, за потреби, робить AJAX запит на сервер, щоб отримати необхідні дані. Ми позбулися бліків!</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Клієнтська генерація сторінок — Client-Side Rendering (CSR)
            </div>
            <div class="collapsible-body">
                <p>Підхід доволі простий, особливо в наші дні. Створений додаток складається з кількох файлів: файл стилів, скрипти та
                    умовно порожня HTML-сторінка, в якій підключаються стилі та скрипти. У файлі index.html з тегів є лише один div з
                    id="root«, де і будується вся сторінка. При переході між сторінками змінюється URL-адреса в браузері та підтягуються
                    дані з сервера, за потреби. Реалізація проста, на сервер навантаження мінімальні, адже не потрібно рендерити сторінку на
                    кожен запит, а лише повернути статичні файли. Якщо потрібні дані, можна створити окремий RESTful сервер, який
                    повертатиме дані в JSON форматі.</p>
                <p>Як бонус — легкість масштабування, і дані можуть використовуватися різними клієнтами (вебсторінки, мобільні додатки, інші
                    сервера). До того ж можна зекономити на хостингу. Вам не потрібно багато ресурсів, щоб повернути декілька файлів.</p>
                <p>Звісно, в даному підході страждає SEO. Додатково можуть виникнути проблеми при спробі поділитися такими сторінками в
                    соціальних мережах, адже їм також потрібно завантажити сторінку, відрендерити її та знайти потрібні дані. Ну, і не
                    забуваємо про користувачів, якщо в них старі слабенькі телефони, то рендеринг сторінки займе цілу вічність.</p>
                <br>
                <strong>Переваги</strong>
                <ul>
                    <li>легкість реалізації</li>
                    <li>менше навантаження на сервер</li>
                    <li>актуальність інформації</li>
                    <li>можна обійтися без сервера</li>
                    <li>легкість масштабування</li>
                    <li>дешевший хостинг</li>
                </ul>
                <strong>Недоліки</strong>
                <ul>
                    <li>страждає SEO</li>
                    <li>social media crawlers та проблеми з share</li>
                    <li>більше навантаження на пристрої клієнтів</li>
                    <li>розмір js файлу при першому завантаженні</li>
                </ul>
                <p><strong>Інструменти: </strong>react-create-app, React і конфігурація вручну.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Серверна генерація сторінок — Server-Side Rendering (SSR)
            </div>
            <div class="collapsible-body">
                <p>Головна особливість цього підходу в тому, що вся сторінка рендериться на сервері при першому запиті, а потім уже в
                    браузері ініціалізується React, і далі додаток працює як звичайний SPA, виконуючи, за потреби, AJAX-запити на сервер.
                    Дані завантажуються завжди актуальні, адже при кожному перезавантаженні сторінки відбувається запит на сервер. З точки
                    зору SEO все також ідеально: повертається повноцінна сторінка. Користувачі також задоволені — працюють зі звичайним SPA,
                    різниці вони не бачать.</p>
                <p>Хоч і виникає потреба в підтримці потужного сервера, який буде обробляти усі запити, тут є і перевага. Можна налаштувати
                    кешування для найпопулярніших запитів, що прискорить завантаження та відображення сторінки.</p>
                <strong>Переваги:</strong>
                <ul>
                    <li>ідеальна реалізація SEO;</li>
                    <li>актуальність інформації;</li>
                    <li>швидкість завантаження та відображення контенту (Time to Interactive);</li>
                    <li>налаштування кеша на сервері.</li>
                </ul>
                <strong>Недоліки:</strong>
                <ul>
                    <li>складність реалізації</li>
                    <li>навантаження на сервер;</li>
                    <li>збільшення розміру файлів що завантажуються з сервера;</li>
                    <li>довша відповідь від сервера (TTFB — Time to first byte).</li>
                </ul>
                <p><strong>Інструменти: </strong>NodeJS; NextJS.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Статична генерація сайтів — Static Site Generation (SSG)
            </div>
            <div class="collapsible-body">
                <p>Чи потрібно нам кожен раз на сервері генерувати цілу сторінку, якщо дані не так часто оновлюються? Для різних лендінгів,
                    сайтів-візиток, блогів, простих інтернет-магазинів, де інформація оновлюється дуже рідко, підтримка серверного
                    рендерингу може бути накладною та надлишковою.</p>
                <p>Тут на сцену виходить SSG. Навіщо виконувати генерацію на кожен запит, якщо можна один раз при побудові додатку
                    згенерувати усі сторінки. Просто складаємо в папку всі HTML (CSS та JS) файли, розміщуємо їх на простенькому файловому
                    сервері чи взагалі в CDN і повертаємо при кожному запиті. Повна відсутність сервера для обробки запитів чи генерування
                    сторінок. Отримуємо максимальну швидкість завантаження та безпеку. Безпечний сервер — той сервер, якого нема.</p>
                <p>З точки зору SEO — це ідеальний варіант. Для користувача сторінка відображається ще швидше ніж при SSR, ми не очікуємо
                    дані на сервері, тому TTFB менший. Для користувачів все залишається незмінним, адже після завантаження сторінки там
                    знову ініціалізуються React і додаток працює, як звичайний SPA.</p>
                <p>Недоліком даного підходу являється те, що при оновленні даних потрібно повністю перезібрати проєкт і відрендерити всі
                    сторінки. Я б не назвав це недоліком, все так, це більше особливість. Якщо сайт містить близько 100 000 сторінок, то
                    генерація може зайняти декілька годин. На це потрібно звернути увагу.</p>
                <p>
                    Також може виникнути питання: а як щодо взаємодії користувача з сайтом? Що робити, якщо потрібно відправити якусь форму
                    або зібрати інформацію? Ніхто не забороняє запустити окремий RESTful сервер, який відповідатиме за обробку різноманітних
                    запитів від клієнтів. Також можна звернути увагу на Serverless або «хмарні функції», рекомендую глянути на AWS Lambda
                    або GCP Cloud functions.
                </p>
                <strong>Переваги:</strong>
                <ul>
                    <li>ідеальна реалізація SEO;</li>
                    <li>швидкість завантаження та відображення;</li>
                    <li>надійність та безпека (нема сервера);</li>
                    <li>дешевий хостинг.</li>
                </ul>
                <strong>Недоліки:</strong>
                <ul>
                    <li>при оновленні контенту потрібно перезбирати проєкт;</li>
                    <li>час на генерацію великої кількості сторінок, наприклад для 100 000 продуктів.</li>
                </ul>
                <p><strong>Інструменти: </strong>GatsbyJS; NextJS.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Інкрементальна регенерація статичних сторінок — Incremental Static Regeneration (ISR)
            </div>
            <div class="collapsible-body">
                <p>Даний метод поєднує переваги двох попередніх. Не завжди потрібно генерувати сторінку при кожному запиті, та й заздалегідь
                    нагенеровані сторінки не є рішенням, якщо контент час від часу оновлюється.</p>
                <p>Рішенням буде розділення сторінок. Ті, що частіше оновлюються, будуть рендеритися за допомогою SSR, ті, що рідко
                    оновлюються, будуть згенеровані за допомогою SSG.</p>
                <strong>Переваги:</strong>
                <ul>
                    <li>ідеальна реалізація SEO;</li>
                    <li>швидкість завантаження та відображення;</li>
                    <li>можна застосовувати для деяких сторінок;</li>
                    <li>відносна актуальність інформації.</li>
                </ul>
                <strong>Недоліки:</strong>
                <ul>
                    <li>складність реалізації;</li>
                    <li>необхідний сервер.</li>
                </ul>
                <p><strong>Інструменти: </strong>NextJS.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Різниця між бібліотекою і фреймворком
            </div>
            <div class="collapsible-body">
                <p><strong>Бібліотека</strong> - це збірка наперед написаного коду, який може бути використаний повторно для виконання
                    конкретних
                    завдань,
                    таких як створення інтерфейсів користувача чи обробка мережевих запитів. Зазвичай бібліотека надає набір функцій чи
                    класів, які можуть бути викликані розробником у його коді для виконання певного завдання. Бібліотеки призначені бути
                    гнучкими і можуть використовуватися в різноманітних застосуваннях.</p>
                <p>З іншого боку, фреймворк - це більш комплексний набір інструментів і конвенцій, який надає структуру для будівництва
                    цілого додатку. Фреймворк зазвичай включає набір бібліотек і інструментів, а також набір правил і найкращих практик, які
                    керують процесом розробки. Фреймворки надають більш предкриптивний підхід до розробки додатків, і розробники часто
                    повинні дотримуватися вказівок фреймворку, щоб забезпечити коректне інтегрування їх коду з іншою частиною додатку.</p>
                <p>У порівнянні бібліотек та фреймворків в питаннях на співбесіді для старшого фронтенд-розробника, можна зазначити, що,
                    хоча обидва надають написаний код для будівництва додатків, основна різниця полягає в їхньому обсязі та рівні
                    абстракції. Бібліотеки є більш гнучкими і можуть бути використані для різних завдань, тоді як фреймворки надають більш
                    комплексний набір інструментів і конвенцій для будівництва цілих додатків.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                CI vs CD vs CD: різниця підходів і чому вони важливі
            </div>
            <div class="collapsible-body">
                <p>Continuous Integration, Delivery та Deployment — процеси, що дозволяють полегшити впровадження змін у застосунку для
                    їхнього швидкого розгортання у середовище (prod, staging, dev та інші). Частіше всього, це реалізується за допомогою
                    створення пайплайнів, що автоматизують певні повторювані дії.</p>
                <p>[Continuous Integration: - Build - Test - Merge]</p>
                <p>[Continuous Delivery - Automated Release]</p>
                <p>[Continuous Deployment: - Automated Deployment]</p>

                <strong>Continuous Integration</strong><br>
                <p>Continuous Integration — це процес об’єднання змін у коді від декількох розробників в один спільний проєкт, що має
                    виконуватись якомога частіше. Загалом цю задачу покладають на систему контролю версій. А чому це необхідно?</p>
                <p>Зараз більшість репозиторіїв налаштовано так, що під час внесення будь-яких змін у систему контролю версій ми запускаємо
                    ланцюжок процесів, що мають перевірити базову працездатність коду — тестування, правила форматування, компіляція
                    останньої версії коду для перевірки, а чи нема в нових змінах помилок, що «завалять» потенційний білд.</p>
                <p>Тож усі ці процеси направлені на те, щоб раніше виявляти потенційні баги, покращувати якість кінцевого продукту та
                    скоротити час верифікації та релізу нового функціоналу. І хоча неможливо уникнути виникнення багів, Continuous
                    Integration може допомогти шляхом їх виявлення та усунення. Це головна причина, чому сьогодні бізнес відходить від
                    застарілих підходів до СІ.</p>
                <p>Якщо на якійсь із цих стадій була виявлена помилка, результат цього пайплайну відображався на сторінці пул реквесту та не
                    дозволяв мерджити гілки. Тож помилка мала бути виправлена, і вже новий успішний пайплайн вважався одним з обов’язкових
                    пунктів для закриття пул реквесту. Так, ми отримали функціонал — протестований і перевірений, — для того, щоб передати
                    його наступній фазі.</p>

                <strong>Continuous Delivery та Deployment</strong><br>
                <p>Continuous Delivery - По суті, це автоматизоване впровадження останньої версії продукту в Production та інші середовища.
                    Але до цього код має пройти автоматизовані Unit-, Integration- та System-тестування, що проводяться на стадії
                    інтеграції.</p>
                <p>Тобто поєднуючи два процеси, наведені вище, ми можемо отримати протестований функціонал одразу розгорнутим у середовищі
                    за допомогою пайплайну в один клік. Звичайно ж, рішення про розгортання нового релізу має ухвалюватися людиною, але
                    підготовкою займається система.</p>
                <p>Розглянемо інший процес, який називається Continuous Deployment. Це наступний крок у розгортанні змін на середовищі. По
                    своїй суті, continuous deployment — це практика у розробці, коли будь-які зміни якнайшвидше потрапляють у
                    production-середовище.</p>
                <p>На меті цей процес ставить лише одне: релізити зміни, які роблять розробники, якомога частіше й швидше доставляти їх
                    кінцевим користувачам. Тобто коли випускається новий реліз, пайплайн підхоплює його, верифікує, чи всі перевірки
                    виконані, та створює білд, який буде розгорнутий одразу на Production.</p>


                <p><strong>У чому ж різниця між Continuous Delivery та Deployment?</strong></p>
                <p>Якщо коротко, то Continuous Delivery спрямований на підтримку коду в стані, коли він завжди готовий піти в реліз та бути
                    розгорнутим у Production, але лише за вказівкою людини, що контролює цей процес.</p>
                <p>На противагу цьому Continuous Deployment скорочує цей процес, та за першої ж можливості, коли тест-плани успішні,
                    розгортає зміни в середовищі.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Як працює стиснення Gzip ?
            </div>
            <div class="collapsible-body">
                Стиснення Gzip - це метод зменшення розміру файлів, що передаються через мережу, шляхом використання алгоритму стиснення
                Gzip.
                <ol>
                    <li>
                        <strong>Алгоритм стиснення:</strong>
                        <p>Gzip використовує алгоритм стиснення DEFLATE для зменшення обсягу текстових файлів. Цей алгоритм використовує
                            кодування LZ77 (алгоритм стиснення з використанням скользячого вікна) та кодування довжин і відстаней.</p>
                    </li>
                    <li>
                        <strong>Виявлення повторень:</strong>
                        <p>Під час стиснення Gzip алгоритм виявляє повторення в тексті і замінює їх коротшими символьними представленнями.
                            Це дозволяє ефективно зменшити розмір файлу.</p>
                    </li>
                    <li>
                        <strong>Блокова стискальна структура:</strong>
                        <p>Закодовані дані розділяються на блоки, кожен з яких стискається незалежно. Це забезпечує ефективність стиснення
                            для різних частин файлу.</p>
                    </li>
                    <li>
                        <strong>Заголовки та мета-інформація:</strong>
                        <p>Кожен стиснутий файл має спеціальний заголовок, що вказує на те, що це стиснутий файл Gzip. Це дозволяє браузерам
                            та серверам розпізнавати такі файли та правильно їх розпаковувати.</p>
                    </li>
                    <li>
                        <strong>Розпакування на боці отримувача:</strong>
                        <p>Коли стиснутий файл досягає веб-браузера або іншого клієнта, він розпаковується перед відображенням або
                            використанням. Цей процес відбувається автоматично, і користувач не бачить розпакованого вмісту.</p>
                    </li>
                </ol>

                <p>Давайте розглянемо приклад стиснення Gzip на основі простого текстового рядка. Припустимо, у нас є наступний текст:</p>
                <p><strong>This is a simple example of Gzip compression.</strong></p>
                <p>Тепер розглянемо, як цей текст може бути стиснений за допомогою алгоритму стиснення DEFLATE, який використовується в
                    Gzip.</p>
                <ol>
                    <li>
                        <strong>Виявлення повторень:</strong>
                        <p>Алгоритм виявляє повторення в тексті. У нашому випадку, наприклад, фраза "is" повторюється.</p>
                    </li>
                    <li>
                        <strong>Заміна повторень:</strong>
                        <p>Повторення замінюються коротшими символьними представленнями. Нехай "is" буде замінено якимось унікальним кодом,
                            скажімо, #1#.</p>
                    </li>
                    <li>
                        <strong>Стискальна структура:</strong>
                        <p>Текст розбивається на блоки, і кожен блок стискається незалежно від інших.</p>
                    </li>
                </ol>
                <p>Отже, після стиснення наш текст може виглядати, наприклад, так:</p>
                <p><strong>Th#1# a simple example of Gz#1#p compr#1#ssion.</strong></p>

                <p>Стиснення Gzip дозволяє значно зменшити розмір файлів, що передаються по мережі, зменшуючи час завантаження сторінок та
                    поліпшуючи продуктивність веб-сайтів.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Compilation vs Interpretation: в чому різниця?
            </div>
            <div class="collapsible-body">
                <p>Компіляція та інтерпретація - це два різних підходи до виконання програмного коду.</p>
                <ol>
                    <li>
                        <strong>Компіляція:</strong>
                        <ul>
                            <li>
                                <strong>Процес: </strong>
                                <p>Компіляція включає в себе перетворення вихідного коду програми (зазвичай у вищорівневій мові
                                    програмування, такій як C, C++, або TypeScript) у машинний код або код іншої мови, який може
                                    виконуватися безпосередньо на апаратному рівні.</p>
                            </li>
                            <li>
                                <strong>Використання: </strong>
                                <p>Отриманий під час компіляції виконуваний файл може бути запущений без наявності вихідного коду
                                    програми.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Інтерпретація:</strong>
                        <ul>
                            <li>
                                <strong>Процес:</strong>
                                <p>Інтерпретація виключає виконання вихідного коду програми покроково, рядок за рядком, за допомогою
                                    віртуальної машини або інтерпретатора.</p>
                            </li>
                            <li>
                                <strong>Використання:</strong>
                                <p>Вихідний код програми залишається в текстовому форматі і інтерпретується за потреби. Програма виконується
                                    без створення окремого виконуваного файлу.</p>
                            </li>
                        </ul>
                    </li>
                </ol>
                <h6>Різниця:</h6>
                <ul>
                    <li>Компіляція вимагає попередньої обробки вихідного коду та створення виконуваного файлу перед його запуском.</li>
                    <li>Інтерпретація виконується покроково під час виконання програми без попередньої генерації окремого виконуваного
                        файлу.
                    </li>
                </ul>
                <p>Обидва підходи мають свої переваги та недоліки, і вибір між ними залежить від конкретних потреб та характеристик
                    системи.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>
                Компіляція vs Транспіляція vs Інтерпретація (в контексті JS & TypeScript)
            </div>
            <div class="collapsible-body">
                <p>Компіляція та транспіляція - це два процеси перетворення вихідного коду з одного рівня абстракції на інший. Ось їх
                    визначення та різниця:</p>
                <ol>
                    <li>
                        <b>Компіляція</b>
                        <ul>
                            <li>Компіляція - це процес перетворення вихідного коду програми (зазвичай у високорівневій мові програмування) у
                                машинний код або виконавчий код, який може бути безпосередньо виконаний процесором комп'ютера.
                            </li>
                            <li>У компіляції вихідний код програми повністю перетворюється у виконуваний файл перед його запуском.</li>
                            <li>Приклади мов програмування, що компілюються, включають C, C++, Java.</li>
                        </ul>
                    </li>
                    <li>
                        <b>Транспіляція</b>
                        <ul>
                            <li>Транспіляція - це процес перетворення вихідного коду з однієї мови програмування на вихідний код іншої мови
                                програмування на тому ж або на іншому рівні абстракції.
                            </li>
                            <li>У транспіляції вихідний код програми перетворюється в код іншої мови програмування, але цей код не
                                обов'язково є машинним кодом, і його зазвичай потрібно додатково компілювати або інтерпретувати.
                            </li>
                            <li>Приклади транспіляторів включають TypeScript (транспілюється в JavaScript), CoffeeScript (транспілюється в
                                JavaScript).
                            </li>
                        </ul>
                    </li>
                    <li>
                        <b>Інтерпретація</b>
                        <ul>
                            <li>Інтерпретація - це процес виконання вихідного коду програми безпосередньо під час виконання програми.</li>
                            <li>У випадку інтерпретації вихідний код програми виконується по одній інструкції за раз, без попереднього
                                перетворення у машинний код.
                            </li>
                            <li>Приклади мов програмування, які інтерпретуються, включають JavaScript (в браузерах або на серверах за
                                допомогою Node.js), Python, Ruby.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Отже, основна відмінність між компіляцією, транспіляцією та інтерпретацією полягає в тому, як виконується вихідний код
                    програми: чи перетворюється він у машинний код перед виконанням (компіляція), чи перетворюється у вихідний код іншої
                    мови програмування (транспіляція), чи виконується безпосередньо під час виконання програми (інтерпретація).</p>
                <ol>
                    <li>
                        <b>JavaScript</b>
                        <ul>
                            <li>JavaScript може бути компільований в машинний код або інший виконуваний код за допомогою спеціалізованих
                                технологій, таких як V8 Engine, що використовується в браузерах або Node.js.
                            </li>
                            <li>JavaScript також може бути транспільований в інші мови програмування за допомогою інструментів транспіляції,
                                таких як Babel, для підтримки сучасних функцій мови в старіших браузерах або для перетворення в код іншої
                                мови програмування.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <b>TypeScript</b>
                        <ul>
                            <li>TypeScript є суперсетом JavaScript, тому весь дійсний JavaScript код є також валідним кодом TypeScript.</li>
                            <li>TypeScript код може бути транспільований в JavaScript, що дозволяє розробникам використовувати функціональні
                                можливості TypeScript у проектах, які виконуються в середовищах, які підтримують тільки JavaScript.
                            </li>
                            <li>Транспіляція TypeScript в JavaScript може бути здійснена за допомогою компілятора TypeScript або за
                                допомогою інших інструментів, таких як Babel, який також підтримує TypeScript.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Отже, як JavaScript, так і TypeScript можуть бути компільовані, транспільовані та інтерпретовані залежно від контексту їх
                    використання та вимог проекту. Обидва можуть використовуватися у веб-розробці, але TypeScript, як суперсет JavaScript,
                    дозволяє розробникам використовувати типізацію та інші додаткові можливості, які полегшують розробку великих та складних
                    програм.</p>
            </div>
        </li>

        <li>
            <div class="collapsible-header"><i class="material-icons">whatshot</i>

            </div>
            <div class="collapsible-body">

            </div>
        </li>
    </ul>

    <h5 id="testing">Testing</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які основні види тестування ви знаєте?
            </div>
            <div class="collapsible-body">
                <p>
                    Існує кілька основних видів тестування, які можуть бути корисні для розробника фронтенду, зокрема для проектів на
                    JavaScript та React.js:</p>
                <ol>
                    <li>
                        <strong>Модульне тестування (Unit Testing):</strong>
                        <p>Тестування окремих модулів (функцій, компонентів) для перевірки їх коректності.</p>
                    </li>
                    <li>
                        <strong>Інтеграційне тестування (Integration Testing):</strong>
                        <p>Перевірка взаємодії між різними частинами системи, такими як компоненти або модулі.</p>
                    </li>
                    <li>
                        <strong>End-to-End Testing, E2E Testing:</strong>
                        <p>Це вид тестування, який спрямований на перевірку повного функціоналу додатку в реальних умовах перед випуском
                            виробу. Основна ідея полягає в тому, щоб перевірити взаємодію всіх компонентів системи від початкового до
                            кінцевого етапу роботи.</p>
                        <ul>
                            <li>
                                <strong>Покриття весь додаток</strong>
                                <p> Енд-ту-енд тестування охоплює всю архітектуру додатку, перевіряючи його функціональність в реальних
                                    умовах.</p>
                            </li>
                            <li>
                                <strong>Реалістичне моделювання взаємодії користувача:</strong>
                                <p> Тестування виконується так, ніби це робить реальний користувач, і включає в себе всі етапи взаємодії з
                                    додатком.</p>
                            </li>
                            <li>
                                <strong>Імітація реального середовища:</strong>
                                <p>Тестування може проводитися в середовищі, яке якомога більше нагадує реальні умови виробництва.</p>
                            </li>
                            <li>
                                <strong>Виявлення комплексних проблем: </strong>
                                <p>Енд-ту-енд тестування може допомогти виявити проблеми, які можуть виникнути через взаємодію різних
                                    компонентів додатку.</p>
                            </li>
                            <li>
                                <strong>Перевірка інтеграції зовнішніх служб: </strong>
                                <p>Тестування може включати перевірку інтеграції з зовнішніми службами та API.</p>
                            </li>
                        </ul>
                        <p>У контексті фронтенд розробки з JavaScript та React.js, енд-ту-енд тестування може включати в себе автоматизовані
                            тести для взаємодії з інтерфейсом користувача, перевірки функціональності React-компонентів та їх інтеграції в
                            рамках всього додатку. Такі тести допомагають впевнитися, що весь фронтенд працює як очікується в реальних
                            умовах використання.</p>
                    </li>
                    <li>
                        <strong>Функціональне тестування (Functional Testing):</strong>
                        <p>Перевірка функціональності програми або компоненту, щоб забезпечити відповідність вимогам.</p>
                    </li>
                    <li>
                        <strong>Тестування візуального вигляду (UI Testing):</strong>
                        <p>Перевірка коректності та візуального вигляду інтерфейсу користувача.</p>
                    </li>
                    <li>
                        <strong>Тестування продуктивності (Performance Testing):</strong>
                        <p>Визначення ефективності та швидкодії програми або компонента при різних навантаженнях.</p>
                    </li>
                    <li>
                        <strong>Тестування безпеки (Security Testing):</strong>
                        <p>Виявлення та усунення можливих вразливостей у програмному забезпеченні.</p>
                    </li>
                    <li>
                        <strong>Тестування користувацького досвіду (Usability Testing):</strong>
                        <p>Оцінка того, наскільки легко користувачі можуть взаємодіяти з продуктом.</p>
                    </li>
                    <li>
                        <strong>Тестування сумісності (Compatibility Testing):</strong>
                        <p>Впевнення, що програмне забезпечення працює на різних платформах та пристроях.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як відрізнити "якісне тестування" від "кількісного тестування"?
            </div>
            <div class="collapsible-body">
                <p>"Якісне тестування" та "кількісне тестування" - це два різних підходи до процесу тестування програмного забезпечення, які
                    акцентують увагу на різних аспектах якості продукту. Ось основні відмінності між ними:</p>
                <ol>
                    <li>
                        <strong>Основний фокус:</strong>
                        <ul>
                            <li>
                                <strong>Якісне тестування: </strong>
                                <p>Основний акцент робиться на якості продукту, його коректності та відповідності вимогам.</p>
                            </li>
                            <li>
                                <strong>Кількісне тестування:</strong>
                                <p>Основний фокус знаходиться на кількості тестів, покритті коду, швидкості виконання тестів та інших
                                    кількісних метриках.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мета:</strong>
                        <ul>
                            <li>
                                <strong>Якісне тестування: </strong>
                                <p>Оцінка та забезпечення високої якості програмного забезпечення, виявлення помилок та проблем в роботі
                                    системи.</p>
                            </li>
                            <li>
                                <strong>Кількісне тестування:</strong>
                                <p>Забезпечення великої кількості тестів для охоплення різних аспектів програмного забезпечення та
                                    збільшення кількості тестових випадків.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Методи тестування:</strong>
                        <ul>
                            <li>
                                <strong>Якісне тестування: </strong>
                                <p>Зазвичай включає в себе ручне тестування, автоматизовані тести для перевірки функціональності та
                                    відповідності вимогам.</p>
                            </li>
                            <li>
                                <strong>Кількісне тестування:</strong>
                                <p>Зазвичай включає в себе автоматизовані тести для швидкого виконання та генерації кількісних метрик, таких
                                    як покриття коду, час виконання тестів тощо.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Метрики якості:</strong>
                        <ul>
                            <li>
                                <strong>Якісне тестування: </strong>
                                <p>Метрики якості можуть включати кількість виявлених дефектів, стабільність системи та коректність
                                    роботи.</p>
                            </li>
                            <li>
                                <strong>Кількісне тестування:</strong>
                                <p>Метрики можуть включати покриття коду тестами, кількість тестів, їх тривалість виконання та інші
                                    кількісні параметри.</p>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Обидва підходи є важливими для забезпечення якості програмного забезпечення. Вибір між якісним та кількісним тестуванням
                    залежить від конкретних потреб та вимог вашого проекту.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке регресійне тестування?
            </div>
            <div class="collapsible-body">
                <p>
                    Регресійне тестування - це вид тестування, який використовується для перевірки того, чи виникли нові помилки чи проблеми
                    в програмному забезпеченні після внесення змін чи оновлень. Основна мета регресійного тестування - впевнитися, що новий
                    код або внесені зміни не вплинули на наявний функціонал та не викликали нових дефектів у вже протестованій частині
                    програми.</p>
                <p>Основні принципи регресійного тестування:</p>
                <ol>
                    <li>
                        <strong>Стабільність функціоналу</strong>
                        <p>Зміни в коді або додавання нового функціоналу не повинні впливати на стабільність наявного функціоналу.</p>
                    </li>
                    <li>
                        <strong>Виявлення нових помилок:</strong>
                        <p>Регресійне тестування допомагає виявити можливі помилки, які можуть виникнути в результаті змін в програмі.</p>
                    </li>
                    <li>
                        <strong>Впевненість у якості:</strong>
                        <p>Забезпечення впевненості у тому, що програмне забезпечення залишається якісним після кожної зміни.</p>
                    </li>
                </ol>
                <p>Процес регресійного тестування може включати в себе автоматизовані тести, які охоплюють ключові функціональність та
                    сценарії взаємодії, а також ручні перевірки для більш глибокого аналізу.</p>
                <p>Зміни, які можуть викликати несправжність у вже існуючому функціоналі, включають оновлення коду, зміни в базі даних,
                    виправлення помилок, додавання нового функціоналу чи інші модифікації коду. Регресійне тестування є важливою складовою
                    частиною розробки програмного забезпечення для забезпечення стабільності та надійності продукту</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як ви визначаєте та розрізняєте "чорний ящик" і "білий ящик" тестування?
            </div>
            <div class="collapsible-body">
                <p>"Чорний ящик" та "білий ящик" - це два різних підходи до тестування програмного забезпечення, які визначаються рівнем
                    доступу до внутрішньої структури коду.</p>
                <ol>
                    <li>
                        <strong>Чорний ящик (Black Box Testing):</strong>
                        <ul>
                            <li>
                                <strong>Визначення:</strong>
                                <p>Чорний ящиковий підхід означає тестування без знання внутрішньої структури чи реалізації програми.</p>
                            </li>
                            <li>
                                <strong>Підхід:</strong>
                                <p>Тестувальник розглядає програмне забезпечення як чорний ящик, де він аналізує лише вхідні та вихідні дані
                                    без знання того, як програма обробляє дані в середині.</p>
                            </li>
                            <li>
                                <strong>Мета:</strong>
                                <p>Виявлення помилок та оцінка функціональності продукту.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Білий ящик (White Box Testing):</strong>
                        <ul>
                            <li>
                                <strong>Визначення:</strong>
                                <p>Білий ящиковий підхід передбачає знання внутрішньої структури коду та алгоритмів програми.</p>
                            </li>
                            <li>
                                <strong>Підхід:</strong>
                                <p>Тестувальник має доступ до вихідного коду та може створювати тести на основі структури програми. Включає
                                    аналіз логіки, гілок, путей коду тощо.</p>
                            </li>
                            <li>
                                <strong>Мета:</strong>
                                <p>Перевірка логіки програми, виявлення помилок у внутрішньому коді, оптимізація та покриття всіх гілок
                                    коду.</p>
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Обидва підходи мають свої переваги та недоліки, і їх використання залежить від конкретних потреб та вимог проекту. Чорний
                    ящиковий тестування ефективне для зовнішнього вивчення функціональності, тоді як білий ящиковий тестування дозволяє
                    більш детально досліджувати внутрішню роботу програми. Зазвичай команди тестувальників використовують обидва підходи,
                    щоб забезпечити повноту та ефективність тестування.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Can you explain the role of smoke testing in the software development lifecycle?
            </div>
            <div class="collapsible-body">
                <p>Смоук-тестування відіграє важливу роль у процесі розробки програмного забезпечення, діючи як перевірка початкової якості,
                    щоб переконатися, що основні функції програмного застосунку працюють так, як передбачено. Це виконується для перевірки
                    стабільності та основної функціональності програми перед більш ретельним тестуванням та, в кінці кінців, перед випуском
                    продукту. Роботодавці можуть ставити це питання, щоб оцінити ваше розуміння цього базового концепту тестування та вашу
                    здатність забезпечити готовність продукту до більш ретельного тестування та випуску для кінцевих користувачів. Вони
                    хочуть знати, чи ви можете визначити та вирішувати критичні проблеми на ранніх етапах циклу розробки, що економить час,
                    зусилля та ресурси.</p>
                <p>Основна мета смоук-тестування - швидко виявити будь-які дефекти, які можуть перешкоджати подальшому ретельному
                    тестуванню. Це дозволяє розробникам вирішити ці проблеми високого пріоритету на ранніх етапах, економлячи час та
                    ресурси, уникнувши обширного тестування на непрацюючій будівлі. З суті, смоук-тестування виступає як воротар якості,
                    оптимізуючи процес тестування та сприяючи загальній ефективності життєвого циклу розробки програмного забезпечення."</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Can you explain the difference between functional testing and non-functional testing?
            </div>
            <div class="collapsible-body">
                <p>Функціональне тестування спрямоване на перевірку того, чи працює програмне забезпечення так, як це передбачено відповідно
                    до його специфікацій. Воно включає оцінку функцій та можливостей системи, таких як інтерфейс користувача, API, взаємодія
                    з базою даних та інтеграція з іншими компонентами. Основною метою функціонального тестування є забезпечення того, що
                    програмне забезпечення відповідає вимогам, визначеним у документах проекту, та влаштовує потреби кінцевих
                    користувачів.</p>
                <p>З іншого боку, нефункціональне тестування оцінює аспекти програмного забезпечення, які не прямо пов'язані з конкретними
                    функціями чи можливостями, але стосуються загальної якості та продуктивності системи. Сюди входять такі області, як
                    зручність використання, надійність, масштабованість, безпека та час реакції. Нефункціональне тестування спрямоване на
                    оцінку того, наскільки добре програмне забезпечення впорається з різними умовами, навантаженнями та середовищами,
                    забезпечуючи оптимальний досвід користувача та зберігаючи стабільність при стресових ситуаціях.</p>
                <p>Обидва типи тестування є важливими для надання високоякісного продукту, оскільки вони враховують різні аспекти
                    програмного забезпечення та сприяють його загальному успіху.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What is risk-based testing, and how do you apply it in your testing process?
            </div>
            <div class="collapsible-body">
                <p>"Ризик-орієнтоване тестування - це підхід, який визначає пріоритет тестових випадків на основі можливих ризиків і впливу
                    дефектів у програмному застосунку. Основна мета - зосередитися на областях з вищим ризиком, забезпечуючи те, що критичні
                    функції будуть ретельно протестовані, при цьому оптимізуючи час і ресурси.</p>
                <p>Для використання ризик-орієнтованого тестування я розпочинаю співпрацю з командою розробників, менеджерами проекту та
                    іншими зацікавленими сторонами для визначення та аналізу можливих ризиків, пов'язаних з кожною функцією чи можливістю.
                    Ми оцінюємо ймовірність виникнення і серйозність впливу в разі виявлення дефекту. На основі цього аналізу призначається
                    рівень пріоритету ризику для кожного компонента.</p>
                <p>Після визначення пріоритетів я розробляю тестовий план, який розподіляє більше часу та ресурсів на компоненти з високим
                    рівнем ризику, забезпечуючи їм ретельне тестування. Цей підхід допомагає виявляти та вирішувати критичні проблеми на
                    ранніх етапах розробки, зменшуючи загальний ризик проекту та підвищуючи якість кінцевого продукту."</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Can you explain the concept of test-driven development (TDD)?
            </div>
            <div class="collapsible-body">
                <p>Розуміння різних методологій розробки є ключовим для інженера з тестування програмного забезпечення. Розробка через
                    тестування (Test-driven development, TDD) - це популярний підхід, який наголошує на написанні тестів перед написанням
                    фактичного коду для того, щоб забезпечити, що програмне забезпечення будується для відповідності своїм вимогам. </p>
                <p>Розробка через тестування (TDD) - це методологія розробки програмного забезпечення, яка підкреслює написання тестів перед
                    написанням фактичного коду. Процес розпочинається створенням набору тестових випадків для конкретної функціональності,
                    які спочатку вказують на невдалі результати, оскільки ще немає реалізації. Потім розробник пише мінімальну кількість
                    коду, необхідного для проходження цих тестів.</p>
                <p>Коли тести проходять, розробник може рефакторити та оптимізувати код, впевнюючись в його правильності за допомогою
                    постійного запуску тестів. Цей цикл написання тестів, виконання коду та рефакторингу сприяє створенню чистого,
                    ефективного та надійного коду. TDD допомагає виявляти проблеми на ранніх етапах розробки, що робить його легше зберігати
                    та змінювати в подальшому."</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                TDD vs BDD vs DDD
            </div>
            <div class="collapsible-body">
                <p>Розробка програмного забезпечення пройшла довгий шлях, і сьогодні у нас є кілька підходів, які розробники можуть
                    використовувати для створення високоякісного програмного забезпечення. Розробка через тестування (Test-Driven
                    Development, TDD), Розробка, орієнтована на поведінку (Behavior-Driven Development, BDD) і Дизайн, орієнтований на домен
                    (Domain-Driven Design, DDD) - це деякі з найпопулярніших підходів до розробки програмного забезпечення. Ці підходи
                    допомагають розробникам створювати програмне забезпечення, яке відповідає потребам клієнта і має високу якість.</p>

                <ul>
                    <li>
                        <strong>TDD (Розробка через тестування, Test-Driven Development)</strong>
                        <p>TDD - це гнучкий процес розробки програмного забезпечення, де розробники пишуть автоматизовані тести перед
                            написанням коду. Ідея за TDD полягає в тому, що якщо ви пишете тести спочатку, ви матимете краще розуміння того,
                            як повинен працювати код. Тести діють як специфікація для коду. TDD забезпечує те, що код є тестовим,
                            підтримується та розширюється. Ось етапи, що включаються в TDD:</p>
                        <ol>
                            <li>Написати тест, який не проходить.</li>
                            <li>Написати код, який робить тест успішним.</li>
                            <li>Рефакторити код для покращення його якості.</li>
                        </ol>
                    </li>
                    <li>
                        <strong>BDD (Розробка, орієнтована на поведінку, Behavior-Driven Development)</strong>
                        <p>BDD - це процес розробки програмного забезпечення, який фокусується на поведінці програмного забезпечення. BDD є
                            розширенням TDD, де тести пишуться більш природною мовою, яку можуть розуміти стейкхолдери. BDD забезпечує те,
                            що програмне забезпечення розробляється на основі потреб та поведінки користувача. Ось етапи, що включаються в
                            BDD:</p>
                        <ol>
                            <li>Визначити поведінку програмного забезпечення.</li>
                            <li>Написати тести, які описують цю поведінку.</li>
                            <li>Написати код для того, щоб тести пройшли успішно.</li>
                            <li>Рефакторити код для покращення його якості.</li>
                        </ol>
                    </li>
                    <li>
                        <strong>DDD (Дизайн, орієнтований на домен, Domain-Driven Design)</strong>
                        <p>DDD - це підхід до розробки програмного забезпечення, який акцентується на домені програмного забезпечення. Домен
                            - це простір проблем, який програмне забезпечення призначено вирішувати. DDD забезпечує те, що програмне
                            забезпечення будується навколо домену і вирішує проблему найкращим можливим способом. Ось етапи, що включаються
                            в DDD:</p>
                        <ol>
                            <li>Розуміти домен програмного забезпечення.</li>
                            <li>Визначити модель домену.</li>
                            <li>Реалізувати модель домену у коді.</li>
                            <li>Постійно вдосконалювати модель домену.</li>
                        </ol>
                    </li>
                </ul>
                <h6>Різниця між TDD, BDD та DDD: Основні відмінності</h6>
                <ul>
                    <li>
                        <strong>Фокус:</strong>
                        <ul>
                            <li>TDD фокусується на тестуванні коду.</li>
                            <li>BDD фокусується на поведінці програмного забезпечення.</li>
                            <li>DDD фокусується на домені програмного забезпечення.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Мова:</strong>
                        <ul>
                            <li>TDD використовує тести на основі коду.</li>
                            <li>BDD використовує тести на природній мові.</li>
                            <li>DDD використовує мову, специфічну для домену.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Процес:</strong>
                        <ul>
                            <li>TDD - це трьохетапний процес.</li>
                            <li>BDD - це чотирьохетапний процес.</li>
                            <li>DDD - це постійний процес.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Учасники:</strong>
                        <ul>
                            <li>TDD та BDD залучають розробників та тестувальників.</li>
                            <li>DDD залучає експертів у галузі та розробників.</li>
                        </ul>
                    </li>
                </ul>
                <h6>Переваги TDD, BDD та DDD:</h6>
                <h6>Коли використовувати TDD, BDD та DDD:</h6>
                <ul>
                    <li>Використовуйте TDD, коли ви хочете забезпечити, що ваш код є тестовим, підтримується та розширюється.</li>
                    <li>Використовуйте BDD, якщо ви хочете забезпечити, що ваше програмне забезпечення розробляється на основі потреб та
                        поведінки користувача.
                    </li>
                    <li>Використовуйте DDD, якщо ви хочете забезпечити, що ваше програмне забезпечення вирішує проблему найкращим можливим
                        способом.
                    </li>
                </ul>
                <p>
                    В заключенні можна сказати, що TDD, BDD і DDD - це популярні підходи до розробки програмного забезпечення, кожен з яких
                    має свої переваги та недоліки. TDD зосереджується на тестуванні коду, BDD - на поведінці програмного забезпечення, а DDD
                    - на області застосування програми. Кожен підхід має свої переваги і підходить для різних ситуацій. Вибір вірного
                    підходу залежить від ваших потреб і цілей. Незалежно від обраного підходу важливо використовувати його систематично та
                    постійно вдосконалювати свій процес розробки програмного забезпечення.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                What are some of the testing best practices?
            </div>
            <div class="collapsible-body">
                <p>Тестування є важливою частиною розробки програмного забезпечення, і дотримання найкращих практик може допомогти
                    забезпечити якість та надійність вашого коду. </p>
                <ol>
                    <li>
                        <strong>Написання модульних тестів:</strong>
                        <p>Створюйте невеликі, спрямовані тести для окремих функцій чи компонентів, використовуйте бібліотеки/фреймворки
                            для тестування, такі як Jest та ін.</p>
                    </li>
                    <li>
                        <strong>Розробка через тести (Test Driven Development, TDD):</strong>
                        <p>Розглядайте можливість впровадження TDD, писання тестів перед написанням фактичного коду. Це допомагає визначити
                            вимоги та поліпшити дизайн.</p>
                    </li>
                    <li>
                        <strong>Автоматизація:</strong>
                        <p>Автоматизуйте свої тести, щоб вони виконувалися як частина постійної інтеграції (CI). Це гарантує, що тести
                            виконуються з кожним зміненим кодом.</p>
                    </li>
                    <li>
                        <strong>Ізоляція тестів:</strong>
                        <p>Переконайтеся, що тести незалежні і не залежать від стану інших тестів. Це запобігає каскадним неполадкам і
                            полегшує відлагодження.</p>
                    </li>
                    <li>
                        <strong>Мокування та заміщення:</strong>
                        <p>Використовуйте мокування та заміщення для ізоляції коду, який тестується, від зовнішніх залежностей. Це допомагає
                            тестувати компоненти в ізоляції.</p>
                    </li>
                    <li>
                        <strong>Аналіз покриття:</strong>
                        <p>Спостерігайте за покриттям тестами, щоб переконатися, що значна частина вашого коду покрита тестами. Інструменти,
                            такі як Istanbul, допомагають у генерації звітів з покриття.</p>
                    </li>
                    <li>
                        <strong>Тестування продуктивності:</strong>
                        <p>Включайте тестування продуктивності для виявлення та вирішення будь-яких bottleneck або проблем, пов'язаних із
                            швидкістю та реакцією вашого застосунку.</p>
                    </li>
                    <li>
                        <strong>Тестування на різних браузерах та пристроях:</strong>
                        <p>Тестуйте свій застосунок на різних браузерах та пристроях, щоб забезпечити консистентний користувацький досвід у
                            різних середовищах.</p>
                    </li>
                    <li>
                        <strong>Постійний зворотний зв'язок:</strong>
                        <p>Використовуйте інструменти, які надають постійний зворотний зв'язок щодо якості коду, такі як лінтери та
                            інструменти статичного аналізу коду.</p>
                    </li>
                    <li>
                        <strong>Регресійне тестування:</strong>
                        <p>Регулярно запускайте регресійні тести, щоб переконатися, що всі функції залишаються працездатними після внесення
                            змін.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Test coverage vs Code coverage
            </div>
            <div class="collapsible-body">
                <p>
                    "Тестове охоплення" та "Покриття коду" - це терміни, які часто використовуються в контексті тестування програмного
                    забезпечення, але вони мають трохи відмінний сенс.</p>
                <ol>
                    <li>
                        <strong>Тестове охоплення (Test Coverage):</strong>
                        <ul>
                            <li>Означення: Тестове охоплення вказує на те, які частини програми або системи були випробувані за допомогою
                                тестів у порівнянні з загальною кількістю частин програми.
                            </li>
                            <li>Сенс: Це вимірює, як добре ваші тести охоплюють функціональність вашого коду. Виражається у відсотках та
                                показує, скільки частин коду було перевірено тестами.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Покриття коду (Code Coverage):</strong>
                        <ul>
                            <li>Означення: Покриття коду вказує на те, яка частина фактичного програмного коду була використана або
                                викликана під час виконання тестів.
                            </li>
                            <li>Сенс: Це вимірює, як часто викликаються різні рядки або блоки коду під час виконання тестів. Це може
                                допомогти виявити "мертвий код" або частини коду, які не використовуються.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Отже, тестове охоплення вказує, як багато функціонального коду ви перевірили тестами, тоді як покриття коду показує, яка
                    частина самого коду викликалася в процесі тестування. Обидва ці аспекти важливі для забезпечення якості вашого
                    програмного забезпечення, і їх використання допомагає виявляти та виправляти помилки та недоліки.</p>
            </div>
        </li>
    </ul>

    <h5 id="graphql">GraphQL</h5>
    <ul class="collapsible">
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Що таке GraphQL і як він відрізняється від традиційних API?
            </div>
            <div class="collapsible-body">
                <p><strong>GraphQL</strong> - це мова запитів для вашого API, яка дозволяє вам вказувати тільки ті дані, які вам
                    потрібні, і отримувати їх у одному запиті. Він відрізняється від традиційних API, особливо REST, в кількох
                    аспектах:</p>
                <ol>
                    <li>
                        <strong>Гнучкість у визначенні даних:</strong>
                        <p>У GraphQL ви самі визначаєте, які дані ви хочете отримати, і можете зазначити це у вашому запиті. Замість того,
                            щоб отримувати фіксований набір даних, як у REST, ви отримуєте саме те, що вам потрібно.</p>
                    </li>
                    <li>
                        <strong>Один запит для багатьох даних:</strong>
                        <p>GraphQL дозволяє вам отримати різні дані у одному запиті, що дозволяє ефективно збирати різні ресурси без
                            декількох окремих запитів.</p>
                    </li>
                    <li>
                        <strong>Надлишкова або недостатня інформація:</strong>
                        <p>У GraphQL немає надлишковості або недостатньої інформації. Ви отримуєте саме той обсяг даних, який вам потрібен,
                            і нічого більше.</p>
                    </li>
                    <li>
                        <strong>Динамічність:</strong>
                        <p>GraphQL дозволяє динамічно визначати структуру даних у вашому запиті, що особливо корисно для фронтенд
                            розробників, оскільки вони можуть легко пристосовувати запити до потреб їхніх компонентів.</p>
                    </li>
                    <li>
                        <strong>Автодокументація:</strong>
                        <p>GraphQL API надає автодокументацію, що дозволяє розробникам швидко отримувати інформацію про доступні дані та
                            їхні типи без вивчення документації.</p>
                    </li>
                </ol>
                <p>Загалом, GraphQL надає більше гнучкості та контролю над тим, які дані ви отримуєте, що може бути особливо корисним для
                    фронтенд розробників.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які основні типи запитів у GraphQL?
            </div>
            <div class="collapsible-body">
                <p> У GraphQL існують три основні типи запитів: запити на отримання даних (queries), мутації (mutations) для модифікації
                    даних та Subscription (Використовується для отримання реального часу оновлень.). Давайте розглянемо кожен з цих типів
                    більш детально:</p>
                <ol>
                    <li>
                        <strong>Запити на отримання даних (Queries):</strong>
                        <ul>
                            <li>Запити використовуються для читання даних з сервера.</li>
                            <li>Вони подібні до GET-запитів у REST, але визначаються клієнтом, щоб точно вказати, які дані він хоче
                                отримати.
                            </li>
                            <li>Запити можуть включати вкладені дані, визначати потрібні поля та їх типи.</li>
                        </ul>
                        <p>Приклад запиту на отримання даних у GraphQL:</p>
                        <pre>
                            query {
                              user(id: 123) {
                                name
                                email
                                posts {
                                  title
                                  content
                                }
                              }
                            }
                        </pre>
                    </li>
                    <li>
                        <strong>Мутації (Mutations):</strong>
                        <ul>
                            <li>Мутації використовуються для зміни або модифікації даних на сервері.</li>
                            <li>Вони подібні до POST, PUT, PATCH, DELETE-запитів у REST, але використовуються для виконання змін на
                                сервері.
                            </li>
                        </ul>
                        <p>Приклад мутації у GraphQL:</p>
                        <pre>
                            mutation {
                              createUser(input: { name: "John Doe", email: "john@example.com" }) {
                                id
                                name
                                email
                              }
                            }
                        </pre>
                        <p>Цей приклад мутації створює нового користувача з іменем "John Doe" та електронною поштою "john@example.com" і
                            повертає його ідентифікатор, ім'я та електронну пошту.</p>
                    </li>
                    <li>
                        <strong>Subscription:</strong>
                        <p>Subscription - це третій основний тип запитів у GraphQL, і він використовується для отримання поточних або
                            стрімингових оновлень з сервера. Запити типу Subscription дозволяють клієнту підписатися на події та отримувати
                            автоматичні оновлення, коли дані змінюються на сервері. Це особливо корисно для реалізації функцій живого
                            оновлення (live updates) в реальному часі.</p>
                        <p>Основні характеристики Subscriptions:</p>
                        <ul>
                            <li>
                                <strong>Підписка на події:</strong>
                                <p>Клієнт може підписатися на певну подію або тип подій, які відбуваються на сервері.</p>
                            </li>
                            <li>
                                <strong>Автоматичні оновлення:</strong>
                                <p>Коли стан даних на сервері змінюється внаслідок якої-небудь дії, всі підписані клієнти автоматично
                                    отримують оновлення.</p>
                            </li>
                            <li>
                                <strong>WebSocket або інші протоколи:</strong>
                                <p>Для реалізації Subscriptions використовуються спеціальні протоколи, такі як WebSocket, щоб підтримувати
                                    двосторонній обмін даними між клієнтом і сервером.</p>
                            </li>
                        </ul>
                        <p>Приклад Subscription-запиту у GraphQL:</p>
                        <pre>
                            subscription {
                              newPost {
                                title
                                content
                                author {
                                  name
                                }
                              }
                            }
                        </pre>
                        <p>Цей приклад демонструє підписку на подію newPost, і кожного разу, коли на сервері додається новий пост, клієнт
                            отримає автоматичне оновлення з даними про цей пост.</p>
                        <p>Отже, Subscriptions у GraphQL використовуються для побудови реактивних інтерфейсів, де клієнти отримують
                            оновлення в реальному часі при зміні даних на сервері.</p>
                    </li>
                </ol>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які переваги використання GraphQL для взаємодії із сервером?
            </div>
            <div class="collapsible-body">
                <p>Використання GraphQL для взаємодії із сервером має кілька значущих переваг, особливо для фронтенд розробників. Ось деякі
                    з основних переваг:</p>
                <ol>
                    <li>
                        <strong>Гнучкість запитів:</strong>
                        <p>Клієнт може точно вказати, які дані йому потрібні, і отримати їх у одному запиті. Це уникне проблеми
                            надлишковості або недостатньої інформації в отриманих даних.</p>
                    </li>
                    <li>
                        <strong>Ефективність мережевого трафіку:</strong>
                        <p>Запити GraphQL дозволяють отримати всі необхідні дані у одному запиті, що може значно зменшити обсяг мережевого
                            трафіку порівняно з декількома REST-запитами.</p>
                    </li>
                    <li>
                        <strong>Автодокументація:</strong>
                        <p>GraphQL API надає автодокументацію, яка дозволяє розробникам швидко отримати інформацію про доступні дані та їхні
                            типи без необхідності вивчення зовнішньої документації.</p>
                    </li>
                    <li>
                        <strong>Динамічність:</strong>
                        <p>Можливість динамічно визначати структуру даних у запиті дозволяє розробникам легко адаптувати запити до вимог
                            їхніх компонентів і інтерфейсів.</p>
                    </li>
                    <li>
                        <strong>Підтримка реального часу:</strong>
                        <p>З використанням Subscriptions, GraphQL дозволяє реалізувати функціональність реального часу, надсилаючи
                            автоматичні оновлення клієнтам при зміні даних на сервері.</p>
                    </li>
                    <li>
                        <strong>Мінімізація "over-fetching" та "under-fetching":</strong>
                        <p>GraphQL дозволяє уникнути проблеми "over-fetching" (завантаження зайвих даних) та "under-fetching" (недостатньо
                            завантажених даних), оскільки клієнт самостійно контролює обсяг і структуру отримуваних даних.</p>
                    </li>
                    <li>
                        <strong>Зручний розробка та тестування:</strong>
                        <p>GraphQL спрощує розробку та тестування, оскільки розробники можуть працювати з чітко визначеними схемами та
                            типами даних.</p>
                    </li>
                </ol>
                <p>Загалом, використання GraphQL сприяє більшій ефективності, гнучкості та ефективному управлінню даними між клієнтом і
                    сервером.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які сутності (types) і фільтри можна використовувати в GraphQL?
            </div>
            <div class="collapsible-body">
                <p>
                    В GraphQL існують різні види сутностей (types) та фільтрів, які можна використовувати для визначення структури даних та
                    обмеження результатів запитів. Основні типи включають Scalar Types, Object Types, List Types, та фільтри для запитів та
                    мутацій. Давайте розглянемо їх більш детально:</p>
                <ol>
                    <li>
                        <strong>Scalar Types (Скалярні типи):</strong>
                        <p>Це базові типи даних, які представляють прості значення. Деякі з них включають Int, Float, String, Boolean та
                            ID.</p>
                    </li>
                    <li>
                        <strong>Object Types (Об'єктні типи):</strong>
                        <p>Ці типи використовуються для визначення складних об'єктів, які можуть містити поля з іншими скалярними або
                            об'єктними типами.</p>
                        <pre>
                            type User {
                              id: ID!
                              name: String!
                              age: Int
                              email: String!
                            }

                        </pre>
                    </li>
                    <li>
                        <strong>List Types (Типи списків):</strong>
                        <p>Використовуються для представлення списків об'єктів або скалярних значень.</p>
                        <pre>
                            type Post {
                              id: ID!
                              title: String!
                              tags: [String!]!
                            }

                        </pre>
                    </li>
                    <li>
                        <strong>Enums (Перерахування):</strong>
                        <p>Визначають фіксований набір значень.</p>
                        <pre>
                            enum UserRole {
                              ADMIN
                              USER
                              EDITOR
                            }

                        </pre>
                    </li>
                    <li>
                        <strong>Interfaces (Інтерфейси):</strong>
                        <p>Визначають спільні поля для об'єктних типів.</p>
                        <pre>
                            interface NamedEntity {
                              name: String!
                            }

                            type User implements NamedEntity {
                              id: ID!
                              name: String!
                              email: String!
                            }

                            type Product implements NamedEntity {
                              id: ID!
                              name: String!
                              price: Float!
                            }

                        </pre>
                    </li>
                    <li>
                        <strong>Unions (Об'єднання):</strong>
                        <p>Дозволяють представити результати з декількох типів.</p>
                        <pre>union SearchResult = User | Product | Post</pre>
                    </li>
                    <li>
                        <strong>Input Types (Типи введення):</strong>
                        <p>Використовуються для передачі аргументів до мутацій та запитів.</p>
                        <pre>
                            input CreateUserInput {
                              name: String!
                              email: String!
                              password: String!
                            }

                        </pre>
                    </li>
                    <li>
                        <strong>Аргументи та фільтри:</strong>
                        <p>Дозволяють передавати параметри до запитів та мутацій, а також фільтрувати результати.</p>
                        <pre>
                            type Query {
                              users(limit: Int, offset: Int): [User!]!
                            }
                        </pre>
                        <p>У цьому прикладі limit та offset - це аргументи, які дозволяють обмежити кількість та зсунути початок
                            результатів.</p>
                    </li>
                </ol>
                <p>Загалом, GraphQL надає різноманітні типи для визначення структури даних та має потужність управління даними через
                    аргументи та фільтри.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які є різниці між Query та Mutation в GraphQL?
            </div>
            <div class="collapsible-body">
                <ul>
                    <li>
                        <strong>Query</strong>
                        <p>Використовується для читання даних.</p>
                    </li>
                    <li>
                        <strong>Mutation</strong>
                        <p>Використовується для зміни (створення, оновлення, видалення) даних.</p>
                    </li>
                </ul>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як обробляти помилки в GraphQL?
            </div>
            <div class="collapsible-body">
                Помилки повертаються в об'єкті errors відповіді GraphQL. Додаткова інформація (код помилки, повідомлення) може бути додана
                для деталізації проблеми.
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Які інструменти ви використовуєте для розробки GraphQL?
            </div>
            <div class="collapsible-body">
                <p>Інструменти можуть включати GraphiQL для тестування запитів, Apollo Client для роботи з GraphQL на клієнтському боці, та
                    інші бібліотеки та фреймворки.</p>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як ви забезпечуєте безпеку в GraphQL?
            </div>
            <div class="collapsible-body">
                <p>Забезпечення безпеки включає в себе:</p>
                <ul>
                    <li>
                        <strong>Аутентифікацію та авторизацію:</strong>
                        <p>Визначення, хто користувач і чи має він доступ до певних ресурсів.</p>
                    </li>
                    <li>
                        <strong>Обмеження запитів:</strong>
                        <p>Встановлення обмежень на глибину та складність запитів для запобігання перевантаженню сервера.</p>
                    </li>
                    <li>
                        <strong>Валідацію даних:</strong>
                        <p>Перевірка вхідних даних для запобігання атакам.</p>
                    </li>
                </ul>
            </div>
        </li>
        <li>
            <div class="collapsible-header"><i class="material-icons">filter_drama</i>
                Як ви оптимізуєте запити в GraphQL?
            </div>
            <div class="collapsible-body">
                <p>Оптимізація включає в себе:</p>
                <ul>
                    <li>
                        <strong>Батчинг запитів:</strong>
                        <p> Об'єднання декількох запитів в один для зменшення кількості запитів.</p>
                    </li>
                    <li>
                        <strong>Кешування: </strong>
                        <p>Використання кешу для збереження результатів попередніх запитів.</p>
                    </li>
                    <li>
                        <strong>Стратегії вибору даних: </strong>
                        <p>Отримання тільки тієї інформації, яка потрібна, та уникнення over-fetching.</p>
                    </li>
                </ul>
            </div>
        </li>
    </ul>

</div>
<script src="script.js"></script>
</body>
</html>